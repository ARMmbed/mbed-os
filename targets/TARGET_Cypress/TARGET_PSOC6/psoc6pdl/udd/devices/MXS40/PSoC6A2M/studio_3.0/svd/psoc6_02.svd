<?xml version="1.0" encoding="utf-8"?>
<!-- Generator version: 1.6.0.292 -->
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Cypress Semiconductor</vendor>
  <vendorID>Cypress</vendorID>
  <name>psoc6_02</name>
  <series>PSoC6_02</series>
  <version>1.0</version>
  <description>PSoC6_02</description>
  <licenseText>Copyright 2016-2020 Cypress Semiconductor Corporation\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM4</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <vtorPresent>1</vtorPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>0</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral interconnect</description>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>TIMEOUT_CTL</name>
          <description>Timeout control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <description>This field specifies a number of clock cycles (clk_slow). If an AHB-Lite bus transfer takes more than the specified number of cycles (timeout detection), the bus transfer is terminated with an AHB-Lite bus error and a fault is generated (and possibly recorded in the fault report structure(s)).
'0x0000'-'0xfffe': Number of clock cycles.
'0xffff': This value is the default/reset value and specifies that no timeout detection is performed: a bus transfer will never be terminated and a fault will never be generated.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CMD</name>
          <description>Trigger command</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0001FFF</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when ACTIVATE is '1'. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GROUP_SEL</name>
              <description>Specifies the trigger group:
'0'-'15': trigger multiplexer groups.
'16'-'31': trigger 1-to-1 groups.</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_EDGE</name>
              <description>Specifies if the activated  trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive. The trigger reflects TR_CMD.ACTIVATE.
'1': edge sensitive trigger. The trigger is activated for two clk_peri cycles.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_SEL</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.

Note: this field is not used for trigger 1-to-1 groups.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACTIVATE</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL, TR_EDGE and OUT_SEL. HW sets this field to '0' for edge sensitive triggers AFTER the selected trigger is activated for two clk_peri cycles.

Note: when ACTIVATE is '1', SW should not modify the other register fields.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF03FF</resetValue>
          <resetMask>0xC3FF03FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_DIV_SEL</name>
              <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_DIV_SEL is '255' and PA_TYPE_SEL is '3', 'clk_peri' is used as reference.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_TYPE_SEL</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_peri' (typical usage) or to ANY enabled divider.
 
The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_peri'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_peri' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLOCK_CTL[%s]</name>
          <description>Clock control</description>
          <addressOffset>0xC00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>DIV_SEL</name>
              <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
 
If DIV_SEL is '255' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '255' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TYPE_SEL</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control (for 8.0 divider)</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control (for 16.0 divider)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>256</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control (for 16.5 divider)</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>255</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control (for 24.5 divider)</description>
          <addressOffset>0x1C00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000</resetValue>
          <resetMask>0xFF0507FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where the parity is injected.
- On a 32-bit write access to this SRAM address and when ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for PERI protection structure SRAM.
When '1', the parity (PARITY) is used when a write is done to the WORD_ADDR word address of the SRAM.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>11</dim>
          <dimIncrement>32</dimIncrement>
          <name>GR[%s]</name>
          <description>Peripheral group structure</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>CLOCK_CTL</name>
            <description>Clock control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF00</resetMask>
            <fields>
              <field>
                <name>INT8_DIV</name>
                <description>Specifies a group clock divider (from the peripheral clock 'clk_peri' to the group clock 'clk_group[3/4/5/...15]'). Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. 
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_CTL</name>
            <description>Slave control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ENABLED_0</name>
                <description>Peripheral group, slave 0 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_1</name>
                <description>Peripheral group, slave 1 enable. If the slave is disabled, its clock is gated off (constant '0') and its resets are activated.

Note: For peripheral group 0 (the peripheral interconnect, master interface MMIO registers), this field is a constant '1' (SW: R): the slave can NOT be disabled.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_2</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_8</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_9</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_10</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_11</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_12</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_13</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_14</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED_15</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_0</name>
                <description>Peripheral group, slave 0 permanent disable. Setting this bit to 1 has the same effect as setting ENABLED_0 to 0.  However, once set to 1, this bit cannot be changed back to 0 anymore.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_8</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_9</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_10</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_11</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_12</name>
                <description>N/A</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_13</name>
                <description>N/A</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_14</name>
                <description>N/A</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLED_15</name>
                <description>N/A</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>10</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_GR[%s]</name>
          <description>Trigger group</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x13FF</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>7</dim>
          <dimIncrement>1024</dimIncrement>
          <name>TR_1TO1_GR[%s]</name>
          <description>Trigger 1-to-1 group</description>
          <addressOffset>0x0000C000</addressOffset>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1301</resetMask>
            <fields>
              <field>
                <name>TR_SEL</name>
                <description>Specifies input trigger:
'0'': constant signal level '0'.
'1': input trigger.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_INV</name>
                <description>Specifies if the output trigger is inverted.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TR_EDGE</name>
                <description>Specifies if the (inverted) output trigger is treated as a level sensitive or edge sensitive  trigger.
'0': level sensitive.
'1': edge sensitive trigger. The (inverted) output trigger duration needs to be at least 2 cycles on the consumer clock. the(inverted) output trigger is synchronized to the consumer clock and a two cycle pulse is generated on the consumer clock.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DBG_FREEZE_EN</name>
                <description>Specifies if the output trigger is blocked in debug mode. When set high tr_dbg_freeze will block the output trigger generation.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PERI_MS</name>
      <description>Peripheral interconnect, master interface</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_PR[%s]</name>
          <description>Programmable protection structure pair</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>229</dim>
          <dimIncrement>64</dimIncrement>
          <name>PPU_FX[%s]</name>
          <description>Fixed protection structure pair</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>SL_ADDR</name>
            <description>Slave region, base address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFC</resetMask>
            <fields>
              <field>
                <name>ADDR30</name>
                <description>This field specifies the base address of the slave region. The region size is defined by SL_SIZE.REGION_SIZE. A region of n Bytes must be n Byte aligned. Therefore, some of the lesser significant address bits of ADDR30 must be '0's. E.g., a 64 KB address region (REGION_SIZE is '15') must be 64 KByte aligned, and ADDR30[13:0] must be '0's.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_SIZE</name>
            <description>Slave region, size</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x80000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the slave region:
'0': Undefined.
'1': 4 B region (this is the smallest region size).
'2': 8 B region
'3': 16 B region
'4': 32 B region
'5': 64 B region
'6': 128 B region
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'29': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Slave region enable:
'0': Disabled. A disabled region will never result in a match on the transfer address.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT0</name>
            <description>Slave attributes 0</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT1</name>
            <description>Slave attributes 1</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT2</name>
            <description>Slave attributes 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SL_ATT3</name>
            <description>Slave attributes 3</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ADDR</name>
            <description>Master region, base address</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFC0</resetMask>
            <fields>
              <field>
                <name>ADDR26</name>
                <description>This field specifies the base address of the master region. The base address of the region is the address of the SL_ADDR register.</description>
                <bitRange>[31:6]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_SIZE</name>
            <description>Master region, size</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x85000000</resetValue>
            <resetMask>0x9F000000</resetMask>
            <fields>
              <field>
                <name>REGION_SIZE</name>
                <description>This field specifies the size of the master region:
'5': 64 B region

The master region includes the SL_ADDR, SL_SIZE, SL_ATT0, ..., SL_ATT3, MS_ADDR, MS_SIZE, MS_ATT0, ..., MS_ATT3 registers. Therefore, the access privileges for all these registers is determined by MS_ATT0, ..., MS_ATT3.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Master region enable:
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT0</name>
            <description>Master attributes 0</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC0_UR</name>
                <description>Protection context 0, user read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_UW</name>
                <description>Protection context 0, user write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PR</name>
                <description>Protection context 0, privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_PW</name>
                <description>Protection context 0, privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC0_NS</name>
                <description>Protection context 0, non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UR</name>
                <description>Protection context 1, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_UW</name>
                <description>Protection context 1, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_PR</name>
                <description>Protection context 1, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC1_PW</name>
                <description>Protection context 1, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC1_NS</name>
                <description>Protection context 1, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_UR</name>
                <description>Protection context 2, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_UW</name>
                <description>Protection context 2, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_PR</name>
                <description>Protection context 2, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC2_PW</name>
                <description>Protection context 2, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC2_NS</name>
                <description>Protection context 2, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_UR</name>
                <description>Protection context 3, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_UW</name>
                <description>Protection context 3, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_PR</name>
                <description>Protection context 3, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC3_PW</name>
                <description>Protection context 3, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC3_NS</name>
                <description>Protection context 3, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT1</name>
            <description>Master attributes 1</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC4_UR</name>
                <description>Protection context 4, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_UW</name>
                <description>Protection context 4, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_PR</name>
                <description>Protection context 4, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC4_PW</name>
                <description>Protection context 4, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC4_NS</name>
                <description>Protection context 4, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_UR</name>
                <description>Protection context 5, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_UW</name>
                <description>Protection context 5, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_PR</name>
                <description>Protection context 5, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC5_PW</name>
                <description>Protection context 5, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC5_NS</name>
                <description>Protection context 5, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_UR</name>
                <description>Protection context 6, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_UW</name>
                <description>Protection context 6, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_PR</name>
                <description>Protection context 6, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC6_PW</name>
                <description>Protection context 6, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC6_NS</name>
                <description>Protection context 6, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_UR</name>
                <description>Protection context 7, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_UW</name>
                <description>Protection context 7, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_PR</name>
                <description>Protection context 7, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC7_PW</name>
                <description>Protection context 7, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC7_NS</name>
                <description>Protection context 7, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT2</name>
            <description>Master attributes 2</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC8_UR</name>
                <description>Protection context 8, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_UW</name>
                <description>Protection context 8, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_PR</name>
                <description>Protection context 8, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC8_PW</name>
                <description>Protection context 8, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC8_NS</name>
                <description>Protection context 8, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_UR</name>
                <description>Protection context 9, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_UW</name>
                <description>Protection context 9, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_PR</name>
                <description>Protection context 9, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC9_PW</name>
                <description>Protection context 9, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC9_NS</name>
                <description>Protection context 9, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_UR</name>
                <description>Protection context 10, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_UW</name>
                <description>Protection context 10, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_PR</name>
                <description>Protection context 10, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC10_PW</name>
                <description>Protection context 10, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC10_NS</name>
                <description>Protection context 10, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_UR</name>
                <description>Protection context 11, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_UW</name>
                <description>Protection context 11, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_PR</name>
                <description>Protection context 11, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC11_PW</name>
                <description>Protection context 11, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC11_NS</name>
                <description>Protection context 11, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS_ATT3</name>
            <description>Master attributes 3</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1F1F1F1F</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>PC12_UR</name>
                <description>Protection context 12, user read enable.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_UW</name>
                <description>Protection context 12, user write enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_PR</name>
                <description>Protection context 12, privileged read enable.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC12_PW</name>
                <description>Protection context 12, privileged write enable.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC12_NS</name>
                <description>Protection context 12, non-secure.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_UR</name>
                <description>Protection context 13, user read enable.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_UW</name>
                <description>Protection context 13, user write enable.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_PR</name>
                <description>Protection context 13, privileged read enable.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC13_PW</name>
                <description>Protection context 13, privileged write enable.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC13_NS</name>
                <description>Protection context 13, non-secure.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_UR</name>
                <description>Protection context 14, user read enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_UW</name>
                <description>Protection context 14, user write enable.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_PR</name>
                <description>Protection context 14, privileged read enable.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC14_PW</name>
                <description>Protection context 14, privileged write enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC14_NS</name>
                <description>Protection context 14, non-secure.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_UR</name>
                <description>Protection context 15, user read enable.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_UW</name>
                <description>Protection context 15, user write enable.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_PR</name>
                <description>Protection context 15, privileged read enable.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC15_PW</name>
                <description>Protection context 15, privileged write enable.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC15_NS</name>
                <description>Protection context 15, non-secure.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU subsystem (CPUSS)</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO Port Interrupt #0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO Port Interrupt #1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO Port Interrupt #2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <description>GPIO Port Interrupt #3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_4</name>
        <description>GPIO Port Interrupt #4</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_5</name>
        <description>GPIO Port Interrupt #5</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_6</name>
        <description>GPIO Port Interrupt #6</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_7</name>
        <description>GPIO Port Interrupt #7</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_8</name>
        <description>GPIO Port Interrupt #8</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_9</name>
        <description>GPIO Port Interrupt #9</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_10</name>
        <description>GPIO Port Interrupt #10</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_11</name>
        <description>GPIO Port Interrupt #11</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_12</name>
        <description>GPIO Port Interrupt #12</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_13</name>
        <description>GPIO Port Interrupt #13</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_14</name>
        <description>GPIO Port Interrupt #14</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO All Ports</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_vdd</name>
        <description>GPIO Supply Detect Interrupt</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <description>Low Power Comparator Interrupt</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>scb_8_interrupt</name>
        <description>Serial Communication Block #8 (DeepSleep capable)</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_0</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_mcwdt_1</name>
        <description>Multi Counter Watchdog Timer interrupt</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_backup</name>
        <description>Backup domain interrupt</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt</name>
        <description>Other combined Interrupts for SRSS (LVD, WDT, CLKCAL)</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_0</name>
        <description>CPUSS Inter Process Communication Interrupt #0</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_1</name>
        <description>CPUSS Inter Process Communication Interrupt #1</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_2</name>
        <description>CPUSS Inter Process Communication Interrupt #2</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_3</name>
        <description>CPUSS Inter Process Communication Interrupt #3</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_4</name>
        <description>CPUSS Inter Process Communication Interrupt #4</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_5</name>
        <description>CPUSS Inter Process Communication Interrupt #5</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_6</name>
        <description>CPUSS Inter Process Communication Interrupt #6</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_7</name>
        <description>CPUSS Inter Process Communication Interrupt #7</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_8</name>
        <description>CPUSS Inter Process Communication Interrupt #8</description>
        <value>31</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_9</name>
        <description>CPUSS Inter Process Communication Interrupt #9</description>
        <value>32</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_10</name>
        <description>CPUSS Inter Process Communication Interrupt #10</description>
        <value>33</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_11</name>
        <description>CPUSS Inter Process Communication Interrupt #11</description>
        <value>34</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_12</name>
        <description>CPUSS Inter Process Communication Interrupt #12</description>
        <value>35</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_13</name>
        <description>CPUSS Inter Process Communication Interrupt #13</description>
        <value>36</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_14</name>
        <description>CPUSS Inter Process Communication Interrupt #14</description>
        <value>37</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_ipc_15</name>
        <description>CPUSS Inter Process Communication Interrupt #15</description>
        <value>38</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>Serial Communication Block #0</description>
        <value>39</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>Serial Communication Block #1</description>
        <value>40</value>
      </interrupt>
      <interrupt>
        <name>scb_2_interrupt</name>
        <description>Serial Communication Block #2</description>
        <value>41</value>
      </interrupt>
      <interrupt>
        <name>scb_3_interrupt</name>
        <description>Serial Communication Block #3</description>
        <value>42</value>
      </interrupt>
      <interrupt>
        <name>scb_4_interrupt</name>
        <description>Serial Communication Block #4</description>
        <value>43</value>
      </interrupt>
      <interrupt>
        <name>scb_5_interrupt</name>
        <description>Serial Communication Block #5</description>
        <value>44</value>
      </interrupt>
      <interrupt>
        <name>scb_6_interrupt</name>
        <description>Serial Communication Block #6</description>
        <value>45</value>
      </interrupt>
      <interrupt>
        <name>scb_7_interrupt</name>
        <description>Serial Communication Block #7</description>
        <value>46</value>
      </interrupt>
      <interrupt>
        <name>scb_9_interrupt</name>
        <description>Serial Communication Block #9</description>
        <value>47</value>
      </interrupt>
      <interrupt>
        <name>scb_10_interrupt</name>
        <description>Serial Communication Block #10</description>
        <value>48</value>
      </interrupt>
      <interrupt>
        <name>scb_11_interrupt</name>
        <description>Serial Communication Block #11</description>
        <value>49</value>
      </interrupt>
      <interrupt>
        <name>scb_12_interrupt</name>
        <description>Serial Communication Block #12</description>
        <value>50</value>
      </interrupt>
      <interrupt>
        <name>csd_interrupt</name>
        <description>CSD (Capsense) interrupt</description>
        <value>51</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_0</name>
        <description>CPUSS DMAC, Channel #0</description>
        <value>52</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_1</name>
        <description>CPUSS DMAC, Channel #1</description>
        <value>53</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_2</name>
        <description>CPUSS DMAC, Channel #2</description>
        <value>54</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dmac_3</name>
        <description>CPUSS DMAC, Channel #3</description>
        <value>55</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_0</name>
        <description>CPUSS DataWire #0, Channel #0</description>
        <value>56</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_1</name>
        <description>CPUSS DataWire #0, Channel #1</description>
        <value>57</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_2</name>
        <description>CPUSS DataWire #0, Channel #2</description>
        <value>58</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_3</name>
        <description>CPUSS DataWire #0, Channel #3</description>
        <value>59</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_4</name>
        <description>CPUSS DataWire #0, Channel #4</description>
        <value>60</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_5</name>
        <description>CPUSS DataWire #0, Channel #5</description>
        <value>61</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_6</name>
        <description>CPUSS DataWire #0, Channel #6</description>
        <value>62</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_7</name>
        <description>CPUSS DataWire #0, Channel #7</description>
        <value>63</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_8</name>
        <description>CPUSS DataWire #0, Channel #8</description>
        <value>64</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_9</name>
        <description>CPUSS DataWire #0, Channel #9</description>
        <value>65</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_10</name>
        <description>CPUSS DataWire #0, Channel #10</description>
        <value>66</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_11</name>
        <description>CPUSS DataWire #0, Channel #11</description>
        <value>67</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_12</name>
        <description>CPUSS DataWire #0, Channel #12</description>
        <value>68</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_13</name>
        <description>CPUSS DataWire #0, Channel #13</description>
        <value>69</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_14</name>
        <description>CPUSS DataWire #0, Channel #14</description>
        <value>70</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_15</name>
        <description>CPUSS DataWire #0, Channel #15</description>
        <value>71</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_16</name>
        <description>CPUSS DataWire #0, Channel #16</description>
        <value>72</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_17</name>
        <description>CPUSS DataWire #0, Channel #17</description>
        <value>73</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_18</name>
        <description>CPUSS DataWire #0, Channel #18</description>
        <value>74</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_19</name>
        <description>CPUSS DataWire #0, Channel #19</description>
        <value>75</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_20</name>
        <description>CPUSS DataWire #0, Channel #20</description>
        <value>76</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_21</name>
        <description>CPUSS DataWire #0, Channel #21</description>
        <value>77</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_22</name>
        <description>CPUSS DataWire #0, Channel #22</description>
        <value>78</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_23</name>
        <description>CPUSS DataWire #0, Channel #23</description>
        <value>79</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_24</name>
        <description>CPUSS DataWire #0, Channel #24</description>
        <value>80</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_25</name>
        <description>CPUSS DataWire #0, Channel #25</description>
        <value>81</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_26</name>
        <description>CPUSS DataWire #0, Channel #26</description>
        <value>82</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_27</name>
        <description>CPUSS DataWire #0, Channel #27</description>
        <value>83</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw0_28</name>
        <description>CPUSS DataWire #0, Channel #28</description>
        <value>84</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_0</name>
        <description>CPUSS DataWire #1, Channel #0</description>
        <value>85</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_1</name>
        <description>CPUSS DataWire #1, Channel #1</description>
        <value>86</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_2</name>
        <description>CPUSS DataWire #1, Channel #2</description>
        <value>87</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_3</name>
        <description>CPUSS DataWire #1, Channel #3</description>
        <value>88</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_4</name>
        <description>CPUSS DataWire #1, Channel #4</description>
        <value>89</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_5</name>
        <description>CPUSS DataWire #1, Channel #5</description>
        <value>90</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_6</name>
        <description>CPUSS DataWire #1, Channel #6</description>
        <value>91</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_7</name>
        <description>CPUSS DataWire #1, Channel #7</description>
        <value>92</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_8</name>
        <description>CPUSS DataWire #1, Channel #8</description>
        <value>93</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_9</name>
        <description>CPUSS DataWire #1, Channel #9</description>
        <value>94</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_10</name>
        <description>CPUSS DataWire #1, Channel #10</description>
        <value>95</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_11</name>
        <description>CPUSS DataWire #1, Channel #11</description>
        <value>96</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_12</name>
        <description>CPUSS DataWire #1, Channel #12</description>
        <value>97</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_13</name>
        <description>CPUSS DataWire #1, Channel #13</description>
        <value>98</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_14</name>
        <description>CPUSS DataWire #1, Channel #14</description>
        <value>99</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_15</name>
        <description>CPUSS DataWire #1, Channel #15</description>
        <value>100</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_16</name>
        <description>CPUSS DataWire #1, Channel #16</description>
        <value>101</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_17</name>
        <description>CPUSS DataWire #1, Channel #17</description>
        <value>102</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_18</name>
        <description>CPUSS DataWire #1, Channel #18</description>
        <value>103</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_19</name>
        <description>CPUSS DataWire #1, Channel #19</description>
        <value>104</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_20</name>
        <description>CPUSS DataWire #1, Channel #20</description>
        <value>105</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_21</name>
        <description>CPUSS DataWire #1, Channel #21</description>
        <value>106</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_22</name>
        <description>CPUSS DataWire #1, Channel #22</description>
        <value>107</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_23</name>
        <description>CPUSS DataWire #1, Channel #23</description>
        <value>108</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_24</name>
        <description>CPUSS DataWire #1, Channel #24</description>
        <value>109</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_25</name>
        <description>CPUSS DataWire #1, Channel #25</description>
        <value>110</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_26</name>
        <description>CPUSS DataWire #1, Channel #26</description>
        <value>111</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_27</name>
        <description>CPUSS DataWire #1, Channel #27</description>
        <value>112</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_dw1_28</name>
        <description>CPUSS DataWire #1, Channel #28</description>
        <value>113</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_fault_0</name>
        <description>CPUSS Fault Structure Interrupt #0</description>
        <value>114</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_fault_1</name>
        <description>CPUSS Fault Structure Interrupt #1</description>
        <value>115</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_crypto</name>
        <description>CRYPTO Accelerator Interrupt</description>
        <value>116</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fm</name>
        <description>FLASH Macro Interrupt</description>
        <value>117</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_fp</name>
        <description>Floating Point operation fault</description>
        <value>118</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_0</name>
        <description>CM0+ CTI #0</description>
        <value>119</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_1</name>
        <description>CM0+ CTI #1</description>
        <value>120</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_0</name>
        <description>CM4 CTI #0</description>
        <value>121</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_1</name>
        <description>CM4 CTI #1</description>
        <value>122</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>123</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>124</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>125</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>126</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_4</name>
        <description>TCPWM #0, Counter #4</description>
        <value>127</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_5</name>
        <description>TCPWM #0, Counter #5</description>
        <value>128</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_6</name>
        <description>TCPWM #0, Counter #6</description>
        <value>129</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_0_interrupts_7</name>
        <description>TCPWM #0, Counter #7</description>
        <value>130</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_0</name>
        <description>TCPWM #1, Counter #0</description>
        <value>131</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_1</name>
        <description>TCPWM #1, Counter #1</description>
        <value>132</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_2</name>
        <description>TCPWM #1, Counter #2</description>
        <value>133</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_3</name>
        <description>TCPWM #1, Counter #3</description>
        <value>134</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_4</name>
        <description>TCPWM #1, Counter #4</description>
        <value>135</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_5</name>
        <description>TCPWM #1, Counter #5</description>
        <value>136</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_6</name>
        <description>TCPWM #1, Counter #6</description>
        <value>137</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_7</name>
        <description>TCPWM #1, Counter #7</description>
        <value>138</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_8</name>
        <description>TCPWM #1, Counter #8</description>
        <value>139</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_9</name>
        <description>TCPWM #1, Counter #9</description>
        <value>140</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_10</name>
        <description>TCPWM #1, Counter #10</description>
        <value>141</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_11</name>
        <description>TCPWM #1, Counter #11</description>
        <value>142</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_12</name>
        <description>TCPWM #1, Counter #12</description>
        <value>143</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_13</name>
        <description>TCPWM #1, Counter #13</description>
        <value>144</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_14</name>
        <description>TCPWM #1, Counter #14</description>
        <value>145</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_15</name>
        <description>TCPWM #1, Counter #15</description>
        <value>146</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_16</name>
        <description>TCPWM #1, Counter #16</description>
        <value>147</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_17</name>
        <description>TCPWM #1, Counter #17</description>
        <value>148</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_18</name>
        <description>TCPWM #1, Counter #18</description>
        <value>149</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_19</name>
        <description>TCPWM #1, Counter #19</description>
        <value>150</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_20</name>
        <description>TCPWM #1, Counter #20</description>
        <value>151</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_21</name>
        <description>TCPWM #1, Counter #21</description>
        <value>152</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_22</name>
        <description>TCPWM #1, Counter #22</description>
        <value>153</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_1_interrupts_23</name>
        <description>TCPWM #1, Counter #23</description>
        <value>154</value>
      </interrupt>
      <interrupt>
        <name>pass_interrupt_sar</name>
        <description>SAR ADC interrupt</description>
        <value>155</value>
      </interrupt>
      <interrupt>
        <name>audioss_0_interrupt_i2s</name>
        <description>I2S0 Audio interrupt</description>
        <value>156</value>
      </interrupt>
      <interrupt>
        <name>audioss_0_interrupt_pdm</name>
        <description>PDM0/PCM0 Audio interrupt</description>
        <value>157</value>
      </interrupt>
      <interrupt>
        <name>audioss_1_interrupt_i2s</name>
        <description>I2S1 Audio interrupt</description>
        <value>158</value>
      </interrupt>
      <interrupt>
        <name>profile_interrupt</name>
        <description>Energy Profiler interrupt</description>
        <value>159</value>
      </interrupt>
      <interrupt>
        <name>smif_interrupt</name>
        <description>Serial Memory Interface interrupt</description>
        <value>160</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_hi</name>
        <description>USB Interrupt</description>
        <value>161</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_med</name>
        <description>USB Interrupt</description>
        <value>162</value>
      </interrupt>
      <interrupt>
        <name>usb_interrupt_lo</name>
        <description>USB Interrupt</description>
        <value>163</value>
      </interrupt>
      <interrupt>
        <name>sdhc_0_interrupt_wakeup</name>
        <description>SDIO wakeup interrupt for mxsdhc</description>
        <value>164</value>
      </interrupt>
      <interrupt>
        <name>sdhc_0_interrupt_general</name>
        <description>Consolidated interrupt for mxsdhc for everything else</description>
        <value>165</value>
      </interrupt>
      <interrupt>
        <name>sdhc_1_interrupt_wakeup</name>
        <description>EEMC wakeup interrupt for mxsdhc, not used</description>
        <value>166</value>
      </interrupt>
      <interrupt>
        <name>sdhc_1_interrupt_general</name>
        <description>Consolidated interrupt for mxsdhc for everything else</description>
        <value>167</value>
      </interrupt>
      <registers>
        <register>
          <name>IDENTITY</name>
          <description>Identity</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>This field specifies the protection context of the transfer that reads the register.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MS</name>
              <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x13</resetValue>
          <resetMask>0x13</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_DONE</name>
              <description>After a PWR_MODE change this flag indicates if the new power mode has taken effect or not. 
Note: this flag can also change as a result of  a change in debug power up req</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CLOCK_CTL</name>
          <description>CM4 clock control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00</resetMask>
          <fields>
            <field>
              <name>FAST_INT_DIV</name>
              <description>Specifies the fast clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_fast'). Integer division by (1+FAST_INT_DIV). Allows for integer divisions in the range [1, 256] (FAST_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CTL</name>
          <description>CM4 control</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F000000</resetMask>
          <fields>
            <field>
              <name>IOC_MASK</name>
              <description>CPU floating point unit (FPU) exception mask for the CPU's FPCSR.IOC 'invalid operation' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: the ARM architecture does NOT support FPU exceptions; i.e. there is no precise FPU exception handler. Instead, FPU conditions are captured in the CPU's FPCSR register and the conditions are provided as CPU interface signals. The interface signals are 'masked' with the fields a provide by this register (CM7_0_CTL). The 'masked' signals are reduced/OR-ed into a single CPU floating point interrupt signal. The associated CPU interrupt handler allows for imprecise handling of FPU exception conditions.

Note: the CPU's FPCSR exception conditions are 'sticky'. Typically, the CPU FPU interrupt handler will clear the exception condition(s) to '0'.

Note: by default, the FPU exception masks are '0'. Therefore, FPU exception conditions will NOT activate the CPU's floating point interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DZC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.DZC 'divide by zero' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.OFC 'overflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UFC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.UFC 'underflow' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IXC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IXC 'inexact' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt.

Note: the 'inexact' condition is set as a result of rounding. Rounding may occur frequently and is typically not an error condition. To prevent frequent CPU FPU interrupts as a result of rounding, this field is typically set to '0'.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IDC_MASK</name>
              <description>CPU FPU exception mask for the CPU's FPCSR.IDC 'input denormalized' exception condition:
'0': The CPU's exception condition does NOT activate the CPU's floating point interrupt. 
'1': the CPU's exception condition activates the CPU's floating point interrupt. 

Note: if the CPU FPCSR.FZ field is set to '1', denormalized inputs are 'flushed to zero'. Dependent on the FPU algorithm, this may or may not occur frequently. To prevent frequent CPU FPU interrupts as a result of denormalized inputs, this field may be set to '0'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT0_STATUS</name>
          <description>CM4 interrupt 0 status</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 0.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT1_STATUS</name>
          <description>CM4 interrupt 1 status</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT2_STATUS</name>
          <description>CM4 interrupt 2 status</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT3_STATUS</name>
          <description>CM4 interrupt 3 status</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT4_STATUS</name>
          <description>CM4 interrupt 4 status</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT5_STATUS</name>
          <description>CM4 interrupt 5 status</description>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT6_STATUS</name>
          <description>CM4 interrupt 6 status</description>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_INT7_STATUS</name>
          <description>CM4 interrupt 7 status</description>
          <addressOffset>0x11C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM4 activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_VECTOR_TABLE_BASE</name>
          <description>CM4 vector table base</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFC00</resetMask>
          <fields>
            <field>
              <name>ADDR22</name>
              <description>Address of CM4 vector table. This register is used for CM4 warm and cold boot purposes: the CM0+ CPU initializes the CM4_VECTOR_TABLE_BASE register and the CM4 boot code uses the register to initialize the CM4 internal VTOR register.

Note: the CM4 vector table is at an address that is a 1024 B multiple.</description>
              <bitRange>[31:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_NMI_CTL[%s]</name>
          <description>CM4 NMI control</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Set Power mode for UDBs</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM4_PWR_CTL</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UDB_PWR_DELAY_CTL</name>
          <description>UDB power control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CTL</name>
          <description>CM0+ control</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050002</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>SLV_STALL</name>
              <description>Processor debug access control:
'0': Access.
'1': Stall access.

This field is used to stall/delay debug accesses. This is useful to protect execution of code that needs to be protected from debug accesses.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Processor enable:
'0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM0+ reset, followed by a CM0+ warm boot.
'1': Enabled.
Note: The intent is that this bit is modified only through an external probe or by the CM4 while the CM0+ is in Sleep or DeepSleep power mode. If this field is cleared to '0' by the CM0+ itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).

Note: The CM0+ CPU has a AIRCR.SYSRESETREQ register field that allows the CM0+ to reset the complete device (ENABLED only disables/enables the CM0+), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this CM0_CTL register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ status</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SLEEPING</name>
              <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
- Active power mode: SLEEPING is '0'.
- Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
- DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CLOCK_CTL</name>
          <description>CM0+ clock control</description>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF00</resetMask>
          <fields>
            <field>
              <name>SLOW_INT_DIV</name>
              <description>Specifies the slow clock divider (from the peripheral clock 'clk_peri' to the slow clock 'clk_slow'). Integer division by (1+SLOW_INT_DIV). Allows for integer divisions in the range [1, 256] (SLOW_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PERI_INT_DIV</name>
              <description>Specifies the peripheral clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_peri'). Integer division by (1+PERI_INT_DIV). Allows for integer divisions in the range [1, 256] (PERI_INT_DIV is in the range [0, 255]).
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.

Note that Fperi &lt;= Fperi_max. Fperi_max is likely to be smaller than Fhf_max. In other words, if Fhf = Fhf_max, PERI_INT_DIV should not be set to '0'.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT0_STATUS</name>
          <description>CM0+ interrupt 0 status</description>
          <addressOffset>0x1100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 0.

Multiple system interrupts can be mapped on the same CPU interrupt. The selected system interrupt is the system interrupt with the lowest system interrupt index that has an activated interrupt request at the time of the fetch (system_interrupts[SYSTEM_INT_IDX] is '1'). 

The CPU interrupt handler SW can read SYSTEM_INT_IDX to determine the system interrupt that activated the handler.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>Valid indication for SYSTEM_INT_IDX. When '0', no system interrupt for CPU interrupt 0 is valid/activated.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT1_STATUS</name>
          <description>CM0+ interrupt 1 status</description>
          <addressOffset>0x1104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 1.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT2_STATUS</name>
          <description>CM0+ interrupt 2 status</description>
          <addressOffset>0x1108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 2.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT3_STATUS</name>
          <description>CM0+ interrupt 3 status</description>
          <addressOffset>0x110C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 3.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT4_STATUS</name>
          <description>CM0+ interrupt 4 status</description>
          <addressOffset>0x1110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 4.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT5_STATUS</name>
          <description>CM0+ interrupt 5 status</description>
          <addressOffset>0x1114</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 5.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT6_STATUS</name>
          <description>CM0+ interrupt 6 status</description>
          <addressOffset>0x1118</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 6.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_INT7_STATUS</name>
          <description>CM0+ interrupt 7 status</description>
          <addressOffset>0x111C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>Lowest CM0+ activated system interrupt index for CPU interrupt 7.

See description of CM0_INT0_STATUS.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSTEM_INT_VALID</name>
              <description>See description of CM0_INT0_STATUS.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_VECTOR_TABLE_BASE</name>
          <description>CM0+ vector table base</description>
          <addressOffset>0x1120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>ADDR24</name>
              <description>Address of CM0+ vector table. This register is used for CM0+ warm boot purposes: the CM0+ warm boot code uses the register to initialize the CM0+ internal VTOR register.

Note: the CM0+ vector table is at an address that is a 256 B multiple.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>4</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_NMI_CTL[%s]</name>
          <description>CM0+ NMI control</description>
          <addressOffset>0x1140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FF</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>SYSTEM_INT_IDX</name>
              <description>System interrupt select for CPU NMI. The reset value ('1023') ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050001</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Switch CM4 off
Power off, clock off, isolate, reset and no retain.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Reset CM4
Clock off, no isolated, no retain and reset.

Note: The CM4 CPU has a AIRCR.SYSRESETREQ register field that allows the CM4 to reset the complete device (RESET only resets the CM4), resulting in a warm boot.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM4 in Retained mode
This can only become effective if CM4 is in SleepDeep mode. Check PWR_DONE flag to see if CM4 RETAINED state has been reached.
Power off, clock off, isolate, no reset and retain.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Switch CM4 on.
Power on, clock on, no isolate, no reset and no retain.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_PWR_DELAY_CTL</name>
          <description>CM4 power control</description>
          <addressOffset>0x1204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_CTL0</name>
          <description>RAM 0 control</description>
          <addressOffset>0x1300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection for system SRAM 0.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of system SRAM 0.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM0_STATUS</name>
          <description>RAM 0 status</description>
          <addressOffset>0x1304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>RAM0_PWR_MACRO_CTL[%s]</name>
          <description>RAM 0 power control</description>
          <addressOffset>0x1340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>SRAM Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Turn OFF the SRAM. This will trun OFF both array and periphery power of the SRAM and SRAM memory contents are lost.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Keep SRAM in Retained mode. This will turn OFF the SRAM periphery power, but array power is ON to retain memory contents.
The SRAM contents will be retained in DeepSleep system power mode.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable SRAM for regular operation. 
The SRAM contents will be retained in DeepSleep system power mode.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL0</name>
          <description>RAM 1 control</description>
          <addressOffset>0x1380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_STATUS</name>
          <description>RAM 1 status</description>
          <addressOffset>0x1384</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_PWR_CTL</name>
          <description>RAM 1 power control</description>
          <addressOffset>0x1388</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See RAM0_PWR_MACRO_CTL.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_CTL0</name>
          <description>RAM 2 control</description>
          <addressOffset>0x13A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30001</resetValue>
          <resetMask>0x70303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>See RAM0_CTL.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_STATUS</name>
          <description>RAM 2 status</description>
          <addressOffset>0x13A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>See RAM0_STATUS.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM2_PWR_CTL</name>
          <description>RAM 2 power control</description>
          <addressOffset>0x13A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Power mode.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See RAM0_PWR_MACRO_CTL.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>See RAM0_PWR_MACRO_CTL.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_PWR_DELAY_CTL</name>
          <description>Power up delay used for all SRAM power domains</description>
          <addressOffset>0x13C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x96</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>UP</name>
              <description>Number clock cycles (clk_slow) delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control</description>
          <addressOffset>0x13C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x303</resetMask>
          <fields>
            <field>
              <name>SLOW_WS</name>
              <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.

Timing paths to and from the memory have a (fixed) minimum duration  that always needs to be considered/met. The 'clk_hf' clock domain frequency determines this field's value such that the timing paths minimum duration is met. 
ROM_CTL.SLOW_WS = '0' when clk_hf &lt;=100 MHz.
ROM_CTL.SLOW_WS = '1' when 100MHz &lt; clk_hf &lt;=clk_hf_max.
Note: clk_hf_max depends on the target device. Refer datasheet.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_WS</name>
              <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.
ROM_CTL.FAST_WS = '0' when clk_hf &lt;= clk_hf_max.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x13C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM address and when the corresponding RAM0/RAM1/RAM2_CTL0.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.
This field needs to be written with the offset address within the memory, divided by 4.
For example, if the RAM1 start address is 0x08010000, and an error is to be injected to address 0x08010040, then this field needs to configured to 0x000010.</description>
              <bitRange>[24:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRODUCT_ID</name>
          <description>Product identifier and version (same as CoreSight RomTables)</description>
          <addressOffset>0x1400</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FAMILY_ID</name>
              <description>Family ID. Common ID for a product family.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MAJOR_REV</name>
              <description>Major Revision, starts with 1, increments with all layer tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MINOR_REV</name>
              <description>Minor Revision, starts with 1, increments with metal layer only tape-out (implemented with metal ECO-able  tie-off)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DP_STATUS</name>
          <description>Debug port status</description>
          <addressOffset>0x1410</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x4</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>SWJ_CONNECTED</name>
              <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
'0': Not connected/not active.
'1': Connected/active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_DEBUG_EN</name>
              <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SWJ_JTAG_SEL</name>
              <description>Specifies if the JTAG or SWD interface is selected. This signal is valid when DP_CTL.PTM_SEL is '0' (SWJ mode selected) and SWJ_CONNECTED is '1' (SWJ is connected).
'0': SWD selected.
'1': JTAG selected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AP_CTL</name>
          <description>Access port control</description>
          <addressOffset>0x1414</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70007</resetMask>
          <fields>
            <field>
              <name>CM0_ENABLE</name>
              <description>Enables the CM0 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM4_ENABLE</name>
              <description>Enables the CM4 AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_ENABLE</name>
              <description>Enables the system AP interface:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM0_DISABLE</name>
              <description>Disables the CM0 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM0_DISABLE is '0' and CM0_ENABLE is '1'.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CM4_DISABLE</name>
              <description>Disables the CM4 AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when CM4_DISABLE is '0' and CM4_ENABLE is '1'.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYS_DISABLE</name>
              <description>Disables the system AP interface:
'0': Enabled.
'1': Disabled.

Typically, this field is set by the Cypress boot code with information from eFUSE. The access port is only enabled when SYS_DISABLE is '0' and SYS_ENABLE is '1'.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUFF_CTL</name>
          <description>Buffer control</description>
          <addressOffset>0x1500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WRITE_BUFF</name>
              <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
'0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
'1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSTICK_CTL</name>
          <description>SysTick timer control</description>
          <addressOffset>0x1600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000147</resetValue>
          <resetMask>0xC3FFFFFF</resetMask>
          <fields>
            <field>
              <name>TENMS</name>
              <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SOURCE</name>
              <description>Specifies an external clock source:
'0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
'1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
'3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').

Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKEW</name>
              <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
'0': Precise.
'1': Imprecise.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOREF</name>
              <description>Specifies if an external clock source is provided:
'0': An external clock source is provided. 
'1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MBIST_STAT</name>
          <description>Memory BIST status</description>
          <addressOffset>0x1704</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>SFP_READY</name>
              <description>Flag indicating the BIST run is done. Note that after starting a BIST run this flag must be set before a new run can be started. For the first BIST run this will be 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFP_FAIL</name>
              <description>Report status of the BIST run, only valid if SFP_READY=1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_SET</name>
          <description>Calibration support set and read</description>
          <addressOffset>0x1800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read without side effect, write 1 to set</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_SUP_CLR</name>
          <description>Calibration support clear and reset</description>
          <addressOffset>0x1804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Read side effect: when read all bits are cleared, write 1 to clear a specific bit 
Note: no exception for the debug host, it also causes the read side effect</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC_CTL</name>
          <description>CM0+ protection context control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VALID</name>
              <description>Valid fields for the protection context handler CM0_PCi_HANDLER registers:
Bit 0: Valid field for CM0_PC0_HANDLER.
Bit 1: Valid field for CM0_PC1_HANDLER.
Bit 2: Valid field for CM0_PC2_HANDLER.
Bit 3: Valid field for CM0_PC3_HANDLER.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC0_HANDLER</name>
          <description>CM0+ protection context 0 handler</description>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC1_HANDLER</name>
          <description>CM0+ protection context 1 handler</description>
          <addressOffset>0x2044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 1 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC2_HANDLER</name>
          <description>CM0+ protection context 2 handler</description>
          <addressOffset>0x2048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 2 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_PC3_HANDLER</name>
          <description>CM0+ protection context 3 handler</description>
          <addressOffset>0x204C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Address of the protection context 3 handler.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection status</description>
          <addressOffset>0x20C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>STATE</name>
              <description>Protection state:
'0': UNKNOWN.
'1': VIRGIN.
'2': NORMAL.
'3': SECURE.
'4': DEAD.

The following state transitions are allowed (and enforced by HW):
- UNKNOWN =&gt; VIRGIN/NORMAL/SECURE/DEAD
- NORMAL =&gt; DEAD
- SECURE =&gt; DEAD
An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ROM_CTL</name>
          <description>ROM trim control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_RAM_CTL</name>
          <description>RAM trim control</description>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>N/A</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM0_SYSTEM_INT_CTL[%s]</name>
          <description>CM0+ system interrupt control</description>
          <addressOffset>0x8000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>CPU interrupt index (legal range [0, 7]). This field specifies to which CPU interrupt the system interrupt is mapped. E.g., if CPU_INT_IDX is '6', the system interrupt is mapped to CPU interrupt '6'.

Note: it is possible to map multiple system interrupts to the same CPU interrupt. It is advised to assign different priorities to the CPU interrupts and to assign system interrupts to CPU interrupts accordingly.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>Interrupt enable:
'0': Disabled. The system interrupt will NOT be mapped to any CPU interrupt.
'1': Enabled. The system interrupt is mapped on CPU interrupt CPU_INT_IDX.

Note: the CPUs have dedicated XXX_SYSTEM_INT_CTL registers. In other words, the CPUs can use different CPU interrupts for the same system interrupt. However, typically only one of the CPUs will have the ENABLED field of a specific system interrupt set to '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>1023</dim>
          <dimIncrement>4</dimIncrement>
          <name>CM4_SYSTEM_INT_CTL[%s]</name>
          <description>CM4 system interrupt control</description>
          <addressOffset>0xA000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>CPU_INT_IDX</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_INT_VALID</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x40210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA3).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA3 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA3. The fault information is fault source specific and described below.

Note: this register field (and associated fault source data in DATA0 through DATA3) should only be considered valid, when VALID is '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Valid indication:
'0': Invalid.
'1': Valid. STATUS.IDX, DATA0, ..., DATA3 specify the fault.

Note: Typically, HW sets this field to '1' (on an activated HW fault source that is 'enabled' by the MASK registers) and SW clears this field to '0' (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, ..., DATA3 when the VALID field is set to '1'. 

An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to '1' with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds:
- STATUS.IDX, DATA0, ..., DATA3 can only be written when STATUS.VALID is '0'; the fault structure is not in use yet. Writing STATUS.VALID to '1' effectively locks the fault structure (until SW clears STATUS.VALID to '0'). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register.

Note: For the exceptional SW use case, sequential updates to the DATA and STATUS registers may be 'interrupted' by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>4</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data. 

Note: the DATA registers can only be written when STATUS.VALID is '0'.

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: CM0 MPU.
Bit 1: CRYPTO MPU.
Bit 2: DW 0 MPU.
Bit 3: DW 1 MPU.
Bit 4: DMA controller MPU.
...
Bit 15: DAP MPU.
Bit 16: CM4 system bus MPU.
Bit 17: CM4 code bus MPU (for non FLASH controller accesses).
Bit 18: CM4 code bus MPU (for FLASH controller accesses).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING1</name>
            <description>Fault pending 1</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0: Peripheral group 0 PPU.
Bit 1: Peripheral group 1 PPU.
Bit 2: Peripheral group 2 PPU.
Bit 3: Peripheral group 3 PPU.
Bit 4: Peripheral group 4 PPU.
Bit 5: Peripheral group 5 PPU.
Bit 6: Peripheral group 6 PPU.
Bit 7: Peripheral group 7 PPU.
...
Bit 15: Peripheral group 15 PPU.

Bit 16 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING2</name>
            <description>Fault pending 2</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>This field specifies the following sources:
Bit 0 - 31: See STATUS register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK1</name>
            <description>Fault mask 1</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 63 to 32.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK2</name>
            <description>Fault mask 2</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 95 to 64.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0/MASK1/MASK2) pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA3 captures the fault source data.

SW writes a '1' to this field to clear the interrupt cause to '0'. SW clear STATUS.VALID to '0' to enable capture of the next fault. Note that when there is an enabled pending fault source, the pending fault source is captured immediately and INTR.FAULT is immediately activated (set to '1').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>IPC</name>
      <description>IPC</description>
      <baseAddress>0x40220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>IPC structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>ACQUIRE</name>
            <description>IPC acquire</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the access that successfully acquired the lock.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/non-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the access that successfully acquired the lock.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUCCESS</name>
                <description>Specifies if the lock is successfully acquired or not (reading the ACQUIRE register can have affect on SUCCESS and LOCK_STATUS.ACQUIRED):
'0': Not successfully acquired; i.e. the lock was already acquired by another read transaction and not released. The P, NS, PC and MS fields reflect the access attributes of the transaction that previously successfully acuired the lock; the fields are NOT affected by the current access.
'1': Successfully acquired. The P, NS, PC and MS fields reflect the access attributes of the current access.

Note that this field is NOT SW writable. A lock is released by writing to the associated RELEASE register (irrespective of the write value).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RELEASE</name>
            <description>IPC release</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_RELEASE</name>
                <description>Writing this field releases a lock and allows for the generation of release events to the IPC interrupt structures, but only when the lock is acquired (LOCK_STATUS.ACQUIRED is '1'). The IPC release cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_RELEASE[] is set to '1'. 

SW writes a '1' to the bit fields to generate a release event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NOTIFY</name>
            <description>IPC notification</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>INTR_NOTIFY</name>
                <description>This field allows for the generation of notification events to the IPC interrupt structures. The IPC notification cause fields associated with this IPC structure are set to '1', but only for those IPC interrupt structures for which the corresponding bit field in INTR_NOTIFY[] is set to '1'. 

SW writes a '1' to the bit fields to generate a notify event. Due to the transient nature of this event, SW always reads a '0' from this field.</description>
                <bitRange>[15:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>IPC data 0</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>IPC data 1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>This field holds a 32-bit data element that is associated with the IPC structure.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK_STATUS</name>
            <description>IPC lock status</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>This field specifies the user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NS</name>
                <description>This field specifies the secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC</name>
                <description>This field specifies the protection context that successfully acquired the lock.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MS</name>
                <description>This field specifies the bus master identifier that successfully acquired the lock.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACQUIRED</name>
                <description>Specifies if the lock is acquired. This field is set to '1', if a ACQUIRE read transfer successfully acquires the lock (the ACQUIRE read transfer returns ACQUIRE.SUCCESS as '1'). If zero, P, NS, PC, and MS are not valid.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>INTR_STRUCT[%s]</name>
          <description>IPC interrupt structure</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC release event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>These interrupt cause fields are activated (HW sets the field to '1') when a IPC notification event is detected. One bit field for each master. SW writes a '1' to these field to clear the interrupt cause.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RELEASE</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NOTIFY</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROT</name>
      <description>Protection</description>
      <baseAddress>0x40230000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>SMPU</name>
          <description>SMPU</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>MS0_CTL</name>
            <description>Master 0 protection context control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>Privileged setting ('0': user mode; '1': privileged mode).

Notes:
This field is ONLY used for masters that do NOT provide their own user/privileged access control attribute.
The default/reset field value provides privileged mode access capabilities.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Security setting ('0': secure mode; '1': non-secure mode).

Notes:
This field is ONLY used for masters that do NOT provide their own secure/non-secure access control attribute.
Note that the default/reset field value provides non-secure mode access capabilities to all masters.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Device wide bus arbitration priority setting ('0': highest priority, '3': lowest priority).

Notes: 
The AHB-Lite interconnect performs arbitration on the individual  beats/transfers of a burst (this optimizes latency over locality/bandwidth).
The AXI-Lite interconnects performs a single arbitration for the complete burst (this optimizes locality/bandwidth over latency).
Masters with the same priority setting form a 'priority group'. Within a 'priority group', round robin arbitration is performed.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>Protection context mask for protection context '0'. This field is a constant '0':
- PC_MASK_0 is '0': MPU MS_CTL.PC[3:0] can NOT be set to '0' and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>Protection context mask for protection contexts '15' down to '1'. Bit PC_MASK_15_TO_1[i] indicates if the MPU MS_CTL.PC[3:0] protection context field can be set to the value 'i+1':
- PC_MASK_15_TO_1[i] is '0': MPU MS_CTL.PC[3:0] can NOT be set to 'i+1'; and PC[3:0] is not changed. If the protection context of the write transfer is '0', protection is not applied and PC[3:0] can be changed.
- PC_MASK_15_TO_1[i] is '1': MPU MS_CTL.PC[3:0] can be set to 'i+1'.

Note: When CPUSS_CM0_PC_CTL.VALID[i] is '1' (the associated protection context handler is valid), write transfers to PC_MASK_15_TO_1[i-1] always write '0', regardless of data written. This ensures that when valid protection context handlers are used to enter protection contexts 1, 2 or 3 through (HW modifies MPU MS_CTL.PC[3:0] on entry of the handler), it is NOT possible for SW to enter those protection contexts (SW modifies MPU MS_CTL.PC[3:0]).</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS1_CTL</name>
            <description>Master 1 protection context control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS2_CTL</name>
            <description>Master 2 protection context control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS3_CTL</name>
            <description>Master 3 protection context control</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS4_CTL</name>
            <description>Master 4 protection context control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS5_CTL</name>
            <description>Master 5 protection context control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS6_CTL</name>
            <description>Master 6 protection context control</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS7_CTL</name>
            <description>Master 7 protection context control</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS8_CTL</name>
            <description>Master 8 protection context control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS9_CTL</name>
            <description>Master 9 protection context control</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS10_CTL</name>
            <description>Master 10 protection context control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS11_CTL</name>
            <description>Master 11 protection context control</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS12_CTL</name>
            <description>Master 12 protection context control</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS13_CTL</name>
            <description>Master 13 protection context control</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS14_CTL</name>
            <description>Master 14 protection context control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MS15_CTL</name>
            <description>Master 15 protection context control</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x303</resetValue>
            <resetMask>0xFFFF0303</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>See MS0_CTL.P.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>See MS0_CTL.NS.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>See MS0_CTL.PRIO</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_MASK_0</name>
                <description>See MS0_CTL.PC_MASK_0.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_MASK_15_TO_1</name>
                <description>See MS0_CTL.PC_MASK_15_TO_1.</description>
                <bitRange>[31:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>16</dim>
            <dimIncrement>64</dimIncrement>
            <name>SMPU_STRUCT[%s]</name>
            <description>SMPU structure</description>
            <addressOffset>0x00002000</addressOffset>
            <register>
              <name>ADDR0</name>
              <description>SMPU region address 0 (slave structure)</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (ATT0.REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by ATT0 applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT0.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT0</name>
              <description>SMPU region attributes 0 (slave structure)</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x100</resetValue>
              <resetMask>0x80000100</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ADDR1</name>
              <description>SMPU region address 1 (master structure)</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.

Two out of a total of eight 32 B subregions are enabled. These subregions includes region structures 0 and 1. 

Note: this field is read-only.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region.

'ADDR_DEF1': base address of structure.

Note: this field is read-only.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT1</name>
              <description>SMPU region attributes 1 (master structure)</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x7000109</resetValue>
              <resetMask>0x9F00012D</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).

Note that this register is constant '1'; i.e. user read accesses are ALWAYS allowed.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).

Note that this register is constant '0'; i.e. user execute accesses are NEVER allowed.</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).

Note that this register is constant '1'; i.e. privileged read accesses are ALWAYS allowed.</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).

Note that this register is constant '0'; i.e. privileged execute accesses are NEVER allowed.</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PC_MASK_0</name>
                  <description>This field specifies protection context identifier based access control for protection context '0'.</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MASK_15_TO_1</name>
                  <description>This field specifies protection context identifier based access control.
Bit i: protection context i+1 enable. If '0', protection context i+1 access is disabled; i.e. not allowed. If '1', protection context i+1 access is enabled; i.e. allowed.</description>
                  <bitRange>[23:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'7': 256 B region (8 32 B subregions)

Note: this field is read-only.</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PC_MATCH</name>
                  <description>This field specifies if the PC field participates in the 'matching' process or the 'access evaluation' process:
'0': PC field participates in 'access evaluation'.
'1': PC field participates in 'matching'.

'Matching' process. For each protection structure, the process identifies if a transfer address is contained within the address range. This identifies the 'matching' regions.
'Access evaluation' process. For each protection structure, the process evaluates the bus transfer access attributes against the access control attributes.

Note that it is possible to define different access control for multiple protection contexts by using multiple protection structures with the same address region and PC_MATCH set to '1'.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
        <cluster>
          <dim>16</dim>
          <dimIncrement>1024</dimIncrement>
          <name>MPU[%s]</name>
          <description>MPU</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>MS_CTL</name>
            <description>Master control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Active protection context (PC). Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields. In addition, a write transfer with protection context '0' can change this field (protection context 0 has unrestricted access).

The CM0+ MPU MS_CTL register is special: the PC field is modifiable by BOTH HW and SW (for all other masters, the MPU MS_CTL.PC field is modifiable by SW ONLY. For CM0+ PC field HW modifications, the following holds:
* On entry of a CM0_PC0/1/2/3_HANDLER exception/interrupt handler:
   IF (the new PC is the same as MS_CTL.PC)
       PC is not affected; PC_SAVED is not affected.
   ELSE IF (CM0_PC_CTL.VALID[MS_CTL.PC])
       An AHB-Lite bus error is generated for the exception handler fetch;
       PC is not affected; PC_SAVED is not affected.
   ELSE
       PC = 'new PC'; PC_SAVED = PC (push operation).
* On entry of any other exception/interrupt handler:
   PC = PC_SAVED; PC_SAVED is not affected (pop operation).

Note that the CM0_PC0/1/2/3_HANDLER and CM0_PC_CTL registers are part of repecitve CPUSS MMIO registers.

Note: this field is NOT used by the DW controllers, DMA controller, AXI DMA controller, CRYPTO component and VIDEOSS.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Saved protection context. Modifications to this field are constrained by the associated SMPU MS_CTL.PC_MASK_0 and MS_CTL.PC_MASK_15_TO_1[] fields.

Note: this field is ONLY used by the CM0+.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>127</dim>
            <dimIncrement>4</dimIncrement>
            <name>MS_CTL_READ_MIR[%s]</name>
            <description>Master control read mirror</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF000F</resetMask>
            <fields>
              <field>
                <name>PC</name>
                <description>Read-only mirror of MS_CTL.PC</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PC_SAVED</name>
                <description>Read-only mirror of MS_CTL.PC_SAVED</description>
                <bitRange>[19:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <cluster>
            <dim>8</dim>
            <dimIncrement>32</dimIncrement>
            <name>MPU_STRUCT[%s]</name>
            <description>MPU structure</description>
            <addressOffset>0x00000200</addressOffset>
            <register>
              <name>ADDR</name>
              <description>MPU region address</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x0</resetMask>
              <fields>
                <field>
                  <name>SUBREGION_DISABLE</name>
                  <description>This field is used to individually disabled the eight equally sized subregions in which a region is partitioned. Subregion disable:
Bit 0: subregion 0 disable.
Bit 1: subregion 1 disable.
Bit 2: subregion 2 disable.
Bit 3: subregion 3 disable.
Bit 4: subregion 4 disable.
Bit 5: subregion 5 disable.
Bit 6: subregion 6 disable.
Bit 7: subregion 7 disable.
E.g., a 64 KByte address region (REGION_SIZE is '15') has eight 8 KByte subregions. The access control as defined by MPU_REGION_ATT applies if the bus transfer address is within the address region AND the addressed subregion is NOT disabled. Note that the smallest region size is 256 B and the smallest subregion size is 32 B.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ADDR24</name>
                  <description>This field specifies the most significant bits of the 32-bit address of an address region. The region size is defined by ATT.REGION_SIZE. A region of n Byte is always n Byte aligned. As a result, some of the lesser significant address bits of ADDR24 may be ignored in determining whether a bus transfer address is within an address region. E.g., a 64 KByte address region (REGION_SIZE is '15') is 64 KByte aligned, and ADDR24[7:0] are ignored.</description>
                  <bitRange>[31:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ATT</name>
              <description>MPU region attrributes</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x80000000</resetMask>
              <fields>
                <field>
                  <name>UR</name>
                  <description>User read enable:
'0': Disabled (user, read accesses are NOT allowed).
'1': Enabled (user, read accesses are allowed).</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UW</name>
                  <description>User write enable:
'0': Disabled (user, write accesses are NOT allowed).
'1': Enabled (user, write accesses are allowed).</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>UX</name>
                  <description>User execute enable:
'0': Disabled (user, execute accesses are NOT allowed).
'1': Enabled (user, execute accesses are allowed).</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PR</name>
                  <description>Privileged read enable:
'0': Disabled (privileged, read accesses are NOT allowed).
'1': Enabled (privileged, read accesses are allowed).</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PW</name>
                  <description>Privileged write enable:
'0': Disabled (privileged, write accesses are NOT allowed).
'1': Enabled (privileged, write accesses are allowed).</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PX</name>
                  <description>Privileged execute enable:
'0': Disabled (privileged, execute accesses are NOT allowed).
'1': Enabled (privileged, execute accesses are allowed).</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NS</name>
                  <description>Non-secure:
'0': Secure (secure accesses allowed, non-secure access NOT allowed).
'1': Non-secure (both secure and non-secure accesses allowed).</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>REGION_SIZE</name>
                  <description>This field specifies the region size:
'0'-'6': Undefined.
'7': 256 B region
'8': 512 B region
'9': 1 KB region
'10': 2 KB region
'11': 4 KB region
'12': 8 KB region
'13': 16 KB region
'14': 32 KB region
'15': 64 KB region
'16': 128 KB region
'17': 256 KB region
'18': 512 KB region
'19': 1 MB region
'20': 2 MB region
'21': 4 MB region
'22': 8 MB region
'23': 16 MB region
'24': 32 MB region
'25': 64 MB region
'26': 128 MB region
'27': 256 MB region
'28': 512 MB region
'39': 1 GB region
'30': 2 GB region
'31': 4 GB region</description>
                  <bitRange>[28:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENABLED</name>
                  <description>Region enable:
'0': Disabled. A disabled region will never result in a match on the bus transfer address.
'1': Enabled.

Note: a disabled address region performs logic gating to reduce dynamic power consumption.</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
          </cluster>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASHC</name>
      <description>Flash controller</description>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FLASH_CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x110000</resetValue>
          <resetMask>0x77330F</resetMask>
          <fields>
            <field>
              <name>MAIN_WS</name>
              <description>FLASH macro main interface wait states:
'0': 0 wait states.
...
'15': 15 wait states</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_MAP</name>
              <description>Specifies mapping of FLASH macro main array.
0: Mapping A.
1: Mapping B. 

This field is only used when MAIN_BANK_MODE is '1' (dual bank mode).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_MAP</name>
              <description>Specifies mapping of FLASH macro work array.
0: Mapping A.
1: Mapping B. 

This field is only used when WORK_BANK_MODE is '1' (dual bank mode).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_BANK_MODE</name>
              <description>Specifies bank mode of FLASH macro main array.
0: Single bank mode.
1: Dual bank mode.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_BANK_MODE</name>
              <description>Specifies bank mode of FLASH macro work array.
0: Single bank mode.
1: Dual bank mode.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_EN</name>
              <description>Enable ECC checking for FLASH main interface:
0: Disabled. ECC checking/reporting on FLASH main interface is disabled. No correctable or non-correctable faults are reported.
1: Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH main interface.
When'1', the parity (ECC_CTL.PARITY[7:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MAIN_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro main interface (either a non-correctable ECC error, a FLASH macro main interface internal error, a FLASH macro main interface memory hole access):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS and CM4_STATUS) to register the occurrence of FLASH macro main interface internal errors (non-correctable ECC errors and memory hole errors are NOT registered).

Note: fault reporting can be used to identify the error that occurred:
- FLASH macro main interface internal error. 
- FLASH macro main interface non-recoverable ECC error.
- FLASH macro main interface recoverable ECC error.
- FLASH macro main interface memory hole error.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_EN</name>
              <description>Enable ECC checking for FLASH work interface:
0: Disabled. ECC checking/reporting on FLASH work interface is disabled. No correctable or non-correctable faults are reported.
1: Enabled.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH work interface.
When'1', the parity (ECC_CTL.PARITY[6:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro work interface (either a non-correctable ECC error, a FLASH macro work interface internal error, a FLASH macro work interface memory hole access):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'
In either case, the erroneous FLASH macro data is returned by the bus master interface. The erroneous data is NOT placed in a bus master interface's cache and/or buffer.

This field is ONLY used by CPU bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error.

Note: All CPU bus masters have dedicated status registers (CM0_STATUS and CM4_STATUS) to register the occurrence of FLASH macro work interface internal errors (non-correctable ECC errors and memory hole errors are NOT registered).

Note: fault reporting can be used to identify the error that occurred:
- FLASH macro work interface internal error. 
- FLASH macro work interface non-recoverable ECC error.
- FLASH macro work interface recoverable ECC error.
- FLASH macro work interface memory hole error.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_PWR_CTL</name>
          <description>Flash power control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Controls 'enable' pin of the Flash memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_HV</name>
              <description>Controls 'enable_hv' pin of the Flash memory.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CMD</name>
          <description>Command</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Invalidation of ALL caches (for CM0+ and CM4) and ALL buffers. SW writes a '1' to clear the caches. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. The caches' LRU structures are also reset to their default state.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUFF_INV</name>
              <description>Invalidation of ALL buffers (does not invalidate the caches). SW writes a '1' to clear the buffers. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks.

Note: the caches only capture FLASH macro main array data. Therefore, invalidating just the buffers (BUFF_INV) does not invalidate captures main array data in the caches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For cache SRAM ECC, the word address WORD_ADDR[23:0] is device address A[25:2]. On a FLASH macro refill to this word address and when the corresponding CM0/4_CA_CTL.RAM_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) is injected and stored in the cache.
- For FLASH main interface ECC, the word address WORD_ADDR[23:0] is device address A[26:3]. On a FLASH main interface read and when FLASH_CTL.MAIN_ECC_INJ_EN bit is '1', the parity (PARITY[7:0]) replaces the FLASH macro parity (FLASH main interface read path is manipulated).
- For FLASH work interface ECC, the word address WORD_ADDR[23:0] is device address A[24:2]. On a FLASH work interface read and when FLASH_CTL.WORK_ECC_INJ_EN bit is '1', the parity (PARITY[6:0]) replaces the FLASH macro parity (FLASH work interface read path is manipulated).</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR. 
- For cache SRAM ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.
- For FLASH main interface ECC, the 8-bit parity PARITY[7:0] is for a 64-bit word.
- For FLASH work interface ECC, the 7-bit parity PARITY[6:0] is for a 32-bit word.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL0</name>
          <description>eCT Flash SRAM ECC control 0</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_DATA</name>
              <description>32-bit data for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL1</name>
          <description>eCT Flash SRAM ECC control 1</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>ECC_INJ_PARITY</name>
              <description>7-bit parity for ECC error injection test of eCT Flash SRAM ECC logic.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL2</name>
          <description>eCT Flash SRAM ECC control 2</description>
          <addressOffset>0x2B8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CORRECTED_DATA</name>
              <description>32-bit corrected data output of the ECC syndrome logic.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FM_SRAM_ECC_CTL3</name>
          <description>eCT Flash SRAM ECC control 3</description>
          <addressOffset>0x2BC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x111</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>ECC generation/check enable for eCT Flash SRAM memory.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>eCT Flash SRAM ECC error injection test enable. Follow the steps below for ECC logic test:
1. Write corrupted or uncorrupted 39-bit data to FM_SRAM_ECC_CTL0/1 registers.
2. Set the ECC_INJ_EN bit to '1'.
3. Confirm that the bit ECC_TEST_FAIL is '0'. If this is not the case, start over at item 1 because the eCT Flash was not idle.
4. Check the corrected data in FM_SRAM_ECC_CTL2.
5. Confirm that fault was reported to fault structure, and check syndrome (only applicable if
corrupted data was written in step 1).
6. If not finished, start over at 1 with different data.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_TEST_FAIL</name>
              <description>Status of ECC test.
1 : ECC test failed because eCT Flash macro is busy and using the SRAM.
0: ECC was performed.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL0</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>Enable ECC checking for cache accesses:
0: Disabled.
1: Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>Enable error injection for cache.
When '1', the parity (ECC_CTL.PARITY[6:0]) is used when a refill is done from the FLASH macro to the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>Cache enable:
0: Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
1: Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL1</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM0 cache.
The following sequnece should be followed for truning OFF/ON the cache SRAM.
Turn OFF sequence:
a) Write CM0_CA_CTL0 to disable cache.
b) Write CM0_CA_CTL1 to turn OFF cache SRAM.
Turn ON sequence:
a) Write CM0_CA_CTL1 to turn ON cache SRAM.
b) Delay to allow power up of cache SRAM. Delay should be at a minimum of CM0_CA_CTL2.PWRUP_DELAY CLK_SLOW clock cycles.
c) Write CM0_CA_CTL0 to enable cache.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Power OFF the CM0 cache SRAM.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>Put CM0 cache SRAM in retained mode.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>Enable/Turn ON the CM0 cache SRAM.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_CTL2</name>
          <description>CM0+ cache control</description>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS0</name>
          <description>CM0+ cache status 0</description>
          <addressOffset>0x440</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>Sixteen valid bits of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS1</name>
          <description>CM0+ cache status 1</description>
          <addressOffset>0x444</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>Cache line address of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_CA_STATUS2</name>
          <description>CM0+ cache status 2</description>
          <addressOffset>0x448</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>Six bit LRU representation of the cache set specified by CM0_CA_CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
Bit 5: 0_LRU_1: way 0 less recently used than way 1.
Bit 4: 0_LRU_2.
Bit 3: 0_LRU_3.
Bit 2: 1_LRU_2.
Bit 1: 1_LRU_3.
Bit 0: 2_LRU_3.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM0_STATUS</name>
          <description>CM0+ interface status</description>
          <addressOffset>0x460</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>Specifies/registers the occurrence of a FLASH macro main interface internal error (typically the result of a read access while a program erase operation is ongoing) as a result of a CM0+ access. 

SW clears this field to '0'. HW sets this field to '1' on a FLASH macro main interface internal error. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.MAIN_ERR_SILENT.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL0</name>
          <description>CM4 cache control</description>
          <addressOffset>0x480</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC7030003</resetMask>
          <fields>
            <field>
              <name>RAM_ECC_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM_ECC_INJ_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAY</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CA_EN</name>
              <description>See CM0_CA_CTL.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL1</name>
          <description>CM4 cache control</description>
          <addressOffset>0x484</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFA050003</resetValue>
          <resetMask>0xFFFF0003</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Specifies power mode for CM4 cache. Refer CM0_CA_CTL1 for more details.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>Undefined</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RETAINED</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>See CM0_CA_CTL1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VECTKEYSTAT</name>
              <description>Register key (to prevent accidental writes).
- Should be written with a 0x05fa key value for the write to take effect.
- Always reads as 0xfa05.

Note: Although the SW attribute for this field says ''R', SW need to write the key 0x05fa in this field for this register write to happen. This is a built in protection provided to prevent accidental writes from SW.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_CTL2</name>
          <description>CM4 cache control</description>
          <addressOffset>0x488</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12C</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>PWRUP_DELAY</name>
              <description>Number clock cycles delay needed after power domain power up</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS0</name>
          <description>CM4 cache status 0</description>
          <addressOffset>0x4C0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALID32</name>
              <description>See CM0_CA_STATUS0.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS1</name>
          <description>CM4 cache status 1</description>
          <addressOffset>0x4C4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>TAG</name>
              <description>See CM0_CA_STATUS1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_CA_STATUS2</name>
          <description>CM4 cache status 2</description>
          <addressOffset>0x4C8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>LRU</name>
              <description>See CM0_CA_STATUS2.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CM4_STATUS</name>
          <description>CM4 interface status</description>
          <addressOffset>0x4E0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>MAIN_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WORK_INTERNAL_ERR</name>
              <description>See CM0_STATUS.MAIN_INTERNAL_ERROR.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_BUFF_CTL</name>
          <description>Cryptography buffer control</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
0: Disabled.
1: Enabled.
A prefetch will be done when there is read 'hit' on the last 32-bit word of the buffer.
For eCT work Flash, prefetch will not be done.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW0_BUFF_CTL</name>
          <description>Datawire 0 buffer control</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DW1_BUFF_CTL</name>
          <description>Datawire 1 buffer control</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_BUFF_CTL</name>
          <description>DMA controller buffer control</description>
          <addressOffset>0x680</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS0_BUFF_CTL</name>
          <description>External master 0 buffer control</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS1_BUFF_CTL</name>
          <description>External master 1 buffer control</description>
          <addressOffset>0x780</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x40000000</resetMask>
          <fields>
            <field>
              <name>PREF_EN</name>
              <description>See CRYPTO_BUFF_CTL.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>FM_CTL</name>
          <description>Flash Macro Registers</description>
          <addressOffset>0x0000F000</addressOffset>
          <register>
            <name>FM_CTL</name>
            <description>Flash macro control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x37F030F</resetMask>
            <fields>
              <field>
                <name>FM_MODE</name>
                <description>Requires (IF_SEL|WR_EN)=1
Flash macro mode selection</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_SEQ</name>
                <description>Requires (IF_SEL|WR_EN)=1
Flash macro sequence selection</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAA_MUX_SEL</name>
                <description>Direct memory cell access address.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IF_SEL</name>
                <description>Interface selection. Specifies the interface that is used for flash memory read operations:
0: R interface is used (default value). In this case, the flash memory address is provided as part of the R signal interface.
1: C interface is used. In this case, the flash memory address is provided by FM_MEM_ADDR (the page address) and by the C interface access offset in the FM_MEM_DATA structure.
Note: IF_SEL and WR_EN cannot be changed at the same time</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WR_EN</name>
                <description>0: normal mode
1: Fm Write Enable
Note: IF_SEL and WR_EN cannot be changed at the same time</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x1800</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_ENABLED</name>
                <description>This is the timer_en bit set by writing a '1' in the TIMER_CTL bit 31. It is reset by HW when the timer expires
0: timer not running
1: Timer is enabled and not expired yet</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HV_REGS_ISOLATED</name>
                <description>Indicates the isolation status at HV trim and redundancy registers inputs
0: Not isolated, writing permitted
1: isolated writing disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ILLEGAL_HVOP</name>
                <description>Indicates a bulk, sector erase, program has been requested when axa=1
0: no error
1: illegal HV operation error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TURBO_N</name>
                <description>After FM power up indicates the analog blocks currents are boosted to faster reach their functional state.. 
Used in the testchip boot only as an 'FM READY' flag.  
0: turbo mode 
1: normal mode</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_EN_MON</name>
                <description>FM_CTL.WR_EN bit after being synchronized in clk_r domain</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IF_SEL_MON</name>
                <description>FM_CTL.IF_SEL bit after being synchronized in clk_r domain</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMER_STATUS</name>
                <description>The actual timer state sync-ed in clk_c domain:
0: timer is not running:
1: timer is running;</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>R_GRANT_DELAY_STATUS</name>
                <description>0: R_GRANT_DELAY timer is not running
1: R_GRANT_DELAY timer is running</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_BUSY</name>
                <description>0': FM not busy 
1: FM BUSY : R_GRANT is 0 as result of a busy request from FM ready, or from HV operations.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FM_READY</name>
                <description>0: FM not ready
1: FM ready</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>POS_PUMP_VLO</name>
                <description>POS pump VLO</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>NEG_PUMP_VHI</name>
                <description>NEG pump VHI</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWW</name>
                <description>FM Type  (Read While Write or Not Read While Write):
0: Non RWW FM Type
1:  RWW FM Type</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_DOUT_WIDTH</name>
                <description>Internal memory core max data out size 
(number of data out bits per column):
0: x128 bits
1: x256 bits</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SECTOR0_SR</name>
                <description>0:  Sector 0 does not contain special rows. The special rows are located in separate special sectors.
1:  Sector 0 contains special rows</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESET_MM</name>
                <description>Test_only, internal node: mpcon  reset_mm</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_ODD</name>
                <description>Test_only, internal node: mpcon  row_odd</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ROW_EVEN</name>
                <description>Test_only, internal node: mpcon  row_even</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SUB_SECTOR_N</name>
                <description>Test_only, internal node: mpcon  bk_subb</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_SECTOR</name>
                <description>Test_only, internal node: mpcon  bk_sec</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HVOP_BULK_ALL</name>
                <description>Test_only, internal node: mpcon  bk_all</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RA_MATCH</name>
                <description>Test_only, internal node: mpcon  ra match</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CBUS_RED_ROW_EN</name>
                <description>Test_only, internal node: mpcon  red_row_en</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RQ_ERROR</name>
                <description>Test_only, internal node:  rq_error  sync-de in clk_c domain</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_PDAC</name>
                <description>Test_only, internal node: regif pdac outputs to pos pump</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PUMP_NDAC</name>
                <description>Test_only, internal node: regif ndac outputs to pos pump</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_ADDR</name>
            <description>Flash macro address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Row address.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BA</name>
                <description>Bank address.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AXA</name>
                <description>Auxiliary address field:
0: regular flash memory.
1: supervisory flash memory.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOKMARK</name>
            <description>Bookmark register - keeps the current FW HV seq</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BOOKMARK</name>
                <description>Used by FW. Keeps the Current HV cycle sequence</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY</name>
            <description>Regular flash geometry</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1):
0: 1 row
1: 2 rows
2: 3 rows
...
'65535': 65536 rows</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1):
0: 1 bank
1: 2 banks
...
'255': 256 banks</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). A word is defined as the data that is read from the flash macro over the R interface with a single read access:
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
3: 128 Bytes

The currently planned flash macros have a word size of either 32-bit, 64-bit or 128-bit, resulting in WORD_SIZE_LOG2 settings of 2, 3 and 4 respectively.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2):
0: 1 Byte
1: 2 Bytes
2: 4 Bytes
...
15: 32768 Bytes

The currently planned flash macros have a page size of either 256 Byte or 512 Byte, resulting in PAGE_SIZE_LOG2 settings of 8 and 9 respectively.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GEOMETRY_SUPERVISORY</name>
            <description>Supervisory flash geometry</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ROW_COUNT</name>
                <description>Number of rows (minus 1). ROW_COUNT is typically less than GEOMETRY.ROW_COUNT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BANK_COUNT</name>
                <description>Number of banks (minus 1). BANK_COUNT is less or equal to GEOMETRY.BANK_COUNT.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WORD_SIZE_LOG2</name>
                <description>Number of Bytes per word (log 2). See GEOMETRY.WORD_SIZE_LOG2. Typically, WORD_SIZE_LOG2 equals GEOMETRY.WORD_SIZE_LOG2.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PAGE_SIZE_LOG2</name>
                <description>Number of Bytes per page (log 2). See GEOMETRY.PAGE_SIZE_LOG2. Typically, PAGE_SIZE_LOG2 equals GEOMETRY.PAGE_SIZE_LOG2.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL0</name>
            <description>Analog control 0</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x400</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MDAC</name>
                <description>Trimming of the output margin Voltage as a function of Vpos and Vneg.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CSLDAC</name>
                <description>Trimming of common source line DAC.</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIP_AMUXBUS_AB</name>
                <description>Flips amuxbusa and amuxbusb 
0: amuxbusa, amuxbusb
1:  amuxbusb, amuxbusb</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_MIN</name>
                <description>NDAC staircase min value</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MIN</name>
                <description>PDAC staircase min value</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq0-seq1 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq1-seq2 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on seq2-seq3 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_SEQ30</name>
                <description>PROG&amp;PRE_PROG&amp; ERASE: Scale for R_GRANT_DELAY on seq3-seq0 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE On transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: Scale for R_GRANT_DELAY on PE OFF transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ANA_CTL1</name>
            <description>Analog control 1</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xD32FAFA</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>NDAC_MAX</name>
                <description>Ndac Max Value.Trimming of negative pump output Voltage.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NDAC_STEP</name>
                <description>Ndac step increment</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_MAX</name>
                <description>Pdac Max Value.Trimming of positive pump output Voltage:</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PDAC_STEP</name>
                <description>Pdac step increment</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_STEP_TIME</name>
                <description>Ndac/Pdac step duration: (1uS .. 255uS) * 8
When = 0 N/PDAC_MAX control the pumps</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_ZERO_TIME</name>
                <description>Ndac/Pdac LO duration: (1uS .. 255uS) * 8
When 0, N/PDAC don't return to 0</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WAIT_CTL</name>
            <description>Wait State control</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x30B09</resetValue>
            <resetMask>0x3F070F0F</resetMask>
            <fields>
              <field>
                <name>WAIT_FM_MEM_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the memory</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_RD</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a read from the high Voltage page latches.
Common for reading HV Page Latches and the DATA_COMP_RESULT bit</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FM_HV_WR</name>
                <description>Number of C interface wait cycles (on 'clk_c') for a write to the high Voltage page latches.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_RWW_MODE</name>
                <description>00: Full CBUS MODE
01: RWW
10: RWW. R_GRANT is stalling r_bus for the whole program/erase duration</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LV_SPARE_1</name>
                <description>Spare register</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRMM</name>
                <description>0: Normal
1: Test mode to enable Margin mode for 2 rows at a time</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MBA</name>
                <description>0: Normal
1: Test mode to enable Master Bulk Access which allows both normal rows and redundant rows to be erased / programmed in one HV cycle (Bulk / Sector Erase and Sector Program).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PL_SOFT_SET_EN</name>
                <description>Page latch soft set enable, 0 = disabled, 1 = enabled (at end of seq_2), taken care in API</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CLK_CTL</name>
            <description>Timer prescaler (clk_t to timer clock frequency divider)</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TIMER_CLOCK_FREQ</name>
                <description>Clk_t frequency divider to provide the 1MHz reference clock for the Regif Timer.
Equal to the frequency in MHz of the timer clock 'clk_t'.
Example: if 'clk_t' has a frequency of 4 MHz then this field value is '4'
Max clk_t frequency = 100MHz.
This field is updated at runtime with the  'SW_TIMER_CLOCK_FREQ ' value from the HV parameters table</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEON</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_PEOFF</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ01</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TIMER_CTL</name>
            <description>Timer control</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x4000001</resetValue>
            <resetMask>0xE700FFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Timer period in either microseconds (SCALE is '0') or 100's of microseconds (SCALE is '1') multiples.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE</name>
                <description>Timer tick scale:
0: 1 microsecond.
1: 100 microseconds.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_SEQUENCE</name>
                <description>1': Starts1 the HV automatic sequencing 
Cleared by HW</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG</name>
                <description>1 during pre-program operation</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRE_PROG_CSL</name>
                <description>0: CSL lines driven by CSL_DAC
1: CSL lines driven by VNEG_G</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PUMP_EN</name>
                <description>Pump enable:
0: disabled
1: enabled (also requires FM_CTL.IF_SEL to be'1', this additional restriction is required to prevent non intentional clearing of the FM).
SW sets this field to '1' to generate a single PE pulse. 
HW clears this field when timer is expired.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACLK_EN</name>
                <description>ACLK enable (generates a single cycle pulse for the FM):
0: disabled
1: enabled. SW set this field to '1' to generate a single cycle pulse. HW sets this field to '0' when the pulse is generated.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMER_EN</name>
                <description>Timer enable:
0: disabled
1: enabled. SW sets this field to '1' to start the timer. HW sets this field to '0' when the timer is expired.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ACLK_CTL</name>
            <description>MPCON clock</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACLK_GEN</name>
                <description>A write to this register generates the clock pulse for HV control registers (mpcon outputs)</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>TIMER_EXPIRED</name>
                <description>Logical and of corresponding request and mask fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL0</name>
            <description>Cal control BG LO trim bits</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x38F8F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VCT_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDAC_LO_HV</name>
                <description>LO Temperature compensated trim DAC. To control Vcstat slope for Vpos.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage trim control.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TC_TRIM_LO_HV</name>
                <description>LO Bandgap Voltage Temperature Compensation trim control</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TC_TRIM_LO_HV</name>
                <description>LO Bandgap Current Temperature Compensation trim control</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIMA_LO_HV</name>
                <description>Adds 100-150nA boost on IPREF_LO</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL1</name>
            <description>Cal control BG HI trim bits</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x38F8F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VCT_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CDAC_HI_HV</name>
                <description>HI Temperature compensated trim DAC. To control Vcstat slope for Vpos.</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage trim control.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBG_TC_TRIM_HI_HV</name>
                <description>HI Bandgap Voltage Temperature Compensation trim control.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TC_TRIM_HI_HV</name>
                <description>HI Bandgap Current Temperature Compensation trim control.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIMA_HI_HV</name>
                <description>Adds 100-150nA boost on IPREF_HI</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL2</name>
            <description>Cal control BG LO&amp;HI trim bits</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x7BE10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ICREF_TRIM_LO_HV</name>
                <description>LO Bandgap Current  trim control.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICREF_TRIM_HI_HV</name>
                <description>HI Bandgap Current  trim control.</description>
                <bitRange>[9:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIM_LO_HV</name>
                <description>LO Bandgap IPTAT trim control.</description>
                <bitRange>[14:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TRIM_HI_HV</name>
                <description>HI  Bandgap IPTAT trim control.</description>
                <bitRange>[19:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL3</name>
            <description>Cal control osc trim bits, idac, sdac, itim</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2004</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>OSC_TRIM_HV</name>
                <description>Flash macro pump clock trim control.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OSC_RANGE_TRIM_HV</name>
                <description>0: Oscillator High Frequency Range
1: Oscillator Low Frequency range</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VPROT_ACT_HV</name>
                <description>Forces VPROT in active mode all the time</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IPREF_TC_HV</name>
                <description>0: Increases the IPREF Tempco by subtracting ICREF from IPREF - IPREF internal will be 0.5uA
1: Reduces the IPREF Tempco without subtracting ICREF from IPREF - IPREF internal will be 1uA</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL_HV</name>
                <description>Voltage reference:
0: internal bandgap reference
1: external voltage reference</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IREF_SEL_HV</name>
                <description>Current reference:
0: internal current reference
1: external current reference</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REG_ACT_HV</name>
                <description>0: VBST regulator will operate in active/standby mode based on control signal.
1: Forces the VBST regulator in active mode all the time</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FDIV_TRIM_HV</name>
                <description>FDIV_TRIM_HV[1:0]: Assuming oscillator frequency of 8MHz in standby.
Following are the clock frequencies seen by doubler
00: F = 1MHz 
01: F = 0.5MHz 
10: F = 2MHz
11: F = 4MHz</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VDDHI_HV</name>
                <description>0: vdd &lt; 2.3V 
1: vdd &gt;= 2.3V
'0' setting can used for vdd &gt; 2.3V also, but with a current penalty.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_PULSEW_HV</name>
                <description>Turbo pulse width trim (Typical)
00: 40 us
01: 20 us
10: 15 us 
11: 8 us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGLO_EN_HV</name>
                <description>0: Normal (Automatic change over from HI to LO)
1: Force enable LO Bandgap</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGHI_EN_HV</name>
                <description>0: Normal (Automatic change over from HI to LO)
1: Force enable HI Bandgap 
When both BGLO_EN_HV and BGHI_EN_HV are HIGH, only BGHI output is used and turbo_hv_n pulse is active</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CL_ISO_DIS_HV</name>
                <description>0: The internal logic controls the CL isolation
1: Forces CL bypass</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>R_GRANT_EN_HV</name>
                <description>0: r_grant handshake disabled, r_grant always 1.
1: r_grand handshake  enabled</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LP_ULP_SW_HV</name>
                <description>LP&lt;--&gt;ULP switch for trim signals:
0: LP
1: ULP</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL4</name>
            <description>Cal Control Vlim, SA, fdiv, reg_act</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x12AE0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_ULP_HV</name>
                <description>VLIM_TRIM[1:0]: 
00: V2 = 650mV
01: V2 = 600mV
10: V2 = 750mV
11: V2 = 700mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDAC_ULP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[5:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_ULP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_ULP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_ULP_HV</name>
                <description>00: Default : delay 1ns
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE451_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>READY_RESTART_N_HV</name>
                <description>Toggle: 1--&gt;0, ready goes low, ready will remain low as long as the bit is low. Toggle the bit back to 1 to activate the ready logic. To be used by API only.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VBST_S_DIS_HV</name>
                <description>0: VBST_S voltage for each sector to allow VBST level to be dropped to VCC during Erase in the selected sector, reducing coupling to GBL. 
1: VBST_S voltage for each sector stays at VBST level during Erase in the selected sector.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_HVPULSE_HV</name>
                <description>0: HV Pulse controlled by FW
1: HV Pulse controlled by Hardware</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UGB_EN_HV</name>
                <description>UGB enable in TM control</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL5</name>
            <description>Cal control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2AE0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>VLIM_TRIM_LP_HV</name>
                <description>VLIM_TRIM[1:0]: 
00: V2 = 650mV
01: V2 = 600mV
10: V2 = 750mV
11: V2 = 700mV</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IDAC_LP_HV</name>
                <description>Sets the sense current reference offset value. Refer to trim tables for details.</description>
                <bitRange>[5:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDAC_LP_HV</name>
                <description>Sets the sense current reference temp slope. Refer to trim tables for details.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ITIM_LP_HV</name>
                <description>Trimming of timing current</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DEL_LP_HV</name>
                <description>00: Delayed by 1us
01: Delayed by 1.5us
10: Delayed by 2.0us
11: Delayed by 2.5us</description>
                <bitRange>[14:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE451_LP_HV</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE52_HV</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AMUX_SEL_HV</name>
                <description>Amux Select in AMUX_UGB
00: Bypass UGB for both amuxbusa and amuxbusb
01: Bypass UGB for amuxbusb while passing amuxbusa through UGB.
10: Bypass UGB for amuxbusa while passing amuxbusb through UGB.
11: UGB Calibrate mode</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL6</name>
            <description>SA trim LP/ULP</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x36F7F</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>SA_CTL_TRIM_T1_ULP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_ULP_HV</name>
                <description>SA_CTL_TRIM_T4_ULP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_ULP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_ULP_HV</name>
                <description>SA_CTL_TRIM_T5_ULP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_ULP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_ULP_HV</name>
                <description>SA_CTL_TRIM_T6_ULP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_ULP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[8:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_ULP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T1_LP_HV</name>
                <description>clk_trk delay</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T4_LP_HV</name>
                <description>SA_CTL_TRIM_T4_LP_HV&lt;2&gt;= eqi (eq current trim)
SA_CTL_TRIM_T4_LP_HV&lt;1:0&gt; = eqc (eq cap trim)</description>
                <bitRange>[13:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T5_LP_HV</name>
                <description>SA_CTL_TRIM_T5_LP_HV&lt;2&gt;= evi (integration current trim)
SA_CTL_TRIM_T5_LP_HV&lt;1:0&gt; = evc (integration cap trim)</description>
                <bitRange>[16:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T6_LP_HV</name>
                <description>SA_CTL_TRIM_T6_LP_HV&lt;1&gt;= eni (enable current trim)
SA_CTL_TRIM_T6_LP_HV&lt;0&gt; = ecn (enable cap trim)</description>
                <bitRange>[18:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SA_CTL_TRIM_T8_LP_HV</name>
                <description>saen3 pulse width trim (Current trim)</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAL_CTL7</name>
            <description>Cal control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>ERSX8_CLK_SEL_HV</name>
                <description>Clock frequency into the ersx8 shift register block 
00: Oscillator clock
01: Oscillator clock / 2
10: Oscillator clock / 4
11: Oscillator clock</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_ACTIVE_HV</name>
                <description>0: Normal operation
1: Forces FM SYS in active mode</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TURBO_EXT_HV</name>
                <description>0: Normal operation
1: Uses external turbo pulse</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NPDAC_HWCTL_DIS_HV</name>
                <description>0': ndac, pdac staircase hardware controlled
1: ndac, pdac staircase disabled. Enables FW control.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FM_READY_DIS_HV</name>
                <description>0': fm ready is enabled 
1: fm ready is disabled (fm_ready is always '1')</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERSX8_EN_ALL_HV</name>
                <description>0': Staggered turn on/off of GWL
1: GWL are turned on/off at the same time (old FM legacy)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_LOAD_ONCE_HV</name>
                <description>0: Load common HV params during API HV operations depends on the HV_PARAMS_LOADED bit in RGRANT_DELAY_PRG register.
1: All HV params are loaded during every API HV operation irrespective of HV_PARAMS_LOADED bit in the RGRANT_DELAY_PRG register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_HV</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_ULP_HV</name>
                <description>N/A</description>
                <bitRange>[14:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SPARE7_LP_HV</name>
                <description>N/A</description>
                <bitRange>[19:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL01</name>
            <description>Redundancy Control normal sectors 0,1</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_0</name>
                <description>Bad Row Pair Address for Sector 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_0</name>
                <description>1: Redundancy Enable for Sector 0</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_1</name>
                <description>Bad Row Pair Address for Sector 1</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_1</name>
                <description>1: Redundancy Enable for Sector 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL23</name>
            <description>Redundancy Control normal sectors 2,3</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_2</name>
                <description>Bad Row Pair Address for Sector 2</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_2</name>
                <description>1: Redundancy Enable for Sector 2</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_3</name>
                <description>Bad Row Pair Address for Sector 3</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_3</name>
                <description>1: Redundancy Enable for Sector 3</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL45</name>
            <description>Redundancy Control normal sectors 4,5</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_4</name>
                <description>Bad Row Pair Address for Sector 4</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_4</name>
                <description>1: Redundancy Enable for Sector 4</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_5</name>
                <description>Bad Row Pair Address for Sector 5</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_5</name>
                <description>1: Redundancy Enable for Sector 5</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL67</name>
            <description>Redundancy Control normal sectors 6,7</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_6</name>
                <description>Bad Row Pair Address for Sector 6</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_6</name>
                <description>1: Redundancy Enable for Sector 6</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_7</name>
                <description>Bad Row Pair Address for Sector 7</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_7</name>
                <description>1: Redundancy Enable for Sector 7</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RED_CTL_SM01</name>
            <description>Redundancy Control special sectors 0,1</description>
            <addressOffset>0x90</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>RED_ADDR_SM0</name>
                <description>Bad Row Pair Address for Special Sector 0</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_SM0</name>
                <description>Redundancy Enable for Special Sector 0</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_ADDR_SM1</name>
                <description>Bad Row Pair Address for Special Sector 1</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_EN_SM1</name>
                <description>Redundancy Enable for Special Sector 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_PRG</name>
            <description>R-grant delay for program</description>
            <addressOffset>0x98</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1000000</resetValue>
            <resetMask>0x8FFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ12</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_PRG_SEQ23</name>
                <description>PROG&amp;PRE_PROG: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_SEQ30</name>
                <description>PROG&amp;PRE_PROG &amp; ERASE: R-grant blocking delay on seq3-seq0 transition. Scale = ANA_CTL0.SCALE_SEQ30
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_CLK</name>
                <description>Frequency divider from clk_t  to create the 8MHz reference clock for R_grant delay
The value of this field is the integer result of 'clk_t frequency / 8'.
Example: for clk_t=100 this field is INT(100/8) =12.
This field is updated at runtime with the  'SW_RGRANT_DELAY_CLK ' value from the HV parameters table</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HV_PARAMS_LOADED</name>
                <description>0: HV Pulse common params not loaded
1: HV Pulse common params  loaded: r-grant delays, r-grant scale, prescaler, timer values for seq1,seq2_pre, seq2_post, seq3</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ12</name>
            <description>HV Pulse Delay for seq 1&amp;2 pre</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ1</name>
                <description>Seq1 delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ2_PRE</name>
                <description>Seq2 pre delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PW_SEQ23</name>
            <description>HV Pulse Delay for seq2 post &amp; seq3</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PW_SEQ2_POST</name>
                <description>Seq2 post  delay</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PW_SEQ3</name>
                <description>Seq3 delay</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_SCALE_ERS</name>
            <description>R-grant delay scale for erase</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF03FF</resetMask>
            <fields>
              <field>
                <name>SCALE_ERS_SEQ01</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq0-seq1 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ12</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq1-seq2 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_SEQ23</name>
                <description>ERASE: Scale for R_GRANT_DELAY on seq2-seq3 transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEON</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE On transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SCALE_ERS_PEOFF</name>
                <description>ERASE: Scale for R_GRANT_DELAY on PE OFF transition:
00: 0.125uS
01: 1uS
10: 10uS
11: 100uS</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEON</name>
                <description>ERASE: R-grant blocking delay on PE ON. Scale = ANA_CTL0.SCALE_PEON
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_PEOFF</name>
                <description>ERASE: R-grant blocking delay on PE OFF. Scale = ANA_CTL0.SCALE_PEOFF
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RGRANT_DELAY_ERS</name>
            <description>R-grant delay for erase</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ01</name>
                <description>ERASE: R-grant blocking delay on seq0-seq1 transition. Scale = ANA_CTL0.SCALE_SEQ01
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ12</name>
                <description>ERASE: R-grant blocking delay on seq1-seq2 transition. Scale = ANA_CTL0.SCALE_SEQ12
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RGRANT_DELAY_ERS_SEQ23</name>
                <description>ERASE: R-grant blocking delay on seq2-seq3 transition. Scale = ANA_CTL0.SCALE_SEQ23
When = 0  R_GRANT_DELAY control is disabled
when IF_SEL=1  R_GRANT_DELAY control is disabled</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FM_PL_WRDATA_ALL</name>
            <description>Flash macro write page latches all</description>
            <addressOffset>0x7FC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Write all high Voltage page latches with the same 32-bit data in a single write cycle
Read always returns 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_PL_DATA[%s]</name>
            <description>Flash macro Page Latches data</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Four page latch Bytes 
When reading the page latches it requires FM_CTL.IF_SEL to be '1'
Note: the high Voltage page latches are readable for test mode functionality.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>256</dim>
            <dimIncrement>4</dimIncrement>
            <name>FM_MEM_DATA[%s]</name>
            <description>Flash macro memory sense amplifier and column decoder data</description>
            <addressOffset>0xC00</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DATA32</name>
                <description>Sense amplifier and column multiplexer structure Bytes. The read data is dependent on FM_CTL.IF_SEL:
- IF_SEL is 0: data as specified by the R interface address
- IF_SEL is 1: data as specified by FM_MEM_ADDR and the offset of the accessed FM_MEM_DATA register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSS</name>
      <description>SRSS Core Registers</description>
      <baseAddress>0x40260000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CTL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFC0033</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>System is resetting.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>At least one CPU is running.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>No CPUs are running.  Peripherals may be running.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active.  Power modes behave differently to keep the debug session active.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after XRES/POR/BOD/HIBERNATE wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>IREF_LPMODE</name>
              <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Current reference generator operates in normal mode.  It works for vddd ramp rates of 100mV/us or less.
1: Current reference generator operates in low power mode.  Response time is reduced to save current, and it works for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_OK</name>
              <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting VREFBUF_DIS=1.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DPSLP_REG_DIS</name>
              <description>Disable the DeepSleep regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: DeepSleep Regulator is on.
1: DeepSleep Regulator is off.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RET_REG_DIS</name>
              <description>Disable the Retention regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Retention Regulator is on.
1: Retention Regulator is off.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NWELL_REG_DIS</name>
              <description>Disable the Nwell regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Nwell Regulator is on.
1: Nwell Regulator is off.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_DIS</name>
              <description>Disable the linear Core Regulator.  This is only legal when the on-chip buck regulator supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Linear regulator is on.
1: Linear regulator is off.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LINREG_LPMODE</name>
              <description>Control the power mode of the Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Linear Regulator operates in normal mode.  Internal current consumption is 50uA and load current capability is 50mA to 300mA, depending on the number of regulator modules present in the product.
1: Linear Regulator operates in low power mode.  Internal current consumption is 5uA and load current capability is 25mA.  Firmware must ensure the current is kept within the limit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORBOD_LPMODE</name>
              <description>Control the power mode of the POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: POR/BOD circuits operate in normal mode.  They work for vddd ramp rates of 100mV/us or less.
1: POR/BOD circuits operate in low power mode.  Response time is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BGREF_LPMODE</name>
              <description>Control the power mode of the Bandgap Voltage and Current References.  This applies to voltage and current generation and is different than the reference voltage buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.  When lower power mode is used, the Active Reference circuit can be disabled to reduce current.  Firmware is responsible to ensure ACT_REF_OK==1 before changing back to normal mode.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Active Bandgap Voltage and Current Reference operates in normal mode.  They work for vddd ramp rates of 100mV/us or less.
1: Active Bandgap Voltage and Current Reference operates in low power mode.  Power supply rejection is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.  The Active Reference may be disabled using ACT_REF_DIS=0.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LS_BYPASS</name>
              <description>Bypass level shifter inside the PLL.  
0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_LPMODE</name>
              <description>Control the power mode of the 800mV voltage reference buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.
0: Voltage Reference Buffer operates in normal mode.  They work for vddd ramp rates of 100mV/us or less.  This register is only reset by XRES/POR/BOD/HIBERNATE.
1: Voltage Reference Buffer operates in low power mode.  Power supply rejection is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFBUF_DIS</name>
              <description>Disable the 800mV voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_DIS</name>
              <description>Disables the Active Reference.  Firmware must ensure that LPM_READY==1 and BGREF_LPMODE==1 for at least 1us before disabling the Active Reference.  When enabling the Active Reference, use ACT_REF_OK indicator to know when it is ready.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0: Active Reference is enabled
1: Active Reference is disabled</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_OK</name>
              <description>Indicates that the normal mode of the Active Reference is ready.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_HIBERNATE</name>
          <description>HIBERNATE Mode Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCFFEFFFF</resetMask>
          <fields>
            <field>
              <name>TOKEN</name>
              <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>Firmware sets this bit to freeze the configuration, mode and state of all GPIOs and SIOs in the system.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBALARM</name>
              <description>When set, HIBERNATE will wakeup for a RTC interrupt</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBWDT</name>
              <description>When set, HIBERNATE will wakeup if WDT matches</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY_HIBPIN</name>
              <description>Each bit sets the active polarity of the corresponding wakeup pin.
0: Pin input of 0 will wakeup the part from HIBERNATE
1: Pin input of 1 will wakeup the part from HIBERNATE</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK_HIBPIN</name>
              <description>When set, HIBERNATE will wakeup if the corresponding pin input matches the POLARITY_HIBPIN setting.  Each bit corresponds to one of the wakeup pins.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE_DISABLE</name>
              <description>Hibernate disable bit.
0: Normal operation, HIBERNATE works as described
1: Further writes to this register are ignored
Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIBERNATE</name>
              <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP event.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_CTL</name>
          <description>Low Voltage Detector (LVD) Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HVLVD1_TRIPSEL</name>
              <description>Threshold selection for HVLVD1.  Disable the LVD (HVLVD1_EN=0) before changing the threshold.
0: rise=1.225V (nom), fall=1.2V (nom)
1: rise=1.425V (nom), fall=1.4V (nom)
2: rise=1.625V (nom), fall=1.6V (nom)
3: rise=1.825V (nom), fall=1.8V (nom)
4: rise=2.025V (nom), fall=2V (nom)
5: rise=2.125V (nom), fall=2.1V (nom)
6: rise=2.225V (nom), fall=2.2V (nom)
7: rise=2.325V (nom), fall=2.3V (nom)
8: rise=2.425V (nom), fall=2.4V (nom)
9: rise=2.525V (nom), fall=2.5V (nom)
10: rise=2.625V (nom), fall=2.6V (nom)
11: rise=2.725V (nom), fall=2.7V (nom)
12: rise=2.825V (nom), fall=2.8V (nom)
13: rise=2.925V (nom), fall=2.9V (nom)
14: rise=3.025V (nom), fall=3.0V (nom)
15: rise=3.125V (nom), fall=3.1V (nom)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_SRCSEL</name>
              <description>Source selection for HVLVD1</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDD</name>
                  <description>Select VDDD</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSA</name>
                  <description>Select AMUXBUSA (VDDD branch)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDIO</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AMUXBUSB</name>
                  <description>Select AMUXBUSB (VDDD branch)</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVLVD1_EN</name>
              <description>Enable HVLVD1 voltage monitor.  When the LVD is enabled, it takes 20us for it to settle.  There is no hardware stabilization counter, and it may falsely trigger during settling.  It is recommended that firmware keep the interrupt masked for at least 8us, write a 1'b1 to the corresponding SRSS_INTR field to any falsely pended interrupt, and then optionally unmask the interrupt.  After enabling, it is further recommended to read the related PWR_LVD_STATUS field, since the interrupt only triggers on edges.  This bit is cleared (LVD is disabled) when entering DEEPSLEEP to prevent false interrupts during wakeup.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL</name>
          <description>Buck Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x5</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT1_SEL</name>
              <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES/POR/BOD/HIBERNATE.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 0.85V
1: 0.875V
2: 0.90V
3: 0.95V
4: 1.05V
5: 1.10V
6: 1.15V
7: 1.20V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_EN</name>
              <description>Master enable for buck converter.    This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT1_EN</name>
              <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES/POR/BOD/HIBERNATE.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The TRM specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BUCK_CTL2</name>
          <description>Buck Control Register 2</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>BUCK_OUT2_SEL</name>
              <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
0: 1.15V
1: 1.20V
2: 1.25V
3: 1.30V
4: 1.35V
5: 1.40V
6: 1.45V
7: 1.50V</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_HW_SEL</name>
              <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCK_OUT2_EN</name>
              <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_LVD_STATUS</name>
          <description>Low Voltage Detector (LVD) Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OK</name>
              <description>HVLVD1 output.
0: below voltage threshold
1: above voltage threshold</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>PWR_HIB_DATA[%s]</name>
          <description>HIBERNATE Data Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HIB_DATA</name>
              <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTL</name>
          <description>Watchdog Counter Control Register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000001</resetValue>
          <resetMask>0xC0000001</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Enable this watchdog timer.  This field is retained during DEEPSLEEP and HIBERNATE modes.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_LOCK</name>
              <description>Prohibits writing to WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers when not equal 0.  Requires at least two different writes to unlock.  A change in WDT_LOCK takes effect beginning with the next write cycle.
Note that this field is 2 bits to force multiple writes only.  It represents only a single write protect signal protecting all those registers at the same time.  WDT will lock on any reset.  This field is not retained during DEEPSLEEP or HIBERNATE mode, so the WDT will be locked after wakeup from these modes.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_CHG</name>
                  <description>No effect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR0</name>
                  <description>Clears bit 0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR1</name>
                  <description>Clears bit 1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET01</name>
                  <description>Sets both bits 0 and 1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CNT</name>
          <description>Watchdog Counter Count Register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter.  The write feature of this register is for engineering use (DfV), have no synchronization, and can only be applied when the WDT is fully off.  When writing, the value is updated immediately in the WDT counter, but it will read back as the old value until this register resynchronizes just after the negedge of ILO.  Writes will be ignored if they occur when the WDT is enabled.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Counter Match Register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_BITS</name>
              <description>The number of MSB bits of the watchdog timer that are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  Up to 12 MSB can be ignored.  Settings &gt;12 behave like a setting of 12.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>64</dimIncrement>
          <name>MCWDT_STRUCT[%s]</name>
          <description>Multi-Counter Watchdog Timer</description>
          <headerStructName>MCWDT_STRUCT</headerStructName>
          <addressOffset>0x00000200</addressOffset>
          <register>
            <name>MCWDT_CNTLOW</name>
            <description>Multi-Counter Watchdog Sub-counters 0/1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR0</name>
                <description>Current value of sub-counter 0 for this MCWDT.  Software writes are ignored when the sub-counter is enabled.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CTR1</name>
                <description>Current value of sub-counter 1 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CNTHIGH</name>
            <description>Multi-Counter Watchdog Sub-counter 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_CTR2</name>
                <description>Current value of sub-counter 2 for this MCWDT.  Software writes are ignored when the sub-counter is enabled</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_MATCH</name>
            <description>Multi-Counter Watchdog Counter Match Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WDT_MATCH0</name>
                <description>Match value for sub-counter 0 of this MCWDT</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MATCH1</name>
                <description>Match value for sub-counter 1 of this MCWDT</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CONFIG</name>
            <description>Multi-Counter Watchdog Counter Configuration</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F010F0F</resetMask>
            <fields>
              <field>
                <name>WDT_MODE0</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR0=WDT_MATCH0).</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR0</name>
                <description>Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0. In other words WDT_CTR0 divides LFCLK by (WDT_MATCH0+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH0 is 1.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE0_1</name>
                <description>Cascade Watchdog Counters 0,1.  Counter 1 increments the cycle after WDT_CTR0=WDT_MATCH0.
0: Independent counters
1: Cascaded counters</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE1</name>
                <description>Watchdog Counter Action on Match.  Action is taken on the next increment after the values match (WDT_CTR1=WDT_MATCH1).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Assert WDT_INTx</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Assert WDT Reset</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT_THEN_RESET</name>
                    <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_CLEAR1</name>
                <description>Clear Watchdog Counter when WDT_CTR1==WDT_MATCH1. In other words WDT_CTR1 divides LFCLK by (WDT_MATCH1+1).
0: Free running counter
1: Clear on match.  In this mode, the minimum legal setting of WDT_MATCH1 is 1.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_CASCADE1_2</name>
                <description>Cascade Watchdog Counters 1,2.  Counter 2 increments the cycle after WDT_CTR1=WDT_MATCH1.  It is allowed to cascade all three WDT counters.
0: Independent counters
1: Cascaded counters.  When cascading all three counters, WDT_CLEAR1 must be 1.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_MODE2</name>
                <description>Watchdog Counter 2 Mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Free running counter with no interrupt requests</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Free running counter with interrupt request that occurs one LFCLK cycle after the specified bit in CTR2 toggles (see WDT_BITS2).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WDT_BITS2</name>
                <description>Bit to observe for WDT_INT2:
0: Assert after bit0 of WDT_CTR2 toggles (one int every tick)
...
31: Assert after bit31 of WDT_CTR2 toggles (one int every 2^31 ticks)</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_CTL</name>
            <description>Multi-Counter Watchdog Counter Control</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xB0B0B</resetMask>
            <fields>
              <field>
                <name>WDT_ENABLE0</name>
                <description>Enable subcounter 0.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED0</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE0 by up to two LFCLK cycles.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET0</name>
                <description>Resets counter 0 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE1</name>
                <description>Enable subcounter 1.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED1</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE1 by up to two LFCLK cycles.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET1</name>
                <description>Resets counter 1 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLE2</name>
                <description>Enable subcounter 2.  May take up to 2 LFCLK cycles to take effect.
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WDT_ENABLED2</name>
                <description>Indicates actual state of counter.  May lag WDT_ENABLE2 by up to two LFCLK cycles.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WDT_RESET2</name>
                <description>Resets counter 2 back to 0000.  Hardware will reset this bit after counter was reset.  This will take up to one LFCLK cycle to take effect.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR</name>
            <description>Multi-Counter Watchdog Counter Interrupt Register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>MCWDT Interrupt Request for sub-counter 0.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE0=3.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>MCWDT Interrupt Request for sub-counter 1.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE1=3.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>MCWDT Interrupt Request for sub-counter 2.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODE2=3.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_SET</name>
            <description>Multi-Counter Watchdog Counter Interrupt Set Register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Set interrupt for MCWDT_INT0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Set interrupt for MCWDT_INT1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Set interrupt for MCWDT_INT2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASK</name>
            <description>Multi-Counter Watchdog Counter Interrupt Mask Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Mask for sub-counter 0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Mask for sub-counter 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Mask for sub-counter 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_INTR_MASKED</name>
            <description>Multi-Counter Watchdog Counter Interrupt Masked Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>MCWDT_INT0</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT1</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MCWDT_INT2</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MCWDT_LOCK</name>
            <description>Multi-Counter Watchdog Counter Lock Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC0000000</resetMask>
            <fields>
              <field>
                <name>MCWDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this MCWDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  Each MCWDT has a separate local lock.  LFCLK settings are locked by the global WDT_LOCK register, and this register has no effect on that.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_DSI_SELECT[%s]</name>
          <description>Clock DSI Select Register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>DSI_MUX</name>
              <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DSI_OUT0</name>
                  <description>DSI0 - dsi_out[0]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT1</name>
                  <description>DSI1 - dsi_out[1]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT2</name>
                  <description>DSI2 - dsi_out[2]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT3</name>
                  <description>DSI3 - dsi_out[3]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT4</name>
                  <description>DSI4 - dsi_out[4]</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT5</name>
                  <description>DSI5 - dsi_out[5]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT6</name>
                  <description>DSI6 - dsi_out[6]</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT7</name>
                  <description>DSI7 - dsi_out[7]</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT8</name>
                  <description>DSI8 - dsi_out[8]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT9</name>
                  <description>DSI9 - dsi_out[9]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT10</name>
                  <description>DSI10 - dsi_out[10]</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT11</name>
                  <description>DSI11 - dsi_out[11]</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT12</name>
                  <description>DSI12 - dsi_out[12]</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT13</name>
                  <description>DSI13 - dsi_out[13]</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT14</name>
                  <description>DSI14 - dsi_out[14]</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_OUT15</name>
                  <description>DSI15 - dsi_out[15]</description>
                  <value>15</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>16</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator</description>
                  <value>17</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock</description>
                  <value>18</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low-speed Oscillator</description>
                  <value>19</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PATH_SELECT[%s]</name>
          <description>Clock Path Select Register</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PATH_MUX</name>
              <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DSI_MUX</name>
                  <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_ROOT_SELECT[%s]</name>
          <description>Clock Root Select Register</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000003F</resetMask>
          <fields>
            <field>
              <name>ROOT_MUX</name>
              <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PATH0</name>
                  <description>Select PATH0 (can be configured for FLL)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH1</name>
                  <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH2</name>
                  <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH3</name>
                  <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH4</name>
                  <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH5</name>
                  <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH6</name>
                  <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH7</name>
                  <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH8</name>
                  <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH9</name>
                  <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH10</name>
                  <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH11</name>
                  <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH12</name>
                  <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH13</name>
                  <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH14</name>
                  <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH15</name>
                  <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ROOT_DIV</name>
              <description>Selects predivider value for this clock root and DSI input.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock selection register</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF03</resetMask>
          <fields>
            <field>
              <name>LFCLK_SEL</name>
              <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low-speed Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision ILO. If present, it works in DEEPSLEEP and higher modes.  Does not work in HIBERNATE mode.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock PATH&lt;k&gt;, where k=PUMP_SEL.  The output of this mux goes to the PUMP_DIV to make PUMPCLK  Each product has a specific number of available clock paths.  Selecting a path that is not implemented on a product will result in undefined behavior.  Note that this is not a glitch free mux.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PUMP_DIV</name>
              <description>Division ratio for PUMPCLK.  Uses selected PUMP_SEL clock as the source.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_16</name>
                  <description>Divide selected clock source by 16</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_ENABLE</name>
              <description>Enable the pump clock.  PUMP_ENABLE and the PUMP_SEL mux are not glitch-free to minimize side-effects, avoid changing the PUMP_SEL and PUMP_DIV while changing PUMP_ENABLE.  To change the settings, do the following: 
1) If the pump clock is enabled, write PUMP_ENABLE=0 without changing PUMP_SEL and PUMP_DIV.  
2) Change PUMP_SEL and PUMP_DIV to desired settings with PUMP_ENABLE=0.  
3) Write PUMP_ENABLE=1 without changing PUMP_SEL and PUMP_DIV.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TIMER_CTL</name>
          <description>Timer Clock Control Register</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x70000</resetValue>
          <resetMask>0x80FF0301</resetMask>
          <fields>
            <field>
              <name>TIMER_SEL</name>
              <description>Select source for TIMERCLK.  The output of this mux can be further divided using TIMER_DIV.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal Main Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HF0_DIV</name>
                  <description>Select the output of the predivider configured by TIMER_HF0_DIV.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_HF0_DIV</name>
              <description>Predivider used when HF0_DIV is selected in TIMER_SEL.  If HFCLK0 frequency is less than 100MHz and has approximately 50 percent duty cycle, then no division is required (NO_DIV).  Otherwise, select a divide ratio of 2, 4, or 8 before selected HF0_DIV as the timer clock.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing or correcting duty cycle.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide HFCLK0 by 2.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide HFCLK0 by 4.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide HFCLK0 by 8.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER_DIV</name>
              <description>Divide selected timer clock source by (1+TIMER_DIV).  The output of this divider is TIMERCLK  Allows for integer divisions in the range [1, 256].  Do not change this setting while the timer is enabled.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable for TIMERCLK.
0: TIMERCLK is off
1: TIMERCLK is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>ILO_BACKUP</name>
              <description>If backup domain is present on this product, this register indicates that ILO should stay enabled for use by backup domain during XRES, HIBERNATE mode, and through power-related resets like BOD on VDDD/VCCD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
0: ILO turns off at XRES/BOD event or HIBERNATE entry.
1: ILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  After enabling, it takes at most two cycles to reach the accuracy spec.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during HIBERNATE and XRES.  It will automatically disable during DEEPSLEEP if DPSLP_ENABLE==0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_FAST</name>
          <description>Fast Clock Output Select Register</description>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>FAST_SEL0</name>
              <description>Select signal for fast clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL0</name>
                  <description>Selects the clock path chosen by PATH_SEL0 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL0</name>
                  <description>Selects the output of the HFCLK_SEL0 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL0</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL0</name>
              <description>Selects a clock path to use in fast clock output #0 logic.  0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL0</name>
              <description>Selects a HFCLK tree for use in fast clock output #0</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAST_SEL1</name>
              <description>Select signal for fast clock output #1</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>External Crystal Oscillator (ECO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>External clock input (EXTCLK)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTHF</name>
                  <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERCLK</name>
                  <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PATH_SEL1</name>
                  <description>Selects the clock path chosen by PATH_SEL1 field</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK_SEL1</name>
                  <description>Selects the output of the HFCLK_SEL1 mux</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLOW_SEL1</name>
                  <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PATH_SEL1</name>
              <description>Selects a clock path to use in fast clock output #1 logic.  0: FLL output
1-15: PLL output on path1-path15 (if available)</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HFCLK_SEL1</name>
              <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_OUTPUT_SLOW</name>
          <description>Slow Clock Output Select Register</description>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLOW_SEL0</name>
              <description>Select signal for slow clock output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLOW_SEL1</name>
              <description>Select signal for slow clock output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>Internal Low Speed Oscillator (ILO)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-Crystal Oscillator (WCO)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BAK</name>
                  <description>Root of the Backup domain clock tree (BAK)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTLF</name>
                  <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>Root of the low-speed clock tree (LFCLK)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRL</name>
                  <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>Precision Internal Low Speed Oscillator (PILO)</description>
                  <value>8</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x51C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80FFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on fast clock output #0 (see CLK_OUTPUT_FAST). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete.  A stalled counter can be recovered by selecting valid clocks, waiting until the measurement completes, and discarding the first result.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on fast clock output  #1 (see CLK_OUTPUT_FAST). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x52C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x80000002</resetMask>
          <fields>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by ECO_TRIM0.ATRIM.  When low, the amplitude is not explicitly controlled and can be as high as the vddd supply.  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECO_EN</name>
              <description>Master enable for ECO oscillator.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>ECO_OK</name>
              <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECO_READY</name>
              <description>Indicates the ECO internal oscillator circuit has had enough time to fully stabilize.  This is the output of a counter since ECO was enabled, and it does not check the ECO output.  It is recommended to also confirm ECO_OK==1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_PILO_CONFIG</name>
          <description>Precision ILO Configuration Register</description>
          <addressOffset>0x53C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xE00003FF</resetMask>
          <fields>
            <field>
              <name>PILO_FFREQ</name>
              <description>Fine frequency trim allowing +/-250ppm accuracy with periodic calibration.  The nominal step size of the LSB is 8Hz.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_CLK_EN</name>
              <description>Enable the PILO clock output.  See PILO_EN field for required sequencing.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RESET_N</name>
              <description>Reset the PILO.  See PILO_EN field for required sequencing.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_EN</name>
              <description>Enable PILO.  When enabling PILO, set PILO_EN=1, wait 1ms, then PILO_RESET_N=1 and PILO_CLK_EN=1.  When disabling PILO, clear PILO_EN=0, PILO_RESET_N=0, and PLO_CLK_EN=0 in the same write cycle.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG</name>
          <description>FLL Configuration Register</description>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x8103FFFF</resetMask>
          <fields>
            <field>
              <name>FLL_MULT</name>
              <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).

Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
              <bitRange>[17:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: no division
1: divide by 2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_ENABLE</name>
              <description>Master enable for FLL.  The FLL requires firmware sequencing when enabling, disabling, and entering/exiting DEEPSLEEP.

To enable the FLL, first enable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=1 and wait until CLK_FLL_STATUS.CCO_READY==1.  Next, ensure the reference clock has stabilized and CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF.  Next, write FLL_ENABLE=1 and wait until CLK_FLL_STATUS.LOCKED==1.  Finally, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_OUT to switch to the FLL output.  It takes seven reference clock cycles plus four FLL output cycles to switch to the FLL output.  Do not disable the FLL before this time completes.

To disable the FLL, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF and (optionally) read the same register to ensure the write completes.  Then, wait at least seven FLL reference clock cycles before disabling it with FLL_ENABLE=0.  Lastly, disable the CCO by writing CLK_FLL_CONFIG4.CCO_ENABLE=0.

Before entering DEEPSLEEP, either disable the FLL using above sequence or use the following procedure to deselect/select it before/after DEEPSLEEP.  Before entering DEEPSLEEP, write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_REF to change the FLL to use its reference clock.  After DEEPSLEEP wakeup, wait until CLK_FLL_STATUS.LOCKED==1 and then write CLK_FLL_CONFIG3.BYPASS_SEL=FLL_OUT to switch to the FLL output.

0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG2</name>
          <description>FLL Configuration Register 2</description>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20001</resetValue>
          <resetMask>0x1FF1FFF</resetMask>
          <fields>
            <field>
              <name>FLL_REF_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
8191: divide by 8191</description>
              <bitRange>[12:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_TOL</name>
              <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or to track a less accurate source.  The tolerance should be set so that the FLL does not unlock under normal conditions.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value. 
0: tolerate error of 1 count value
1: tolerate error of 2 count values
...
511: tolerate error of 512 count values</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG3</name>
          <description>FLL Configuration Register 3</description>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2800</resetValue>
          <resetMask>0x301FFFFF</resetMask>
          <fields>
            <field>
              <name>FLL_LF_IGAIN</name>
              <description>FLL Loop Filter Gain Setting #1.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLL_LF_PGAIN</name>
              <description>FLL Loop Filter Gain Setting #2.  The proportional gain is the sum of FLL_LF_IGAIN and FLL_LF_PGAIN.
0: 1/256
1: 1/128
2: 1/64
3: 1/32
4: 1/16
5: 1/8
6: 1/4
7: 1/2
8: 1.0
9: 2.0
10: 4.0
11: 8.0
&gt;=12: illegal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SETTLING_COUNT</name>
              <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
0: no settling time
1: wait one reference clock cycle
...
8191: wait 8191 reference clock cycles</description>
              <bitRange>[20:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after FLL output.  See FLL_ENABLE description for instructions on how to use this field when enabling/disabling the FLL.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_REF</name>
                  <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLL_OUT</name>
                  <description>Select FLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_CONFIG4</name>
          <description>FLL Configuration Register 4</description>
          <addressOffset>0x58C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xC1FF07FF</resetMask>
          <fields>
            <field>
              <name>CCO_LIMIT</name>
              <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_RANGE</name>
              <description>Frequency range of CCO</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RANGE0</name>
                  <description>Target frequency is in range [48, 64) MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE1</name>
                  <description>Target frequency is in range [64, 85) MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE2</name>
                  <description>Target frequency is in range [85, 113) MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE3</name>
                  <description>Target frequency is in range [113, 150) MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RANGE4</name>
                  <description>Target frequency is in range [150, 200] MHz</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CCO_FREQ</name>
              <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_HW_UPDATE_DIS</name>
              <description>Disable CCO frequency update by FLL hardware
0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_ENABLE</name>
              <description>Enable the CCO.  It is required to enable the CCO before using the FLL.  
0: Block is powered off
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_FLL_STATUS</name>
          <description>FLL Status Register</description>
          <addressOffset>0x590</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>FLL Lock Indicator.  LOCKED is high when FLL is within CLK_FLL_CONFIG2.LOCK_TOL.  If FLL is outside LOCK_TOL, LOCKED goes low.  Note that this can happen during normal operation, if FLL needs to recalculate due to a change in the reference clock, change in voltage, or change in temperature.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_READY</name>
              <description>This indicates that the CCO is internally settled and ready to use.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_CONFIG[%s]</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20116</resetValue>
          <resetMask>0xB81F1F7F</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0-21: illegal (undefined behavior)
22: divide by 22
...
112: divide by 112
&gt;112: illegal (undefined behavior)</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: divide by 1
...
20: divide by 20
others: illegal (undefined behavior)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
0: illegal (undefined behavior)
1: illegal (undefined behavior) 
2: divide by 2.  Suitable for direct usage as HFCLK source.
...
16: divide by 16.  Suitable for direct usage as HFCLK source.
&gt;16: illegal (undefined behavior)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_LF_MODE</name>
              <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
0: VCO frequency is [200MHz, 400MHz]
1: VCO frequency is [170MHz, 200MHz)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO1</name>
                  <description>Same as AUTO</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  To disable the PLL, first deselect it using .BYPASS_SEL=PLL_REF, wait at least six PLL clock cycles, and then disable it with .ENABLE=0.

Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)

0: Block is disabled
1: Block is enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>15</dim>
          <dimIncrement>4</dimIncrement>
          <name>CLK_PLL_STATUS[%s]</name>
          <description>PLL Status Register</description>
          <addressOffset>0x640</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  W1C also feeds the watch dog.  Missing 2 interrupts in a row will generate a reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Set interrupt for low voltage detector WDT_MATCH</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Set interrupt for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DEEPSLEEP mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x708</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.  When WDT resets the chip, it also internally pends an interrupt that survives the reset.  To prevent unintended ISR execution, clear SRSS_INTR.WDT_MATCH before setting this bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Mask for low voltage detector HVLVD1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x70C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x23</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVLVD1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_CFG</name>
          <description>SRSS Interrupt Configuration Register</description>
          <addressOffset>0x710</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>HVLVD1_EDGE_SEL</name>
              <description>Sets which edge(s) will trigger an IRQ for HVLVD1</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A basic WatchDog Timer (WDT) reset has occurred since last power cycle.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>Fault logging system requested a reset from its Active logic.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_DPSLP_FAULT</name>
              <description>Fault logging system requested a reset from its DeepSleep logic.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_WCO_LOSS</name>
              <description>Clock supervision logic requested a reset due to loss of a watch-crystal clock.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>A CPU requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT0</name>
              <description>Multi-Counter Watchdog timer reset #0 has occurred since last power cycle.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT1</name>
              <description>Multi-Counter Watchdog timer reset #1 has occurred since last power cycle.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT2</name>
              <description>Multi-Counter Watchdog timer reset #2 has occurred since last power cycle.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_MCWDT3</name>
              <description>Multi-Counter Watchdog timer reset #3 has occurred since last power cycle.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE2</name>
          <description>Reset Cause Observation Register 2</description>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RESET_CSV_HF_LOSS</name>
              <description>Clock supervision logic requested a reset due to loss of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CSV_HF_FREQ</name>
              <description>Clock supervision logic requested a reset due to frequency error of high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_REF_CTL</name>
          <description>Reference Trim Register</description>
          <addressOffset>0x7F00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x70F00000</resetValue>
          <resetMask>0xF1FF5FFF</resetMask>
          <fields>
            <field>
              <name>ACT_REF_TCTRIM</name>
              <description>Active-Reference temperature trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_ITRIM</name>
              <description>Active-Reference current trim.   This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_ABSTRIM</name>
              <description>Active-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REF_IBOOST</name>
              <description>Active-Reference current boost.   This register is only reset by XRES/POR/BOD/HIBERNATE.
0: normal operation
others: risk mitigation</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_TCTRIM</name>
              <description>DeepSleep-Reference temperature trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.
0 -&gt; default setting at POR; not for trimming use
others -&gt; normal trim range</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_ABSTRIM</name>
              <description>DeepSleep-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPSLP_REF_ITRIM</name>
              <description>DeepSleep current reference trim.   This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[31:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_BODOVP_CTL</name>
          <description>BOD/OVP Trim Register</description>
          <addressOffset>0x7F04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40D04</resetValue>
          <resetMask>0xFDFF7</resetMask>
          <fields>
            <field>
              <name>HVPORBOD_TRIPSEL</name>
              <description>HVPORBOD trip point selection.  Monitors vddd.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVPORBOD_OFSTRIM</name>
              <description>HVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVPORBOD_ITRIM</name>
              <description>HVPORBOD current trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[9:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_TRIPSEL</name>
              <description>LVPORBOD trip point selection.  Monitors vccd.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[12:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_OFSTRIM</name>
              <description>LVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[16:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LVPORBOD_ITRIM</name>
              <description>LVPORBOD current trim.  This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[19:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_CCO_CTL</name>
          <description>CCO Trim Register</description>
          <addressOffset>0x7F08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA7000020</resetValue>
          <resetMask>0xBF00003F</resetMask>
          <fields>
            <field>
              <name>CCO_RCSTRIM</name>
              <description>CCO reference current source trim.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_STABLE_CNT</name>
              <description>Terminal count for the stabilization counter from CCO_ENABLE until stable.</description>
              <bitRange>[29:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE_CNT</name>
              <description>Enables the automatic stabilization counter.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_CCO_CTL2</name>
          <description>CCO Trim Register 2</description>
          <addressOffset>0x7F0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x884110</resetValue>
          <resetMask>0x1FFFFFF</resetMask>
          <fields>
            <field>
              <name>CCO_FCTRIM1</name>
              <description>CCO frequency 1st range calibration</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM2</name>
              <description>CCO frequency 2nd range calibration</description>
              <bitRange>[9:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM3</name>
              <description>CCO frequency 3rd range calibration</description>
              <bitRange>[14:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM4</name>
              <description>CCO frequency 4th range calibration</description>
              <bitRange>[19:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CCO_FCTRIM5</name>
              <description>CCO frequency 5th range calibration</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_WAKE_CTL</name>
          <description>Wakeup Trim Register</description>
          <addressOffset>0x7F30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>WAKE_DELAY</name>
              <description>Wakeup holdoff.  Spec (fastest) wake time is achieved with a setting of 0.  Additional delay can be added for debugging or workaround.  The delay is counted by the IMO.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_LVD_CTL</name>
          <description>LVD Trim Register</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>HVLVD1_OFSTRIM</name>
              <description>HVLVD1 offset trim</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVLVD1_ITRIM</name>
              <description>HVLVD1 current trim</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ILO_CTL</name>
          <description>ILO Trim Register</description>
          <addressOffset>0xFF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2C</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ILO_FTRIM</name>
              <description>ILO frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_TRIM_PWRSYS_CTL</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xFF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x17</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>ACT_REG_TRIM</name>
              <description>Trim for the Active-Regulator.  This sets the output voltage level.  This register is only reset by XRES/POR/BOD/HIBERNATE.  Two voltages are supported: 0.9V and 1.1V.  The codes for these are stored in SFLASH_LDO_0P9V_TRIM and SFLASH_LDO_1P1V_TRIM, respectively.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ACT_REG_BOOST</name>
              <description>Controls the tradeoff between output current and internal operating current for the Active Regulator.  The maximum output current depends on the silicon implementation, but an application may limit its maximum current to less than that.  This may allow a reduction in the internal operating current of the regulator.  The regulator internal operating current depends on the boost setting:
2'b00: 50uA
2'b01: 100uA
2'b10: 150uA
2'b11: 200uA

The allowed setting is a lookup table based on the chip-specific maximum (set in factory) and an application-specific maximum (set by customer).  The defaults are set assuming the application consumes the maximum allowed by the chip.
50mA chip: 2'b00 (default);
100mA chip: 2'b00 (default);
150mA chip: 50..100mA app =&gt; 2'b00, 150mA app =&gt; 2'b01 (default);
200mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200mA app =&gt; 2'b10 (default);
250mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200..250mA app =&gt; 2'b10 (default);
300mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01, 200..250mA app =&gt; 2'b10, 300mA app =&gt; 2'b11 (default);

This register is only reset by XRES/POR/BOD/HIBERNATE.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_ECO_CTL</name>
          <description>ECO Trim Register</description>
          <addressOffset>0xFF20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1F0003</resetValue>
          <resetMask>0x3F3FF7</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim -  Delta voltage below steady state level
0x0 - 50mV
0x1 - 75mV
0x2 - 100mV
0x3 - 125mV
0x4 - 150mV
0x5 - 175mV
0x6 - 200mV
0x7 - 225mV</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0 - 150mV
0x1 - 175mV
0x2 - 200mV
0x3 - 225mV
0x4 - 250mV
0x5 - 275mV
0x6 - 300mV
0x7 - 325mV
0x8 - 350mV
0x9 - 375mV
0xA - 400mV
0xB - 425mV
0xC - 450mV
0xD - 475mV
0xE - 500mV
0xF - 525mV</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ITRIM</name>
              <description>Current Trim</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL</name>
          <description>PILO Trim Register</description>
          <addressOffset>0xFF24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x108500F</resetValue>
          <resetMask>0x7DFF703F</resetMask>
          <fields>
            <field>
              <name>PILO_CFREQ</name>
              <description>Coarse frequency trim to meet 32.768kHz +/-2 percent across PVT without calibration.  The nominal step size of the LSB is 1kHz.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_OSC_TRIM</name>
              <description>Trim for current in oscillator block.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_COMP_TRIM</name>
              <description>Trim for comparator bias current.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_NBIAS_TRIM</name>
              <description>Trim for biasn by trimming sub-Vth NMOS width in beta-multiplier</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_RES_TRIM</name>
              <description>Trim for beta-multiplier branch current</description>
              <bitRange>[24:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_ISLOPE_TRIM</name>
              <description>Trim for beta-multiplier current slope</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_VTDIFF_TRIM</name>
              <description>Trim for VT-DIFF output (internal power supply)</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL2</name>
          <description>PILO Trim Register 2</description>
          <addressOffset>0xFF28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xDA10E0</resetValue>
          <resetMask>0xFF1FFF</resetMask>
          <fields>
            <field>
              <name>PILO_VREF_TRIM</name>
              <description>Trim for voltage reference</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREFBM_TRIM</name>
              <description>Trim for beta-multiplier current reference</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PILO_IREF_TRIM</name>
              <description>Trim for current reference</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_TRIM_PILO_CTL3</name>
          <description>PILO Trim Register 3</description>
          <addressOffset>0xFF2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4800</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PILO_ENGOPT</name>
              <description>Engineering options for PILO circuits
0: Short vdda to vpwr
1: Beta:mult current change
2: Iref generation Ptat current addition
3: Disable current path in secondary Beta:mult startup circuit
4: Double oscillator current
5: Switch between deep:sub:threshold and sub:threshold stacks in Vref generation block
6: Spare
7: Ptat component increase in Iref
8: vpwr_rc and vpwr_dig_rc shorting testmode
9: Switch b/w psub connection for cascode nfet for vref generation
10: Switch between sub:threshold and deep:sub:threshold stacks in comparator.
15-11: Frequency fine trim.  See AKK-444 for an overview of the trim strategy.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BACKUP</name>
      <description>SRSS Backup Domain</description>
      <baseAddress>0x40270000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0F3308</resetMask>
          <fields>
            <field>
              <name>WCO_EN</name>
              <description>Watch-crystal oscillator (WCO) enable.  If there is a write in progress when this bit is cleared, the WCO will be internally kept on until the write completes.
After enabling the WCO software must wait until STATUS.WCO_OK=1 before configuring any component that depends on clk_lf/clk_bak, like for example RTC or WDTs.  Follow the procedure in BACKUP_RTC_RW to access this bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_SEL</name>
              <description>Clock select for BAK clock</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WCO</name>
                  <description>Watch-crystal oscillator input.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ALTBAK</name>
                  <description>This allows to use the LFCLK selection as an alternate backup domain clock.  Note that LFCLK is not available in all power modes, and clock glitches can propagate into the backup logic when the clock is stopped.  For this reason, if the WCO is intended as the clock source then choose it directly instead of routing through LFCLK.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRESCALER</name>
              <description>N/A</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WCO_BYPASS</name>
              <description>Configures the WCO for different board-level connections to the WCO pins.  For example, this can be used to connect an external watch crystal oscillator instead of a watch crystal.   In all cases, the two related GPIO pins (WCO input and output pins) must be configured as analog connections using GPIO registers, and they must be hooked at the board level as described below.  Configure this field before enabling the WCO, and do not change this setting when WCO_EN=1.
0: Watch crystal.  Connect a 32.768 kHz watch crystal between WCO input and output pins.
1: Clock signal, either a square wave or sine wave.  See PRESCALER field for connection information.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDBAK_CTL</name>
              <description>Controls the behavior of the switch that generates vddbak from vbackup or vddd.
0: automatically select vddd if its brownout detector says it is valid.  If the brownout says its not valid, then use vmax which is the highest of vddd or vbackup.
1,2,3: force vddbak and vmax to select vbackup, regardless of its voltage.</description>
              <bitRange>[18:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VBACKUP_MEAS</name>
              <description>Connect vbackup supply to the vbackup_meas output for measurement by an ADC attached to amuxbusa_adft_vddd.  The vbackup_meas signal is scaled to 10 percent of vbackup, so it is within the supply range of the ADC.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CHARGE_KEY</name>
              <description>When set to 3C, the supercap charger circuit is enabled.  Any other code disables the supercap charger.  THIS CHARGING CIRCUIT IS FOR A SUPERCAP ONLY AND CANNOT SAFELY CHARGE A BATTERY.  DO NOT WRITE THIS KEY WHEN VBACKUP IS CONNECTED TO A BATTERY.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_RW</name>
          <description>RTC Read Write register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>READ</name>
              <description>Read bit
When this bit is set the RTC registers will be copied to user registers and frozen so that a coherent RTC value can safely be read. The RTC will keep on running.
Do not set the read bit if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Write bit is set. Do not set the Read bit at the same time that the Write bit is cleared.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WRITE</name>
              <description>Write bit
Only when this bit is set can the RTC registers be written to (otherwise writes are ignored). This bit cannot be set if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Read bit is set or getting set. 
The user writes to the RTC user registers, when the Write bit is cleared by the user then the user registers content is copied to the actual RTC registers. 
Only user RTC registers that were written to will get copied, others will not be affected. 
When the SECONDS field is updated then TICKS will also be reset (WDT is not affected).
When the Write bit is cleared by a reset (brown out/DeepSleep) then the RTC update will be ignored/lost.
Do not set the Write bit if the RTC if the RTC is still busy with a previous update (see RTC_BUSY).  Do not set the Write bit at the same time that the Read bit is cleared.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CAL_CTL</name>
          <description>Oscillator calibration for absolute frequency</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000007F</resetMask>
          <fields>
            <field>
              <name>CALIB_VAL</name>
              <description>Calibration value for absolute frequency (at a fixed temperature).  Each step causes 128 ticks to be added or removed each hour.  Effectively that means that each step is 1.085ppm (= 128/(60*60*32,768)).
Positive values 0x01-0x3c (1..60) add pulses, negative values remove pulses, thus giving a range of +/-65.1 ppm (limited by 60 minutes per hour, not the range of this field)

Calibration is performed hourly, starting at 59 minutes and 59 seconds, and applied as 64 ticks every 30 seconds until there have been 2*CALIB_VAL adjustments.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CALIB_SIGN</name>
              <description>Calibration sign:
0= Negative sign: remove pulses (it takes more clock ticks to count one second)
1= Positive sign: add pulses (it takes less clock ticks to count one second)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_OUT</name>
              <description>Output enable for 512Hz signal for calibration and allow CALIB_VAL to be written. Note that calibration does not affect the 512Hz output signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x5</resetMask>
          <fields>
            <field>
              <name>RTC_BUSY</name>
              <description>pending RTC write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WCO_OK</name>
              <description>Indicates that output has transitioned.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_TIME</name>
          <description>Calendar Seconds, Minutes, Hours, Day of Week</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77F7F7F</resetMask>
          <fields>
            <field>
              <name>RTC_SEC</name>
              <description>Calendar seconds in BCD, 0-59</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MIN</name>
              <description>Calendar minutes in BCD, 0-59</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_HOUR</name>
              <description>Calendar hours in BCD, value depending on 12/24HR mode
0=24HR: [21:16]=0-23
1=12HR: [21]:0=AM, 1=PM, [20:16]=1-12</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTRL_12HR</name>
              <description>Select 12/24HR mode: 1=12HR, 0=24HR</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_DAY</name>
              <description>Calendar Day of the week in BCD, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RTC_DATE</name>
          <description>Calendar Day of Month, Month,  Year</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF1F3F</resetMask>
          <fields>
            <field>
              <name>RTC_DATE</name>
              <description>Calendar Day of the Month in BCD, 1-31
Automatic Leap Year Correction</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_MON</name>
              <description>Calendar Month in BCD, 1-12</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_YEAR</name>
              <description>Calendar year in BCD, 0-99</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_TIME</name>
          <description>Alarm 1 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x87BFFFFF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds in BCD, 0-59</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes in BCD, 0-59</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours in BCD, value depending on 12/24HR mode
12HR: [5]:0=AM, 1=PM, [4:0]=1-12
24HR: [5:0]=0-23</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week in BCD, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM1_DATE</name>
          <description>Alarm 1 Day of Month, Month</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80009FBF</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month in BCD, 1-31
Leap Year corrected</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month in BCD, 1-12</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 1.
0: Alarm 1 is disabled.  Fields for date and time are ignored.
1: Alarm 1 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_TIME</name>
          <description>Alarm 2 Seconds, Minute, Hours, Day of Week</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000000</resetValue>
          <resetMask>0x87BFFFFF</resetMask>
          <fields>
            <field>
              <name>ALM_SEC</name>
              <description>Alarm seconds in BCD, 0-59</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_SEC_EN</name>
              <description>Alarm second enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN</name>
              <description>Alarm minutes in BCD, 0-59</description>
              <bitRange>[14:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MIN_EN</name>
              <description>Alarm minutes enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR</name>
              <description>Alarm hours in BCD, value depending on 12/24HR mode
12HR: [5]:0=AM, 1=PM, [4:0]=1-12
24HR: [5:0]=0-23</description>
              <bitRange>[21:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_HOUR_EN</name>
              <description>Alarm hour enable: 0=ignore, 1=match</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY</name>
              <description>Alarm Day of the week in BCD, 1-7
It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DAY_EN</name>
              <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALM2_DATE</name>
          <description>Alarm 2 Day of Month, Month</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x101</resetValue>
          <resetMask>0x80009FBF</resetMask>
          <fields>
            <field>
              <name>ALM_DATE</name>
              <description>Alarm Day of the Month in BCD, 1-31
Leap Year corrected</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_DATE_EN</name>
              <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON</name>
              <description>Alarm Month in BCD, 1-12</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_MON_EN</name>
              <description>Alarm Month enable: 0=ignore, 1=match</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALM_EN</name>
              <description>Master enable for alarm 2.
0: Alarm 2 is disabled.  Fields for date and time are ignored.
1: Alarm 2 is enabled.  Alarm triggers whenever the new date and time matches all the enabled date and time fields, which can happen more than once depending on configuration.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Alarm 1 Interrupt</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Alarm 2 Interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Century overflow interrupt</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>ALARM1</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ALARM2</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CENTURY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OSCCNT</name>
          <description>32kHz oscillator counter</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CNT32KHZ</name>
              <description>32kHz oscillator count (msb=128Hz), calibration can cause bit 6 to skip.  Reset when RTC_TIME.RTC_SEC fields is written.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TICKS</name>
          <description>128Hz tick counter</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CNT128HZ</name>
              <description>128Hz counter (msb=2Hz)
When SECONDS is written this field will be reset.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMIC_CTL</name>
          <description>PMIC control register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0000000</resetValue>
          <resetMask>0xE001FF00</resetMask>
          <fields>
            <field>
              <name>UNLOCK</name>
              <description>This byte must be set to 0x3A for PMIC to be disabled.  When the UNLOCK code is not present: writes to PMIC_EN field are ignored and the hardware ignores the value in PMIC_EN.  Do not change PMIC_EN in the same write cycle as setting/clearing the UNLOCK code; do these in separate write cycles.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>N/A</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN_OUTEN</name>
              <description>Output enable for the output driver in the PMIC_EN pad.
0: Output pad is tristate for PMIC_EN pin.  This can allow this pin to be used for another purpose. Tristate condition is kept only if the UNLOCK key (0x3A) is present
1: Output pad is enabled for PMIC_EN pin.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_ALWAYSEN</name>
              <description>Override normal PMIC controls to prevent accidentally turning off the PMIC by errant firmware.
0: Normal operation, PMIC_EN and PMIC_OUTEN work as described
1: PMIC_EN and PMIC_OUTEN are ignored and the output pad is forced enabled.
Note: This bit is a write-once bit until the next backup reset.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMIC_EN</name>
              <description>Enable for external PMIC that supplies vddd (if present).  This bit will only clear if UNLOCK was written correctly in a previous write operation and PMIC_ALWAYSEN=0.  When PMIC_EN=0, the system functions normally until vddd is no longer present (OFF w/Backup mode).  Firmware can set this bit, if it does so before vddd is actually removed.  This bit is also set by any RTC alarm or PMIC pin wakeup event regardless of UNLOCK setting.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESET</name>
          <description>Backup reset register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>RESET</name>
              <description>Writing 1 to this register resets the backup logic.  Hardware clears it when the reset is complete.  After setting this register, firmware should confirm it reads as 0 before attempting to write other backup registers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>BREG[%s]</name>
          <description>Backup register region</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BREG</name>
              <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM</name>
          <description>Trim Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>WCO trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DW0</name>
      <description>Datawire Controller</description>
      <headerStructName>DW</headerStructName>
      <baseAddress>0x40280000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC checking:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable parity injection for SRAM.
When '1', the parity (ECC_CTL.PARITY) is used when a full 32-bit write is done to the ECC_CTL.WORD_ADDR word address of the SRAM.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>P</name>
              <description>Active channel, user/privileged access control:
'0': user mode.
'1': privileged mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NS</name>
              <description>Active channel, secure/non-secure access control:
'0': secure.
'1': non-secure.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>B</name>
              <description>Active channel, non-bufferable/bufferable access control:
'0': non-bufferable
'1': bufferable.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PC</name>
              <description>Active channel protection context.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Active channel priority.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PREEMPTABLE</name>
              <description>Active channel preemptable.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_IDX</name>
              <description>Active channel index.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the DW controller. 
'0': Default/inactive state.
'1': Loading descriptor.
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': CRC functionality (only used for CRC transfer descriptor type).
'5': Update of active control information (e.g. source and destination addresses) and wait for trigger de-activation.
'6': Error.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Active channel present: 
'0': No.
'1': Yes.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_CTL</name>
          <description>Active descriptor control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_CTL of the currently active descriptor.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_SRC</name>
          <description>Active descriptor source</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_SRC of the currently active descriptor.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_DST</name>
          <description>Active descriptor destination</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_DST of the currently active descriptor.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_X_CTL</name>
          <description>Active descriptor X loop control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_X_CTL of the currently active descriptor.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_Y_CTL</name>
          <description>Active descriptor Y loop control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Copy of DESCR_Y_CTL of the currently active descriptor.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DESCR_NEXT_PTR</name>
          <description>Active descriptor next pointer</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.</description>
              <bitRange>[31:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_SRC</name>
          <description>Active source</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>SRC_ADDR</name>
              <description>Current address of source location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ACT_DST</name>
          <description>Active destination</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DST_ADDR</name>
              <description>Current address of destination location.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFE0003FF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- On a write transfer to this SRAM word address and when CTL.ECC_INJ_EN bit is '1', the parity (PARITY) is injected.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_CTL</name>
          <description>CRC control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x101</resetMask>
          <fields>
            <field>
              <name>DATA_REVERSE</name>
              <description>Specifies the bit order in which a data Byte is processed (reversal is performed after XORing):
'0': Most significant bit (bit 1) first.
'1': Least significant bit (bit 0) first.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REM_REVERSE</name>
              <description>Specifies whether the remainder is bit reversed (reversal is performed after XORing):
'0': No.
'1': Yes.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_DATA_CTL</name>
          <description>CRC data control</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA_XOR</name>
              <description>Specifies a byte mask with which each data byte is XOR'd. The XOR is performed before data reversal.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_POL_CTL</name>
          <description>CRC polynomial control</description>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POLYNOMIAL</name>
              <description>CRC polynomial. The polynomial is represented WITHOUT the high order bit (this bit is always assumed '1'). The polynomial should be aligned/shifted such that the more significant bits (bit 31 and down) contain the polynomial and the less significant bits (bit 0 and up) contain padding '0's. Some frequently used polynomials:
- CRC32: POLYNOMIAL is 0x04c11db7 (x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1).
- CRC16: POLYNOMIAL is 0x80050000 (x^16 + x^15 + x^2 + 1, shifted by 16 bit positions).
- CRC16 CCITT: POLYNOMIAL is 0x10210000 (x^16 + x^12 + x^5 + 1, shifted by 16 bit positions).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_LFSR_CTL</name>
          <description>CRC LFSR control</description>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LFSR32</name>
              <description>State of a 32-bit Linear Feedback Shift Registers (LFSR) that is used to implement CRC. This register needs to be initialized by SW to provide the CRC seed value.

The seed value should be aligned such that the more significant bits (bit 31 and down) contain the seed value and the less significant bits (bit 0 and up) contain padding '0's.  

Note that SW can write this field. This functionality can be used prevent information leakage (through either CRC_LFSR_CTL or CRC_REM_RESULT).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_CTL</name>
          <description>CRC remainder control</description>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM_XOR</name>
              <description>Specifies a mask with which the CRC_LFSR_CTL.LFSR32 register is XOR'd to produce a remainder. The XOR is performed before remainder reversal.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRC_REM_RESULT</name>
          <description>CRC remainder result</description>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REM</name>
              <description>Remainder value. The alignment of the remainder depends on CRC_REM_CTL0.REM_REVERSE: 
'0': the more significant bits (bit 31 and down) contain the remainder.
'1': the less significant bits (bit 0 and up) contain the remainder. 

Note: This field is combinatorially derived from CRC_LFSR_CTL.LFSR32, CRC_CTL.REM_REVERSE and CRC_REM_CTL.REM_XOR.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>29</dim>
          <dimIncrement>64</dimIncrement>
          <name>CH_STRUCT[%s]</name>
          <description>DW channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CH_CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x80000BF7</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e.  the 'write data' is ignored and instead the access control is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register;  i.e.  the 'write data' is ignored and instead the context is inherited from the write transaction (note the field attributes should be HW:RW, SW:R).

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group. Priority decoding determines the highest priority pending channel. This channel is determined as follows. First, the highest priority group with pending channels is identified. Second, within this priority group, round robin arbitration is applied. Round robin arbitration (within a priority group) gives the highest priority to the lower channel indices (within the priority group).</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>Specifies if the channel is preemptable.
'0': Not preemptable.
'1': Preemptable. This field allows higher priority pending channels (from a higher priority group; i.e. an active channel can NOT be preempted by a pending channel in the same priority group) to preempt the active channel in between 'single transfers' (a 1D transfer consists out of X_COUNT single transfers; a 2D transfer consists out of X_COUNT*Y_COUNT single transfers). Preemption will NOT affect the pending status of channel. As a result, after completion of a higher priority activated channel, the current channel may be reactivated.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' on an error interrupt cause (the specific error is specified by CH_STATUS.INTR_CAUSE).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_STATUS</name>
            <description>Channel status</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>INTR_CAUSE</name>
                <description>Specifies the source of the interrupt cause:
'0': No interrupt generated
'1': Interrupt based on transfer complettion configuration based on INTR_TYPE
'2': Source transfer bus error
'3': Destination transfer bus error
'4': Source address misalignment
'5': Destination address misalignment
'6': Current descriptor pointer is null
'7': Active channel is disabled
'8': Descriptor bus error
'9'-'15': Not used.

For error related interrupt causes (INTR_CAUSE is '2', '3', ..., '8'), the channel is disabled (HW sets CH_CTL.ENABLED to '0').</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PENDING</name>
                <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_IDX</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>Y_IDX</name>
                <description>Specifies the Y loop index, with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: SW should set this field to '0' when it updates CH_CURR_PTR.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CH_CURR_PTR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor. 

Note: Typically, when SW updates the current descriptor pointer CH_CURR_PTR, it also sets CH_IDX.X_IDX and CH_IDX.Y_IDX to '0'.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Set to '1', when event (as specified by CH_STATUS.INTR_CAUSE) is detected. Write INTR.CH field with '1', to clear bit. Write INTR_SET.CH field with '1', to set bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR.CH field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CH</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA0</name>
            <description>SRAM data 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRAM_DATA1</name>
            <description>SRAM data 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channel software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="DW0">
      <name>DW1</name>
      <baseAddress>0x40290000</baseAddress>
    </peripheral>
    <peripheral>
      <name>DMAC</name>
      <description>DMAC</description>
      <baseAddress>0x402A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ACTIVE</name>
          <description>Active channels</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>ACTIVE</name>
              <description>Specifies active channels; i.e. enabled channels whose trigger got activated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>DMA controller channel</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Channel control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2</resetValue>
            <resetMask>0x800003F7</resetMask>
            <fields>
              <field>
                <name>P</name>
                <description>User/privileged access control:
'0': user mode.
'1': privileged mode.

This field is set with the user/privileged access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the P field for the user/privileged access control ('hprot[1]').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NS</name>
                <description>Secure/on-secure access control:
'0': secure.
'1': non-secure.

This field is set with the secure/non-secure access control of the transaction that writes this register; i.e. the access control is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel use the NS field for the secure/non-secure access control ('hprot[4]').</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>B</name>
                <description>Non-bufferable/bufferable access control:
'0': non-bufferable.
'1': bufferable.

This field is used to indicate to an AMBA bridge that a write transaction can complete without waiting for the destination to accept the write transaction data.

All transactions for this channel uses the B field for the non-bufferable/bufferable access control ('hprot[2]').</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PC</name>
                <description>Protection context.

This field is set with the protection context of the transaction that writes this register; i.e. the context is inherited from the write transaction and not specified by the transaction write data.

All transactions for this channel uses the PC field for the protection context.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRIO</name>
                <description>Channel priority:
'0': highest priority.
'1'
'2'
'3': lowest priority.

Channels with the same priority constitute a priority group and within this priority group, the following 'roundrobin' arbitration is applied. 
A 'round' consists of a contiguous sequence of channel activations, within this priority group, without any repetition. Within a round, higher priority is given to the lower channel indices. The notion of a round guarantees that within a group, higher channel indices do not yield to lower indices indefinitely.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. The channel's trigger is ignored and the channel cannot be made pending and therefore cannot be made active. If a pending channel is disabled, the channel is made non pending. If the activate channel is disabled, the channel is de-activated (bus transactions are completed). 
'1': Enabled.

SW sets this field to '1' to enable a specific channel.

HW sets this field to '0' when an error interrupt cause is activated.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IDX</name>
            <description>Channel current indices</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X</name>
                <description>Specifies the X loop index. In the range of [0, X_COUNT], with X_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>Y</name>
                <description>Specifies the Y loop index, with Y_COUNT taken from the current descriptor. 

Note: HW sets this field to '0' when it loads a descriptor..</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SRC</name>
            <description>Channel current source address</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of source location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DST</name>
            <description>Channel current destination address</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Current address of destination location.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR</name>
            <description>Channel current descriptor pointer</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>Address of current descriptor. When this field is '0', there is no valid descriptor.

Note: HW updates the current descriptor pointer CH_CURR_PTR with DESCR_NEXT_PTR after execution of the current descriptor.</description>
                <bitRange>[31:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CMD</name>
            <description>Channle software trigger</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>ACTIVATE</name>
                <description>Software trigger. When written with '1', a trigger is generated which sets 'trigger pending' (only if the channel is enabled). A read always returns a 0.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_STATUS</name>
            <description>Channel descriptor status</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>VALID</name>
                <description>Indicates whether the descriptor information present in DESCR_CTL, DESCR_SRC, DESCR_DST, DESCR_X_SIZE, DESCR_X_INCR, DESCR_Y_SIZE, DESCR_Y_INCR, DESCR_NEXT status registers is valid or not.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_CTL</name>
            <description>Channel descriptor control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>N/A</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INTR_TYPE</name>
                <description>N/A</description>
                <bitRange>[3:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_OUT_TYPE</name>
                <description>N/A</description>
                <bitRange>[5:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TR_IN_TYPE</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_PREFETCH</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CH_DISABLE</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_TYPE</name>
                <description>N/A</description>
                <bitRange>[30:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_SRC</name>
            <description>Channel descriptor source</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_DST</name>
            <description>Channel descriptor destination</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>N/A</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_SIZE</name>
            <description>Channel descriptor X size</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>X_COUNT</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_X_INCR</name>
            <description>Channel descriptor X increment</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_X</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_X</name>
                <description>N/A</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_SIZE</name>
            <description>Channel descriptor Y size</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>Y_COUNT</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_Y_INCR</name>
            <description>Channel descriptor Y increment</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SRC_Y</name>
                <description>N/A</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_Y</name>
                <description>N/A</description>
                <bitRange>[31:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DESCR_NEXT</name>
            <description>Channel descriptor next pointer</description>
            <addressOffset>0x7C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PTR</name>
                <description>N/A</description>
                <bitRange>[31:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Activated (set to '1') on completion of data transfer(s) as specified by the descriptor's CH_DESCR_CTL.INTR_TYPE.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load from the source.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a store to the destination.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the source address.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>Activated (set to '1') on a misalignment of the destination address.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>Activated (set to '1') when the channel is enabled (CH_CTL.ENABLED is '1') and CH_CURR_PTR is '0'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>Activated (set to '1') if the channel is disabled by SW (accidentally/incorrectly) when the data transfer engine is busy.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>Activated (set to '1') on a bus error for a load of the descriptor.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Write this field with '1' to set corresponding INTR field to '1' (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0x8C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>COMPLETION</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SRC_MISAL</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DST_MISAL</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CURR_PTR_NULL</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ACTIVE_CH_DISABLED</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DESCR_BUS_ERROR</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>EFUSE</name>
      <description>EFUSE MXS40 registers</description>
      <baseAddress>0x402C0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>128</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x800F1F71</resetMask>
          <fields>
            <field>
              <name>BIT_DATA</name>
              <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields. This bit is a don't care for the MXS40 Macro.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ADDR</name>
              <description>Bit address. This field specifies a bit within a Byte.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_ADDR</name>
              <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MACRO_ADDR</name>
              <description>Macro address. This field specifies an eFUSE macro.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.

Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.

Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.

Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_DEFAULT</name>
          <description>Sequencer Default value</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1D0000</resetValue>
          <resetMask>0x7F0000</resetMask>
          <fields>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_0</name>
          <description>Sequencer read control 0</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_1</name>
          <description>Sequencer read control 1</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_2</name>
          <description>Sequencer read control 2</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x560001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_3</name>
          <description>Sequencer read control 3</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x540003</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_4</name>
          <description>Sequencer read control 4</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80150001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_READ_CTL_5</name>
          <description>Sequencer read control 5</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310004</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_0</name>
          <description>Sequencer program control 0</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_1</name>
          <description>Sequencer program control 1</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x220020</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_2</name>
          <description>Sequencer program control 2</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200001</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_3</name>
          <description>Sequencer program control 3</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x310005</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_4</name>
          <description>Sequencer program control 4</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80350006</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_PROGRAM_CTL_5</name>
          <description>Sequencer program control 5</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x803D0019</resetValue>
          <resetMask>0x807F03FF</resetMask>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_A</name>
              <description>Specifies value of eFUSE control signal strobe_a</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_B</name>
              <description>Specifies value of eFUSEcontrol signal strobe_b</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_C</name>
              <description>Specifies value of eFUSE control signal strobe_c</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_D</name>
              <description>Specifies value of eFUSE control signal strobe_d</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_E</name>
              <description>Specifies value of eFUSE control signal strobe_e</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_F</name>
              <description>Specifies value of eFUSE control signal strobe_f</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STROBE_G</name>
              <description>Specifies value of eFUSE control signal strobe_g</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DONE</name>
              <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PROFILE</name>
      <description>Energy Profiler IP</description>
      <baseAddress>0x402D0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Profile control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>WIN_MODE</name>
              <description>Specifies the profiling time window mode:
'0': Start / stop mode. The profiling time window is started when a rising edge of the start trigger signal occurs and stopped when a rising edge of the stop trigger signal occurs.
In case both rising edges (of start and stop trigger signals) occur in the same cycle, the profiling time window is stopped.
'1': Enable mode. The profiling time window is active as long as the start 'trigger' signal is active. The stop trigger signal has no effect.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Enables the profiling block:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Profile status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WIN_ACTIVE</name>
              <description>Indicates if the profiling time window is active.
'0': Not active.
'1': Active.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Profile command</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x103</resetMask>
          <fields>
            <field>
              <name>START_TR</name>
              <description>Software start trigger for the profiling time window. When written with '1', the profiling time window is started.
Can only be used in start / stop mode (PROFILE_WIN_MODE=0).
Has no effect in enable mode (PROFILE_WIN_MODE=1).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_TR</name>
              <description>Software stop trigger for the profiling time window. When written with '1', the profiling time window is stopped.
Can only be used in start / stop mode (PROFILE_WIN_MODE=0).
Has no effect in enable mode (PROFILE_WIN_MODE=1).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLR_ALL_CNT</name>
              <description>Counter clear. When written with '1', all profiling counter registers are cleared to 0x00.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Profile interrupt</description>
          <addressOffset>0x7C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_OVFLW</name>
              <description>This interrupt cause field is activated (HW sets the field to '1') when an profiling counter overflow (from 0xFFFFFFFF to 0x00000000) is captured. There is one bit per profling counter.

SW writes a '1' to a bit of this field to clear this bit to '0' (writing 0xFFFFFFFF clears all interrupt causes to '0').</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Profile interrupt set</description>
          <addressOffset>0x7C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_OVFLW</name>
              <description>SW writes a '1' to a bit of this field to set the corresponding bit in the INTR register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Profile interrupt mask</description>
          <addressOffset>0x7C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_OVFLW</name>
              <description>Mask bit for corresponding field in the INTR register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Profile interrupt masked</description>
          <addressOffset>0x7CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNT_OVFLW</name>
              <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>16</dimIncrement>
          <name>CNT_STRUCT[%s]</name>
          <description>Profile counter structure</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>CTL</name>
            <description>Profile counter configuration</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x807F0071</resetMask>
            <fields>
              <field>
                <name>CNT_DURATION</name>
                <description>This field specifies if events (edges) or a duration of the monitor signal is counted.
'0': Events are monitored. An edge detection is done. All edges of the selected monitor signal are counted.
'1': A duration is monitored. No edge detection is done. The monitored signal is taken as a (high active) level signal for enabling the profiling counter.

Note: All monitor signals which only can represent events are edge encoded in hardware, therefore a selection of CTL.CNT_DURATION=1 will not produce meaningful results.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REF_CLK_SEL</name>
                <description>This field specifies the reference clock used for a counting time base when counting durations. Has no effect when CTL.CNT_DURATION=0.</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CLK_TIMER</name>
                    <description>Timer clock (divided or undivided high frequency clock, e.g. from IMO). Selection is done in SRSS register CLK_TIMER_CTL.TIMER_SEL.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLK_IMO</name>
                    <description>IMO - Internal Main Oscillator</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLK_ECO</name>
                    <description>ECO - External-Crystal Oscillator</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLK_LF</name>
                    <description>Low frequency clock (ILO, WCO or ALTLF). 
Selection is done in SRSS register CLK_SELECT.LFCLK_SEL.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLK_HF</name>
                    <description>High frequuency clock ('clk_hfx').</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLK_PERI</name>
                    <description>Peripheral clock ('clk_peri').</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD_6</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD_7</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MON_SEL</name>
                <description>This field specifies the montior input signal to be observed by the profiling counter.
The monitor signals are product specific, see product definition spreadsheet tab 'Monitor' for details.</description>
                <bitRange>[22:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enables the profiling counter:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>Profile counter value</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>This field shows / specifies the actual value of the profiling counter. It allows reading as well as writing the profiling counter.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>15</dim>
          <dimIncrement>16</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL0</name>
            <description>Port selection 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pin 0 route.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>GPIO controls 'out'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>GPIO controls 'out', DSI controls 'output enable'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controls 'out' and 'output enable'</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controls 'out', GPIO controls 'output enable'</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>Analog mux bus A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>Analog mux bus B</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA_DSI</name>
                    <description>Analog mux bus A, DSI control</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB_DSI</name>
                    <description>Analog mux bus B, DSI control</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Active functionality 0</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Active functionality 1</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Active functionality 2</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Active functionality 3</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_0</name>
                    <description>DeepSleep functionality 0</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_1</name>
                    <description>DeepSleep functionality 1</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>DeepSleep functionality 2</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>DeepSleep functionality 3</description>
                    <value>15</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_4</name>
                    <description>Active functionality 4</description>
                    <value>16</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_5</name>
                    <description>Active functionality 5</description>
                    <value>17</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_6</name>
                    <description>Active functionality 6</description>
                    <value>18</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_7</name>
                    <description>Active functionality 7</description>
                    <value>19</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_8</name>
                    <description>Active functionality 8</description>
                    <value>20</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_9</name>
                    <description>Active functionality 9</description>
                    <value>21</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_10</name>
                    <description>Active functionality 10</description>
                    <value>22</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_11</name>
                    <description>Active functionality 11</description>
                    <value>23</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_12</name>
                    <description>Active functionality 12</description>
                    <value>24</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_13</name>
                    <description>Active functionality 13</description>
                    <value>25</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_14</name>
                    <description>Active functionality 14</description>
                    <value>26</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_15</name>
                    <description>Active functionality 15</description>
                    <value>27</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_4</name>
                    <description>DeepSleep functionality 4</description>
                    <value>28</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_5</name>
                    <description>DeepSleep functionality 5</description>
                    <value>29</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_6</name>
                    <description>DeepSleep functionality 6</description>
                    <value>30</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_7</name>
                    <description>DeepSleep functionality 7</description>
                    <value>31</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pin 1 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pin 2 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pin 3 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PORT_SEL1</name>
            <description>Port selection 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F1F1F1F</resetMask>
            <fields>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pin 4 route.
See PORT_SEL0 for connection details.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pin 5 route.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pin 6 route.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pin 7 route.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_0</name>
          <description>Power/Ground Monitor cell control 0</description>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_1</name>
          <description>Power/Ground Monitor cell control 1</description>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_2</name>
          <description>Power/Ground Monitor cell control 2</description>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MONITOR_CTL_3</name>
          <description>Power/Ground Monitor cell control 3</description>
          <addressOffset>0x220C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MONITOR_EN</name>
              <description>control for switch, which connects the power/ground supply to AMUXBUS_A/B respectively when switch is closed:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ALT_JTAG_EN</name>
          <description>Alternate JTAG IF selection register</description>
          <addressOffset>0x2240</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Provides the selection for alternate JTAG IF connectivity.
0: Primary JTAG interface is selected
1: Secondary (alternate) JTAG interface is selected.

This connectivity works ONLY in ACTIVE mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40310000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>15</dim>
          <dimIncrement>128</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>OUT</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO output data for pin 0
'0': Output state set to '0'
'1': Output state set to '1'</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO output data for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO output data for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO output data for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO output data for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO output data for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO output data for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO output data for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO clear output for pin 0:
'0': Output state not affected.
'1': Output state set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO clear output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO clear output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO clear output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO clear output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO clear output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO clear output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO clear output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO set output for pin 0:
'0': Output state not affected.
'1': Output state set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO set output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO set output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO set output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO set output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO set output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO set output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO set output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OUT_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>OUT0</name>
                <description>IO invert output for pin 0:
'0': Output state not affected.
'1': Output state inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT1</name>
                <description>IO invert output for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT2</name>
                <description>IO invert output for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT3</name>
                <description>IO invert output for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT4</name>
                <description>IO invert output for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT5</name>
                <description>IO invert output for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT6</name>
                <description>IO invert output for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT7</name>
                <description>IO invert output for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>IN</name>
            <description>Port input state register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>IN0</name>
                <description>IO pin state for pin 0
'0': Low logic level present on pin.
'1': High logic level present on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN</name>
                <description>Reads of this register return the logical state of the filtered pin as selected in the INTR_CFG.FLT_SEL register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detect for IO pin 0
'0': No edge was detected on pin.
'1': An edge was detected on pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detect for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detect for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detect for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detect for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detect for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detect for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detect for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_IN0</name>
                <description>IO pin state for pin 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN1</name>
                <description>IO pin state for pin 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN2</name>
                <description>IO pin state for pin 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN3</name>
                <description>IO pin state for pin 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN4</name>
                <description>IO pin state for pin 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN5</name>
                <description>IO pin state for pin 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN6</name>
                <description>IO pin state for pin 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>IN_IN7</name>
                <description>IO pin state for pin 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_IN_IN</name>
                <description>Filtered pin state for pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Port interrupt mask register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Masks edge interrupt on IO pin 0
'0': Pin interrupt forwarding disabled
'1': Pin interrupt forwarding enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Masks edge interrupt on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Masks edge interrupt on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Masks edge interrupt on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Masks edge interrupt on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Masks edge interrupt on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Masks edge interrupt on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Masks edge interrupt on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Masks edge interrupt on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Port interrupt masked status register</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Edge detected AND masked on IO pin 0
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Edge detected and masked on IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Edge detected and masked on IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Edge detected and masked on IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Edge detected and masked on IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Edge detected and masked on IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Edge detected and masked on IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Edge detected and masked on IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Edge detected and masked on filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Port interrupt set register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>EDGE0</name>
                <description>Sets edge detect interrupt for IO pin 0
'0': Interrupt state not affected
'1': Interrupt set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE1</name>
                <description>Sets edge detect interrupt for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2</name>
                <description>Sets edge detect interrupt for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3</name>
                <description>Sets edge detect interrupt for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4</name>
                <description>Sets edge detect interrupt for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5</name>
                <description>Sets edge detect interrupt for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6</name>
                <description>Sets edge detect interrupt for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7</name>
                <description>Sets edge detect interrupt for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE</name>
                <description>Sets edge detect interrupt for filtered pin selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pin 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Sets which edge will trigger an IRQ for the glitch filtered pin (selected by INTR_CFG.FLT_SEL</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG</name>
            <description>Port configuration register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DRIVE_MODE0</name>
                <description>The GPIO drive mode for IO pin 0. Resistive pull-up and pull-down is selected in the drive mode.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the peripheral and HSIOM (HSIOM_PRT_SELx) is properly configured  before turning the IO on here to avoid producing glitches on the bus.
Note: that peripherals other than GPIO &amp; UDB/DSI directly control both the output and output-enable of the output buffer (peripherals can drive strong 0 or strong 1 in any mode except OFF='0').  
Note: D_OUT, D_OUT_EN are pins of GPIO cell.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HIGHZ</name>
                    <description>Output buffer is off creating a high impedance input
D_OUT = '0': High Impedance
D_OUT = '1': High Impedance</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP</name>
                    <description>Resistive pull up

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Weak/resistive pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull up
   D_OUT = '1': Weak/resistive pull up</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLDOWN</name>
                    <description>Resistive pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': Weak/resistive pull down
   D_OUT = '1': Weak/resistive pull down</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESLOW</name>
                    <description>Open drain, drives low

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': High Impedance
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OD_DRIVESHIGH</name>
                    <description>Open drain, drives high

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': High Impedance
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STRONG</name>
                    <description>Strong D_OUTput buffer

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High impedance
   D_OUT = '1': High impedance

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
   D_OUT = '0': High Impedance
   D_OUT = '1': High Impedance</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PULLUP_DOWN</name>
                    <description>Pull up or pull down

For GPIO &amp; UDB/DSI peripherals:
When D_OUT_EN = '0':
    GPIO_DSI_OUT = '0': Weak/resistive pull down
    GPIO_DSI_OUT = '1': Weak/resistive pull up
where 'GPIO_DSI_OUT' is a function of PORT_SEL, OUT &amp; DSI_DATA_OUT.

For peripherals other than GPIO &amp; UDB/DSI:
When D_OUT_EN = 1:
   D_OUT = '0': Strong pull down
   D_OUT = '1': Strong pull up
When D_OUT_EN = 0:
    D_OUT = '0': Weak/resistive pull down
    D_OUT = '1': Weak/resistive pull up</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IN_EN0</name>
                <description>Enables the input buffer for IO pin 0.  This bit should be cleared when analog signals are present on the pin to avoid crowbar currents.  The output buffer can be used to drive analog signals high or low without issue.
'0': Input buffer disabled
'1': Input buffer enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE1</name>
                <description>The GPIO drive mode for IO pin 1</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN1</name>
                <description>Enables the input buffer for IO pin 1</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE2</name>
                <description>The GPIO drive mode for IO pin 2</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN2</name>
                <description>Enables the input buffer for IO pin 2</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE3</name>
                <description>The GPIO drive mode for IO pin 3</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN3</name>
                <description>Enables the input buffer for IO pin 3</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE4</name>
                <description>The GPIO drive mode for IO pin4</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN4</name>
                <description>Enables the input buffer for IO pin 4</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE5</name>
                <description>The GPIO drive mode for IO pin 5</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN5</name>
                <description>Enables the input buffer for IO pin 5</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE6</name>
                <description>The GPIO drive mode for IO pin 6</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN6</name>
                <description>Enables the input buffer for IO pin 6</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_MODE7</name>
                <description>The GPIO drive mode for IO pin 7</description>
                <bitRange>[30:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_EN7</name>
                <description>Enables the input buffer for IO pin 7</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN</name>
            <description>Port input buffer configuration register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_0</name>
                <description>Configures the pin 0 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS</name>
                    <description>PSoC 6:: Input buffer compatible with CMOS and I2C interfaces
Traveo II: Full encoding is shown in CFG_IN_AUTOLVL.VTRIP_SEL0_1</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TTL</name>
                    <description>PSoC 6:: Input buffer compatible with TTL and MediaLB interfaces
Traveo II: full encoding is shown in CFG_IN_AUTOLVL.VTRIP_SEL0_1</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_0</name>
                <description>Configures the pin 1 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_0</name>
                <description>Configures the pin 2 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_0</name>
                <description>Configures the pin 3 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_0</name>
                <description>Configures the pin 4 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_0</name>
                <description>Configures the pin 5 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_0</name>
                <description>Configures the pin 6 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_0</name>
                <description>Configures the pin 7 input buffer mode (trip points and hysteresis)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_OUT</name>
            <description>Port output buffer configuration register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF00FF</resetMask>
            <fields>
              <field>
                <name>SLOW0</name>
                <description>Enables slow slew rate for IO pin 0
'0': Fast slew rate
'1': Slow slew rate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW1</name>
                <description>Enables slow slew rate for IO pin 1</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW2</name>
                <description>Enables slow slew rate for IO pin 2</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW3</name>
                <description>Enables slow slew rate for IO pin 3</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW4</name>
                <description>Enables slow slew rate for IO pin 4</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW5</name>
                <description>Enables slow slew rate for IO pin 5</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW6</name>
                <description>Enables slow slew rate for IO pin 6</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLOW7</name>
                <description>Enables slow slew rate for IO pin 7</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL0</name>
                <description>Sets the GPIO drive strength for IO pin 0</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ZERO</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: Full drive strengh: GPIO drives current at its max rated spec.
Traveo II:_GPIO_SMC: GPIO_SMC default mode.
Traveo II:_HSIO_STD: HSIO default mode.
PSoC 6: GPIO cells and HSIO_STD cells: Full drive strength: GPIO drives current at its max rated spec.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_ONE</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: Full drive strengh: GPIO drives current at its max rated spec.
Traveo II:_GPIO_SMC: GPIO full drive strength.
Traveo II:_HSIO_STD: GPIO full drive strength.
PSoC 6: GPIO cells and HSIO_STD cells: 1/2 drive strength: GPIO drives current at 1/2 of its max rated spec</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_TWO</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: 1/2 drive strength: GPIO drives current at 1/2 of its max rated spec.
Traveo II:_GPIO_SMC: GPIO 1/2 drive strength.
Traveo II:_HSIO_STD: GPIO 1/2 drive strength.
PSoC 6: GPIO cells and HSIO_STD cells: 1/4 drive strength. GPIO drives current at 1/4 of its max rated spec.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DRIVE_SEL_THREE</name>
                    <description>Traveo II: GPIO_STD/GPIO_ENH: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
Traveo II:_GPIO_SMC: GPIO 1/4 drive strength.
Traveo II:_HSIO_STD: GPIO 1/4 drive strength.
PSoC 6: GPIO cells and HSIO_STD cells: 1/8 drive strength. GPIO drives current at 1/8 of its max rated spec.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DRIVE_SEL1</name>
                <description>Sets the GPIO drive strength for IO pin 1</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL2</name>
                <description>Sets the GPIO drive strength for IO pin 2</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL3</name>
                <description>Sets the GPIO drive strength for IO pin 3</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL4</name>
                <description>Sets the GPIO drive strength for IO pin 4</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL5</name>
                <description>Sets the GPIO drive strength for IO pin 5</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL6</name>
                <description>Sets the GPIO drive strength for IO pin 6</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRIVE_SEL7</name>
                <description>Sets the GPIO drive strength for IO pin 7</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>VREG_EN01</name>
                <description>Selects the output buffer mode:
'0': Unregulated output buffer
'1': Regulated output buffer
The regulated output mode is selected ONLY if the CFG.DRIVE_MODE bits are set to the strong pull up (Z_1 = '5') mode. If the CFG.DRIVE_MODE bits are set to any other mode the regulated output buffer will be disabled and the standard CMOS output buffer is used.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL01</name>
                <description>Selects the input buffer mode:
0: Singled ended input buffer
1: Differential input buffer</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL01</name>
                <description>Selects the input buffer trip-point in single ended input buffer mode (IBUF_SEL = '0'):
'0': Input buffer functions as a CMOS input buffer.
'1': Input buffer functions as a TTL input buffer.
In differential input buffer mode (IBUF_SEL = '1')
'0': Trip-point is 0.5*Vddio or 0.5*Voh (depends on VREF_SEL/VOH_SEL)
'1': Trip-point is 0.4*Vddio or 1.0*Vref  (depends on VREF_SEL)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL01</name>
                <description>Selects reference voltage (Vref) trip-point of the input buffer:
'0': Trip-point reference from pin_ref
'1': Trip-point reference of SRSS internal reference Vref (1.2 V)
'2': Trip-point reference of AMUXBUS_A
'3': Trip-point reference of AMUXBUS_B</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL01</name>
                <description>Selects the regulated Voh output level and trip point of the input buffer for a specific SIO pin pair. Voh depends on the selected reference voltage (VREF_SEL). 
'0': Voh = 1*reference; e.g. reference at 1.2V -&gt; Voh = 1.2V 
'1': Voh = 1.25*reference; e.g. reference at 1.2V -&gt; Voh = 1.5V
'2': Voh = 1.49*reference; e.g. reference at 1.2V -&gt; Voh = ~1.8V
'3': Voh = 1.67*reference; e.g. reference at 1.2V -&gt; Voh = 2V
'4': Voh = 2.08*reference; e.g. reference at 1.2V -&gt; Voh = 2.5V
'5': Voh = 2.5*reference; e.g. reference at 1.2V -&gt; Voh = 3V
'6': Voh = 2.78*reference; e.g. reference at 1.2V -&gt; Voh = ~3.3V
'7': Voh = 4.16*reference; e.g. reference at 1.2V -&gt; Voh = 5.0V
Note: The upper value on Voh is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL23</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL45</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREG_EN67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBUF_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VOH_SEL67</name>
                <description>See corresponding definition for IO pins 0 and 1</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CFG_IN_AUTOLVL</name>
            <description>Port input buffer AUTOLVL configuration register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>VTRIP_SEL0_1</name>
                <description>Configures the input buffer mode (trip points and hysteresis) for GPIO upper bit.  Lower bit is still selected by CFG_IN.VTRIP_SEL0_0 field.  This field is used along with CFG_IN.VTRIP_SEL0_0 field as below:
{CFG_IN_AUTOLVL.VTRIP_SEL0_1,CFG_IN.VTRIP_SEL0_0}:
0,0: CMOS
0,1: TTL
1,0: input buffer is compatible with automotive.
1,1: input buffer is compatible with automotvie</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CMOS_OR_TTL</name>
                    <description>Input buffer compatible with CMOS/TTL interfaces as described in CFG_IN.VTRIP_SEL0_0.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AUTO</name>
                    <description>Input buffer compatible with AUTO (elevated Vil) interfaces when used along with CFG_IN.VTRIP_SEL0_0.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>VTRIP_SEL1_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL2_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL3_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL4_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL5_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL6_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VTRIP_SEL7_1</name>
                <description>Input buffer compatible with automotive (elevated Vil) interfaces.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE0</name>
          <description>Interrupt port cause register 0</description>
          <addressOffset>0x4000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE1</name>
          <description>Interrupt port cause register 1</description>
          <addressOffset>0x4004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE2</name>
          <description>Interrupt port cause register 2</description>
          <addressOffset>0x4008</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE3</name>
          <description>Interrupt port cause register 3</description>
          <addressOffset>0x400C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
'0': Port has no pending interrupt
'1': Port has pending interrupt</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_ACTIVE</name>
          <description>Extern power supply detection register</description>
          <addressOffset>0x4010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
'0': Supply is not present
'1': Supply is present

When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
0: vbackup, 
1: vddio_0, 
2: vddio_1,
3: vddio_a,
4: vddio_r,
5: vddusb'</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR</name>
          <description>Supply detection interrupt register</description>
          <addressOffset>0x4014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply state change detected.
'0': No change to supply detected
'1': Change to supply detected</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASK</name>
          <description>Supply detection interrupt mask register</description>
          <addressOffset>0x4018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Masks supply interrupt on VDDIO.
'0': VDDIO interrupt forwarding disabled
'1': VDDIO interrupt forwarding enabled</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_MASKED</name>
          <description>Supply detection interrupt masked register</description>
          <addressOffset>0x401C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Supply transition detected AND masked
'0': Interrupt was not forwarded to CPU
'1': Interrupt occurred and was forwarded to CPU</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VDD_INTR_SET</name>
          <description>Supply detection interrupt set register</description>
          <addressOffset>0x4020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>VDDIO_ACTIVE</name>
              <description>Sets supply interrupt.
'0': Interrupt state not affected
'1': Interrupt set</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDD_ACTIVE</name>
              <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMARTIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40320000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>10</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and SMARTIO fabric is always bypassed.
'0': No bypass (programmable SMARTIO fabric is exposed). 
'1': Bypass (programmable SMARTIOIO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_smartio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_smartio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_smartio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_smartio' (note that 'clk_smartio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': Same as '17'. Note that the M0S8 SMARTIO version used the Hibernate reset for this value, but the MXS40 SMARTIO version does not support Hibernate functionality.  
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': asynchronous mode/'1'.  Select this when clockless operation is configured.

NOTE: Two positive edges of the selected clock are required for the block to be enabled (to deactivate reset).  In asynchronous (clockless) mode clk_sys is used to enable the block, but is not available for clocking.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep power mode, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the SMARTIO is supposed to deliver DeepSleep output functionality on these IO pads. This field is used to control the hold override functionality from the SMARTIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The SMARTIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the SMARTIO sets hold override to 'pwr_hld_ovr_hib' to enable SMARTIO functionality in DeepSleep power mode (but disables it in Hibernate or Stop power mode).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCOMP</name>
      <description>Low Power Comparators</description>
      <baseAddress>0x40350000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>LPCOMP Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>LPREF_EN</name>
              <description>Enable the local reference generator circuit to generate the local Vref and ibias. This bit must be set for DeepSleep or Hibernate operation.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: IP disabled (put analog in power down, open all switches, all clocks off, leakage power only)
- 1: IP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>LPCOMP Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>OUT0</name>
              <description>Current output value of the comparator 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OUT1</name>
              <description>Current output value of the comparator 1.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>LPCOMP Interrupt request register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>LPCOMP Interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>LPCOMP Interrupt request mask</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>LPCOMP Interrupt request masked</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_CTRL</name>
          <description>Comparator 0 control Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCE3</resetMask>
          <fields>
            <field>
              <name>MODE0</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP</name>
                  <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST0</name>
              <description>Add 30mV hysteresis to the comparator
0= Disable Hysteresis
1= Enable Hysteresis</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE0</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_BYPASS0</name>
              <description>Asynchronous: bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async).
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL0</name>
              <description>Synchronous comparator DSI (trigger) output  : 0=pulse, 1=level</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_SW</name>
          <description>Comparator 0 switch control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP0_IP0</name>
              <description>Comparator 0 positive terminal isolation switch to GPIO</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AP0</name>
              <description>Comparator 0 positive terminal  switch to amuxbusA</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BP0</name>
              <description>Comparator 0 positive terminal  switch to amuxbusB</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_IN0</name>
              <description>Comparator 0 negative terminal isolation switch to GPIO</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AN0</name>
              <description>Comparator 0 negative terminal  switch to amuxbusA</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BN0</name>
              <description>Comparator 0 negative terminal  switch to amuxbusB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_VN0</name>
              <description>Comparator 0 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP0_SW_CLEAR</name>
          <description>Comparator 0 switch control clear</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP0_IP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BP0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_IN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_AN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_BN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP0_VN0</name>
              <description>see corresponding bit in CMP0_SW</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_CTRL</name>
          <description>Comparator 1 control Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCE3</resetMask>
          <fields>
            <field>
              <name>MODE1</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP</name>
                  <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST1</name>
              <description>Add 30mV hysteresis to the comparator
0= Disable Hysteresis
1= Enable Hysteresis</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE1</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_BYPASS1</name>
              <description>Asynchronous: bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async).
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL1</name>
              <description>Synchronous comparator DSI (trigger) output  : 0=pulse, 1=level</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_SW</name>
          <description>Comparator 1 switch control</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP1_IP1</name>
              <description>Comparator 1 positive terminal isolation switch to GPIO</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AP1</name>
              <description>Comparator 1 positive terminal  switch to amuxbusA</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BP1</name>
              <description>Comparator 1 positive terminal  switch to amuxbusB</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_IN1</name>
              <description>Comparator 1 negative terminal isolation switch to GPIO</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AN1</name>
              <description>Comparator 1 negative terminal  switch to amuxbusA</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BN1</name>
              <description>Comparator 1 negative terminal  switch to amuxbusB</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_VN1</name>
              <description>Comparator 1 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMP1_SW_CLEAR</name>
          <description>Comparator 1 switch control clear</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>CMP1_IP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BP1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_IN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_AN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_BN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMP1_VN1</name>
              <description>see corresponding bit in CMP1_SW</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CSD0</name>
      <description>Capsense Controller</description>
      <headerStructName>CSD</headerStructName>
      <baseAddress>0x40360000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration and Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x4000000</resetValue>
          <resetMask>0xCF0E1DF1</resetMask>
          <fields>
            <field>
              <name>IREF_SEL</name>
              <description>Select Iref supply.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IREF_SRSS</name>
                  <description>select SRSS Iref (default)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF_PASS</name>
                  <description>select PASS.AREF Iref, only available if PASS IP is on the chip.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTER_DELAY</name>
              <description>This value determines the number of cycles that the digital filter makes the CSDCMP output ignored while the counter counts and IDAC is on. 
When set to 0 the digital filter is off. When set to any other value the ignoring will last for FILTER_DELAY clk_csd cycles after the start of each measurement and from the first comparator trip to the end of each measurement.</description>
              <bitRange>[8:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SHIELD_DELAY</name>
              <description>Selects the delay by which csd_shield is delayed relative to csd_sense.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Delay line is off, csd_shield=csd_sense</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D5NS</name>
                  <description>Introduces a 5ns delay (typ)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D10NS</name>
                  <description>Introduces a 10ns delay (typ)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D20NS</name>
                  <description>Introduces a 20ns delay (typ)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SENSE_EN</name>
              <description>Enables the sense modulator output. 
0: all switches, static or dynamic, are open and IDAC in CSD mode is off
1: switches and IDAC can be closed/on as per MMIO setting and CSD sequencer.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL_WAVE</name>
              <description>Enables full wave cap sensing mode</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HALFWAVE</name>
                  <description>Half Wave mode (normal).
In this mode the comparator always trips in the same direction (positive or negative edge) and the same Vref, i.e. no polarity change.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FULLWAVE</name>
                  <description>Full Wave mode.
In this mode the comparator trips in opposite direction and with different Vref in each phase, i.e. the polarity flips.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MUTUAL_CAP</name>
              <description>Enables mutual cap sensing mode</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SELFCAP</name>
                  <description>Self-cap mode (configure sense line as CSD_SENSE)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MUTUALCAP</name>
                  <description>Mutual-cap mode (configure Tx line as CSD_SENSE, inverted Tx line as CSD_SHIELD and Rx Line as AMUXA). In this mode the polarity bit of the IDAC is controlled by csd_sense.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSX_DUAL_CNT</name>
              <description>Enable the use of two counters for MUTUAL cap sensing mode (CSX), do not use when MUTUAL_CAP=0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ONE</name>
                  <description>Use one counter for both phases (source and sink).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TWO</name>
                  <description>Use two counters, separate count for when csd_sense is high and when csd_sense is low.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_COUNT_SEL</name>
              <description>Select what to output  on the dsi_count bus.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CSD_RESULT</name>
                  <description>depending on the dsi_count_val_sel input either output  RESULT_VAL1.VALUE (0) or RESULT_VAL2.VALUE (1) on the dsi_count bus. Note that dsi_count_val_sel is not synchronized, i.e. it controls the mux combinatorially.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_RESULT</name>
                  <description>output ADC_RES.VIN_CNT on the dsi_count bus</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_SAMPLE_EN</name>
              <description>Enables the use of the dsi_sample_in input instead of the comparator output to strobe COUNTER.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_SYNC</name>
              <description>Enables double synchronizing of sample input from DSI (only relevant when DSI_SAMPLE_EN=1).</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SENSE_EN</name>
              <description>Enables the use of the dsi_sense_in input instead of the internally generated modulation signal to drive csd_sense and csd_shield signals.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LP_MODE</name>
              <description>Select the power mode for the CSD components (REFGEN, AMBUF, CSDCMP, HSCMP):
0: High Power mode
1: Low Power mode</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable of the CSDv2 IP.  Must be set to 1 for any CSDv2, ADC or IDAC operation to function.
When 0 all analog components will be off and all switches will be open.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPARE</name>
          <description>Spare MMIO</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SPARE</name>
              <description>Spare MMIO</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status Register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE</resetMask>
          <fields>
            <field>
              <name>CSD_SENSE</name>
              <description>Signal used to drive the Cs switches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HSCMP_OUT</name>
              <description>Output of reference buffer comparator used to charge up Cmod and/or Csh_tank (synchronized)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>C_LT_VREF</name>
                  <description>Vin &lt; Vref</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>C_GT_VREF</name>
                  <description>Vin &gt; Vref</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CSDCMP_OUT</name>
              <description>Output of main sensing comparator (synchronized)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_SEQ</name>
          <description>Current Sequencer status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70007</resetMask>
          <fields>
            <field>
              <name>SEQ_STATE</name>
              <description>CSD sequencer state</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_STATE</name>
              <description>ADC sequencer state (only relevant after SEQ_STATE has reached SAMPLE_NORM and ADC sequencer has started)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_CNTS</name>
          <description>Current status counts</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_CONV</name>
              <description>Current number of conversions remaining when in Sample_* states (note that in AutoZero* states the same down counter is reused to count the cycles)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STAT_HCNT</name>
          <description>Current count of the HSCMP counter</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CNT</name>
              <description>Current value of HSCMP counter</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_VAL1</name>
          <description>Result CSD/CSX accumulation counter value 1</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Accumulated counter value for this result. In case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt) this counter counts when csd_sense is high.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAD_CONVS</name>
              <description>Number of 'bad' conversion for which the CSD comparator did not trigger within the normal time window, either because Vref was not crossed at all, or if the Vref was already crossed before the window started. This counter is reset when the sequencer is started and will saturate at 255 when more than 255 conversions are bad.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_VAL2</name>
          <description>Result CSX accumulation counter value 2</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>Only used in case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt), this counter counts when csd_sense is low.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_RES</name>
          <description>ADC measurement</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC001FFFF</resetMask>
          <fields>
            <field>
              <name>VIN_CNT</name>
              <description>Count to source/sink Cref1 + Cref2 from Vin to Vrefhi.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HSCMP_POL</name>
              <description>Polarity used for IDACB for this last ADC result, 0= source, 1= sink</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_OVERFLOW</name>
              <description>This flag is set when the ADC counter overflows. This is an indication to the firmware that the IDACB current level is too low.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_ABORT</name>
              <description>This flag is set when the ADC sequencer was aborted before tripping HSCMP.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>CSD Interrupt Request Register</description>
          <addressOffset>0xF0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>A normal sample is complete</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Coarse initialization complete or Sample initialization complete (the latter is typically ignored)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>ADC Result ready</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>CSD Interrupt set register</description>
          <addressOffset>0xF4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>CSD Interrupt mask register</description>
          <addressOffset>0xF8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>CSD Interrupt masked register</description>
          <addressOffset>0xFC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x106</resetMask>
          <fields>
            <field>
              <name>SAMPLE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ADC_RES</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HSCMP</name>
          <description>High Speed Comparator configuration</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000011</resetMask>
          <fields>
            <field>
              <name>HSCMP_EN</name>
              <description>High Speed Comparator enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable comparator, output is zero</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HSCMP_INVERT</name>
              <description>Invert the HSCMP output before it is used to control switches and the CSD sequencer. This bit does not affect the ADC sequencer or the STATUS.HSCMP_OUT</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ_EN</name>
              <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AMBUF</name>
          <description>Reference Generator configuration</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>PWR_MODE</name>
              <description>Amux buffer power level</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable buffer</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORM</name>
                  <description>On, normal or low power level depending on CONFIG.LP_MODE.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HI</name>
                  <description>On, high or low power level depending on CONFIG.LP_MODE.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>REFGEN</name>
          <description>Reference Generator configuration</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x9F1F71</resetMask>
          <fields>
            <field>
              <name>REFGEN_EN</name>
              <description>Reference Generator Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable Reference Generator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BYPASS</name>
              <description>Bypass selected input reference unbuffered to Vrefhi</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VDDA_EN</name>
              <description>Close Vdda switch to top of resistor string (or Vrefhi?)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_EN</name>
              <description>Resistor string enable; 0= open switch on top of the resistor string (Vreflo=Vssa)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN</name>
              <description>Select resistor string tap for feedback, 0= minimum vout, 31= maximum vout = vrefhi -&gt; gain=1  (only works if the resistor string is enabled; RES_EN=1)</description>
              <bitRange>[12:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFLO_SEL</name>
              <description>Select resistor string tap for Vreflo/Vreflo_int, 0= minimum vout, 31= maximum vout = vrefhi (only works if the resistor string is enabled; RES_EN=1)</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VREFLO_INT</name>
              <description>Ouput the resistor string tap either to Vreflo (0) or Vreflo_int (1).</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSDCMP</name>
          <description>CSD Comparator configuration</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xB0000331</resetMask>
          <fields>
            <field>
              <name>CSDCMP_EN</name>
              <description>CSD Comparator Enable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Disable comparator, output is zero</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ON</name>
                  <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY_SEL</name>
              <description>Select which IDAC polarity to use to detect CSDCMP triggering</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDACA_POL</name>
                  <description>Use idaca_pol (firmware setting with CSX and optionally DSI mixed in) to determine the direction, this is the most common use-case, used for normal CSD and normal CSX</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDACB_POL</name>
                  <description>Use idacb_pol (firmware setting with optional DSI mixed in) to determine the direction, this is only used for normal CSD if IDACB is used i.s.o. IDACA (not common)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUAL_POL</name>
                  <description>Use the expression (csd_sense ? idaca_pol : idacb_pol)  to determine the direction, this is only useful for the CSX with DUAL_IDAC use-case</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_PHASE</name>
              <description>Select in what phase(s) the comparator is active, typically set to match the BAL_MODE of the used IDAC. Note, this also determines when a bad conversion is detected, namely at the beginning and end of the comparator active phase (also taking into account FILTER_DELAY and non-overlap).</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>Comparator is active from start of Phi2 and kept active into Phi1. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>Comparator is active during Phi1 only. Currently no known use-case.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>Comparator is active during Phi2 only. Intended usage: CSD Low EMI.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>Comparator is activated at the start of both Phi1 and Phi2 (non-overlap should be enabled). Intended usage: CSX, or Full-Wave.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CMP_MODE</name>
              <description>Select which signal to output on dsi_sample_out.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD mode: output the filtered sample signal on dsi_sample_out</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose mode: output the unfiltered sample unfiltered comparator output, either asynchronous or flopped.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FEEDBACK_MODE</name>
              <description>This bit controls whether the output directly from the comparator (csdcmp_out) or the flopped version (csdcmp_out_ff) is used. For CSD operation, the selected signal controls the IDAC(s), in GP mode the signal goes out on dsi_sample_out.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FLOP</name>
                  <description>Use feedback from sampling flip-flop (used in most modes).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP</name>
                  <description>Use feedback from comparator directly (used in single Cmod mutual cap sensing only)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AZ_EN</name>
              <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_RES</name>
          <description>Switch Resistance configuration</description>
          <addressOffset>0x1F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF00FF</resetMask>
          <fields>
            <field>
              <name>RES_HCAV</name>
              <description>Select resistance or low EMI (slow ramp) for the HCAV switch</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOWEMI</name>
                  <description>Low EMI (slow ramp: 3 switches closed by fixed delay line)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_HCAG</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_HCBV</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_HCBG</name>
              <description>Select resistance or low EMI for the corresponding switch</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RES_F1PM</name>
              <description>Select resistance for the corresponding  switch</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <description>Medium</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>High</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RES_F2PT</name>
              <description>Select resistance for the corresponding  switch</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_PERIOD</name>
          <description>Sense clock period</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC000000</resetValue>
          <resetMask>0xFF70FFF</resetMask>
          <fields>
            <field>
              <name>SENSE_DIV</name>
              <description>The length-1 of the Sense modulation 'clock' period in clk_csd cycles. For regular CSD one sense clock cycle = one conversion (=phi1+phi2) .
Note this is the base divider, clock dithering may change the actual period length.
Note that SENSE_DIV must be at least 1 and additionally also allow for one clk_hf of non overlap (if OVERLAP_HI1/2 is set) on both phases, i.e. if clk_csd=clk_hf then SENSE_DIV must be &gt;=3.
In addition the FILTER_DELAY needs to be added to the minimum allowed SENSE_DIV value.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_SIZE</name>
              <description>Selects the length of the LFSR which determines the LFSR repeat period. LFSR_BITS LSB of the LFSR are used  for the clock dithering variation on the base period (was PRS in CSDv1). Whenever the LFSR is used (non zero value in this field) the LFSR_CLEAR bit should also be set.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Don't use clock dithering (=spreadspectrum) (LFSR output value is zero)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6B</name>
                  <description>6-bit LFSR (G(x)=X^6  +X^4+X^3+    X+1, period= 63)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7B</name>
                  <description>7-bit LFSR (G(x)=X^7  +X^4+X^3+X^2+1, period= 127)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>9B</name>
                  <description>9-bit LFSR (G(x)=X^9  +X^4+X^3+    X+1, period= 511)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10B</name>
                  <description>10-bit LFSR (G(x)=X^10+X^4+X^3+    X+1, period= 1023)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8B</name>
                  <description>8-bit LFSR (G(x)=X^8+X^4+X^3+X^2+1, period= 255)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>12B</name>
                  <description>12-bit LFSR (G(x)=X^12+X^7+X^4+X^3+1, period= 4095)</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_SCALE</name>
              <description>Shift the LFSR output left by LSFR_SCALE bits before adding to SENSE_DIV. This dithering is disabled when SEL_LSFR_MSB is set.
The clock divider to be used = (SENSE_DIV+1) + (SEL_LSFR_MSB ? 0 : (LFSR_OUT&lt;&lt;LFSR_SCALE)).
Note that the clock divider including the dithering term must fit in 12 bits, otherwise the result is undefined.</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_CLEAR</name>
              <description>When set, forces the LFSR to it's initial state (all ones).  This bit is automatically cleared by hardware after the LFSR is cleared, which is at the next clk_csd positive edge. This bit should be set whenever this register is written and the LFSR is used.
Note that the LFSR will also get reset to all ones during the AutoZero_1/2 states.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_LFSR_MSB</name>
              <description>Use the MSB of configured LSFR size as csd_sense signal. Intended to be used only with bit 8 or 12-bit LFSR size for CSDv1 backward compatibility (PRS). When this bit is set then clock divider dithering is disabled and SENSE_WIDTH is disabled.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_BITS</name>
              <description>Selects the number of LSB bits to use from the LSFR to provide the clock dithering variation on the base period.
Caveat make sure that SENSE_DIV &gt; the maximum absolute range (e.g. for 4B  SENSE_DIV &gt; 8), otherwise results are undefined.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2B</name>
                  <description>use 2 bits: range = [-2,1]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>3B</name>
                  <description>use 3 bits: range = [-4,3]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4B</name>
                  <description>use 4 bits: range = [-8,7]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5B</name>
                  <description>use 5 bits: range = [-16,15] (default)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_DUTY</name>
          <description>Sense clock duty cycle</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xD0FFF</resetMask>
          <fields>
            <field>
              <name>SENSE_WIDTH</name>
              <description>Defines the length of the first phase of the sense clock in clk_csd cycles. 
A value of 0 disables this feature and the duty cycle of csd_sense will be 50 percent, which is equal to SENSE_WIDTH = (SENSE_DIV+1)/2, or when clock dithering is used that becomes [(SENSE_DIV+1) + (LFSR_OUT &lt;&lt; LSFR_SCALE)]/2.  At all times it must be assured that the phases are at least 2 clk_csd cycles (1 for non overlap, if used), if this rule is violated the result is undefined.
Note that this feature is not available when SEL_LFSR_MSB (PRS) is selected.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_POL</name>
              <description>Polarity of the sense clock
0 = start with low phase (typical for regular negative transfer CSD)
1 = start with high phase</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLAP_PHI1</name>
              <description>NonOverlap or not for Phi1 (csd_sense=0).
0 = Non-overlap for Phi1, the Phi1 signal is  csd_sense inverted except that the signal goes low 1 clk_sample before csd_sense goes high. Intended usage: new low EMI CSD/CSX with static GPIO.
1 = 'Overlap' (= not non-overlap) for Phi1, the Phi1 signal is  csd_sense inverted. Intended usage: legacy CSD with GPIO switching, the GPIO internal circuit ensures that the switches are non-overlapping.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERLAP_PHI2</name>
              <description>Same as OVERLAP_PHI1 but for Phi2 (csd_sense=1).</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_HS_P_SEL</name>
          <description>HSCMP Pos input switch Waveform selection</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11111111</resetMask>
          <fields>
            <field>
              <name>SW_HMPM</name>
              <description>Set HMPM switch
0: static open
1: static closed</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMPT</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMPS</name>
              <description>Set corresponding switch</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMMA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMCA</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HMRH</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_HS_N_SEL</name>
          <description>HSCMP Neg input switch Waveform selection</description>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77110000</resetMask>
          <fields>
            <field>
              <name>SW_HCCC</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCD</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCRH</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCRL</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SHIELD_SEL</name>
          <description>Shielding switches Waveform selection</description>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x117777</resetMask>
          <fields>
            <field>
              <name>SW_HCAV</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCAG</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCBV</name>
              <description>N/A</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCBG</name>
              <description>Select waveform for corresponding switch, using csd_shield as base</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCV</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_HCCG</name>
              <description>Set corresponding switch
If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_AMUXBUF_SEL</name>
          <description>Amuxbuffer switches Waveform selection</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11171110</resetMask>
          <fields>
            <field>
              <name>SW_IRBY</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRLB</name>
              <description>Set corresponding switch</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ICA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_ICB</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRLI</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRH</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IRL</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_BYP_SEL</name>
          <description>AMUXBUS bypass switches Waveform selection</description>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x111000</resetMask>
          <fields>
            <field>
              <name>SW_BYA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_BYB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_CBCC</name>
              <description>Set corresponding switch
If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_CMP_P_SEL</name>
          <description>CSDCMP Pos Switch Waveform selection</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1111777</resetMask>
          <fields>
            <field>
              <name>SW_SFPM</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFPT</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFPS</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFMA</name>
              <description>Set corresponding switch</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFCA</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SFCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_CMP_N_SEL</name>
          <description>CSDCMP Neg Switch Waveform selection</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77000000</resetMask>
          <fields>
            <field>
              <name>SW_SCRH</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SCRL</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_REFGEN_SEL</name>
          <description>Reference Generator Switch Waveform selection</description>
          <addressOffset>0x2A8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11110011</resetMask>
          <fields>
            <field>
              <name>SW_IAIB</name>
              <description>Set corresponding switch</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_IBCB</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGMB</name>
              <description>Set corresponding switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGRP</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGRE</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_SGR</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_FW_MOD_SEL</name>
          <description>Full Wave Cmod Switch Waveform selection</description>
          <addressOffset>0x2B0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11170701</resetMask>
          <fields>
            <field>
              <name>SW_F1PM</name>
              <description>Set corresponding switch</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F1MA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F1CA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1CC</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1CD</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C1F1</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_FW_TANK_SEL</name>
          <description>Full Wave Csh_tank Switch Waveform selection</description>
          <addressOffset>0x2B4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x11177710</resetMask>
          <fields>
            <field>
              <name>SW_F2PT</name>
              <description>Set corresponding switch</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2MA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2CA</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_F2CB</name>
              <description>Select waveform for corresponding switch</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2CC</name>
              <description>Set corresponding switch</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2CD</name>
              <description>Set corresponding switch</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_C2F2</name>
              <description>Set corresponding switch</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_DSI_SEL</name>
          <description>DSI output switch control Waveform selection</description>
          <addressOffset>0x2C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DSI_CSH_TANK</name>
              <description>Select waveform for dsi_csh_tank output signal
0: static open
1: static closed
2: phi1
3: phi2
4: phi1 &amp; HSCMP
5: phi2 &amp; HSCMP
6: HSCMP                       // ignores phi1/2
7: !sense                        // = phi1 but ignores OVERLAP_PHI1

8: phi1_delay              // phi1 delayed with shield delay
9: phi2_delay              // phi2 delayed with shield delay

10: !phi1
11: !phi2
12: !(phi1 &amp; HSCMP)
13: !(phi2 &amp; HSCMP)
14: !HSCMP                   // ignores phi1/2
15: sense                       // = phi2 but ignores OVERLAP_PHI2</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_CMOD</name>
              <description>Select waveform for dsi_cmod output signal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IO_SEL</name>
          <description>IO output control Waveform selection</description>
          <addressOffset>0x2D0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF0FF</resetMask>
          <fields>
            <field>
              <name>CSD_TX_OUT</name>
              <description>Select waveform for csd_tx_out output signal</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_OUT_EN</name>
              <description>Select waveform for csd_tx_out_en output signal</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_AMUXB_EN</name>
              <description>Select waveform for csd_tx_amuxb_en output signal</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_N_OUT</name>
              <description>Select waveform for csd_tx_n_out output signal</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_N_OUT_EN</name>
              <description>Select waveform for csd_tx_n_out_en output signal</description>
              <bitRange>[23:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSD_TX_N_AMUXA_EN</name>
              <description>Select waveform for csd_tx_n_amuxa_en output signal</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_TIME</name>
          <description>Sequencer Timing</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>AZ_TIME</name>
              <description>Define Auto-Zero time in csd_sense cycles -1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_INIT_CNT</name>
          <description>Sequencer Initial conversion and sample counts</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CONV_CNT</name>
              <description>Number of conversion per Initialization sample, if set to 0 the Sample_init state will be skipped.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_NORM_CNT</name>
          <description>Sequencer Normal conversion and sample counts</description>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CONV_CNT</name>
              <description>Number of conversion per sample, if set to 0 the Sample_norm state will be skipped.
Sample window size = SEQ_NORM_CNT.CONV_CNT * (SENSE_PERIOD.SENSE_DIV+1).
Note for CSDv1 Sample window size = PERIOD</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADC_CTL</name>
          <description>ADC Control</description>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>ADC_TIME</name>
              <description>ADC timing -1 in csd_sense clock cycles (actual time is ADC_TIME+1 cycles), either used to discharge Cref1&amp;2, or as the aperture to capture the input voltage on Cref1&amp;2</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_MODE</name>
              <description>Enable ADC measurement. When enabled the ADC sequencer will be started when the main sequencer goes to the SAMPLE_NORM state</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>No ADC measurement</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_CNT</name>
                  <description>Count time A to bring Cref1 + Cref2 up from Vssa to Vrefhi with IDACB</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_BY2_CNT</name>
                  <description>Count time B to bring Cref1 + Cref2 back up to Vrefhi with IDACB (after bringing them down for time A/2 cycles with IDACB sinking)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VIN_CNT</name>
                  <description>Determine HSCMP polarity and count time C to source/sink Cref1 + Cref2 from Vin to Vrefhi.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SEQ_START</name>
          <description>Sequencer start</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31B</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>Start the CSD sequencer. The sequencer will clear this bit when it is done. Depending on the mode the sequencer is done when a sample has been accumulated, when the high speed comparator trips or if the sequencer is aborted. When the ADC is enabled the ADC sequencer will start when the CSD sequencer reaches the Sample_norm state (only with the regular CSD scan mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEQ_MODE</name>
              <description>0 = regular CSD scan + optional ADC 
1 = coarse initialization, the Sequencer will go to the INIT_COARSE state.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>When a 1 is written the CSD and ADC sequencers will be aborted (if they are running) and the START bit will be cleared. This bit always read as 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_START_EN</name>
              <description>When this bit is set a positive edge on dsi_start will start the CSD sequencer and if enabled also the ADC sequencer.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ0_SKIP</name>
              <description>When set the AutoZero_0 state will be skipped</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AZ1_SKIP</name>
              <description>When set the AutoZero_1 state will be skipped</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDACA</name>
          <description>IDACA Configuration</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3EF0FFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>Current value setting for this IDAC (7 bits).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_DYN</name>
              <description>Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>STATIC</name>
                  <description>Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DYNAMIC</name>
                  <description>Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_MODE==CSD also mixed with the CSD configuration and operation. However in mutual cap mode with one IDAC (config.mutual_cap=1 &amp; config.csx_dual_idac=0) the polarity of the IDAC is controlled by csd_sense.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_SRC</name>
                  <description>Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_SNK</name>
                  <description>Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE</name>
                  <description>The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_INV</name>
                  <description>The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BAL_MODE</name>
              <description>Balancing mode: only applies to legs configured as CSD.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>enabled from start of Phi2 until disabled by CSDCMP. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>enabled from start of Phi1 and disabled by CSDCMP or at end of Phi1. Enables dual IDAC CSX or Full-Wave, one for sourcing and the other for sinking.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>enabled from start of Phi2 and disabled by CSDCMP or at end of Phi2. Intended usage: CSD Low EMI or  dual IDAC CSX or Full-Wave.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>enabled from start of both Phi1 and Phi2 and disabled by CSDCMP or at end of Phi1 or Phi2 (if non-overlap enabled). Intended usage: single IDAC CSX, or Full-Wave.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_MODE</name>
              <description>Controls the usage mode of LEG1 and the Polarity bit</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>General Purpose static mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose dynamic mode: LEG1 and POLARITY are controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>CSD static mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG1 is controlled by LEG1_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD dynamic mode: LEG1 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In thoses states LEG1 is controlled by LEG1_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). Polarity is controlled by the CSD configuration and operation. In addition leg1 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG2_MODE</name>
              <description>Controls the usage mode of LEG2</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>General Purpose static mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN).  No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>General Purpose dynamic mode: LEG2 is controlled by MMIO and optionally mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>CSD static mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, csd_sense and the CSD configuration. Polarity is controlled by the CSD configuration and operation. In addition leg2 enable and polarity can optionally be mixed with DSI (see DSI_CTRL_EN). No shunting is used, this saves power when off but also any on/off switching will take longer.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>CSD dynamic mode: LEG2 can only be on when the CSD Sequencer is in the Sample_init or Sample_norm state. In those states LEG2 is controlled by LEG2_EN, the CSD configuration, csd_sense and the flopped CSDCMP output (CSDCMP_OUT_FF). In addition leg2 enable can optionally be mixed with DSI (see DSI_CTRL_EN). Shunting is used, so on/off switching is faster, but power is wasted when the leg is disabled.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_CTRL_EN</name>
              <description>Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled).
0: no DSI control 
     IDACA_POLARITY = IDACA.POLARITY 
     IDACA_LEG1_EN =  IDACA.LEG1_EN 
     IDACA_LEG2_EN = IDACA.LEG2_EN   
1: Mix MMIO with DSI control
     IDACA_POLARITY = IDACA.POLARITY EXOR dsi_idaca_pol
     IDACA_LEG1_EN =  IDACA.LEG1_EN AND dsi_idaca_leg1_en 
     IDACA_LEG2_EN = IDACA.LEG2_EN AND dsi_idaca_leg2_en</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE</name>
              <description>IDAC multiplier</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDAC_LO</name>
                  <description>1 LSB =   37.5 nA</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_MED</name>
                  <description>1 LSB =  300 nA</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_HI</name>
                  <description>1 LSB = 2400 nA</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_EN</name>
              <description>output enable for leg 1 to CSDBUSA</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG2_EN</name>
              <description>output enable for leg 2 to CSDBUSA</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IDACB</name>
          <description>IDACB Configuration</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7EF0FFF</resetMask>
          <fields>
            <field>
              <name>VAL</name>
              <description>Current value setting for this IDAC (7 bits).</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POL_DYN</name>
              <description>Polarity is dynamic, this bit does not influence the logic in the SoftIP, it only goes to the HardIP.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>STATIC</name>
                  <description>Static polarity. Polarity is expected to be stable, so to save power this avoids the shunting of the unused polarity, at the expense of response time.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DYNAMIC</name>
                  <description>Dynamic polarity. Polarity is expected to change frequently (e.g. invert after every csd_sense phase), so to improve response time this keeps the shunt of the unused polarity on at the expense of power.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Selects the polarity of the IDAC (sensing operation). Normally the actual polarity depends on this bit, optionally mixed with DSI (see DSI_CTRL_EN) and if LEG1_EN==1 and LEG1_MODE==CSD also mixed with the CSD configuration and operation. In mutual cap mode however (see config.mutual_cap) the polarity of the IDAC is controlled by csd_sense. If LEG3_EN=1 (the other two legs must be off) then the ADC sequencer controls the IDACB polarity, optionally mixed with DSI.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_SRC</name>
                  <description>Normal: switch between Vssa and Cmod.  For non-CSD application, IDAC will source current.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_SNK</name>
                  <description>Inverted: switch between Vdda and Cmod. For non-CSD application, IDAC will sink current.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE</name>
                  <description>The polarity of the IDAC will follow the csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_INV</name>
                  <description>The polarity of the IDAC will follow the inverted csd_sense signal (POL_DYN bit should be set too). The intended usage is for CSX using a single IDAC.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BAL_MODE</name>
              <description>same as corresponding IDACA Balancing mode</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FULL</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI2</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PHI1_2</name>
                  <description>same as corresponding IDACA Balancing mode</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_MODE</name>
              <description>Controls the usage mode of LEG1 and the Polarity bit</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>same as corresponding IDACA.LEG1_MODE</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG2_MODE</name>
              <description>Controls the usage mode of LEG2</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GP_STATIC</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GP</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD_STATIC</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CSD</name>
                  <description>same as corresponding IDACA.LEG2_MODE</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSI_CTRL_EN</name>
              <description>Mix DSI inputs with MMIO controls or not (before getting mixed with CSD controls if enabled)
0: no DSI control
     IDACB_POLARITY = IDACB.POLARITY 
     IDACB_LEG1_EN =  IDACB.LEG1_EN 
     IDACB_LEG2_EN = IDACB.LEG2_EN   
     IDACB_LEG3_EN = IDACB.LEG3_EN   
1: Mix MMIO with DSI control
     IDACB_POLARITY = IDACB.POLARITY EXOR dsi_idacb_pol
     IDACB_LEG1_EN =  IDACB.LEG1_EN AND dsi_idacb_leg1_en 
     IDACB_LEG2_EN = IDACB.LEG2_EN AND dsi_idacb_leg2_en  
     IDACB_LEG3_EN = IDACB.LEG3_EN AND dsi_idacb_leg3_en</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE</name>
              <description>IDAC multiplier</description>
              <bitRange>[23:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDAC_LO</name>
                  <description>1 LSB =   37.5 nA</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_MED</name>
                  <description>1 LSB =  300 nA</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_HI</name>
                  <description>1 LSB = 2400 nA</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEG1_EN</name>
              <description>output enable for leg 1 to CSDBUSB or CSDBUSA</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG2_EN</name>
              <description>output enable for leg 2 to CSDBUSB or CSDBUSA</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LEG3_EN</name>
              <description>output enable for leg3 to CSDBUSC, only allowed when RANGE = IDAC_LO. When this bit is set both other legs should be off.
Note that leg3 can only be used for ADC mode, not GP mode. Which means that leg3 can only be on when the ADC Sequencer is in the ADC_measure or Calib_measure state. In those states  leg3 is controlled by the ADC configuration and the HSCMP output. In addition this leg3 enable bit can optionally be mixed with DSI (see DSI_CTRL_EN).
When LEG3_EN=1 also the IDACB polarity is controlled by the ADC sequencer.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM0</name>
      <description>Timer/Counter/PWM</description>
      <headerStructName>TCPWM</headerStructName>
      <baseAddress>0x40380000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
- the counter's line outputs ('line_out' and 'line_compl_out').
In multi-core environments, use the CTRL_SET/CTRL_CLR registers to avoid race-conditions on read-modify-write attempts to this register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_CLR</name>
          <description>TCPWM control clear register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Alias of CTRL that only allows disabling of counters. A write access:
'0': Does nothing.
'1': Clears respective COUNTER_ENABLED field.

A read access returns CTRL.COUNTER_ENABLED.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_SET</name>
          <description>TCPWM control set register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Alias of CTRL that only allows enabling of counters. A write access:
'0': Does nothing.
'1': Sets respective COUNTER_ENABLED field.

A read access returns CTRL.COUNTER_ENABLED.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_CAPTURE</name>
          <description>TCPWM capture command register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RELOAD</name>
          <description>TCPWM reload command register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_STOP</name>
          <description>TCPWM stop command register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_START</name>
          <description>TCPWM start command register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>24</dim>
          <dimIncrement>64</dimIncrement>
          <name>CNT[%s]</name>
          <description>Timer/Counter/PWM Counter Module</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending switch event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine the dead time: amount of dead time cycles in the counter clock domain. In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <description>Count up (to PERIOD). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. A terminal count event is generated when the counter changes from a state in which COUNTER equals PERIOD.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <description>Count down (to '0'). An underflow event is generated when  the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter changes from a state in which COUNTER equals PERIOD. An underflow event is generated when the counter changes from a state in which COUNTER equals '0'. A terminal count event is generated when the counter changes from a state in which COUNTER equals '0' AND when the counter changes from a state in which COUNTER equals PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUADRATURE_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <description>X1 encoding (QUAD mode)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <description>X2 encoding (QUAD mode)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <description>X4 encoding (QUAD mode)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <description>Timer mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <description>Capture mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <description>Quadrature encoding mode</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>Pulse width modulation (PWM) mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <description>PWM with deadtime insertion mode</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <description>Pseudo random pulse width modulation</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion. In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit / 32-bit counter value. It is advised to not write to this field when the counter is running.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFFFFFF</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is always '0' and input trigger is always '1'. In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this is the index or revolution pulse. In this mode, it will update the counter with 0x8000 (counter midpoint).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3F</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC register should be set to '0'. For a 100 percent duty cycle, the counter CC register should be set to larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="TCPWM0">
      <name>TCPWM1</name>
      <baseAddress>0x40390000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LCD0</name>
      <description>LCD Controller Block</description>
      <headerStructName>LCD</headerStructName>
      <baseAddress>0x403B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1F0F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LCD controller peripheral is 0xF0F0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIVIDER</name>
          <description>LCD Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBFR_DIV</name>
              <description>Input clock frequency divide value, to generate the 1/4 sub-frame period. The sub-frame period is  4*(SUBFR_DIV+1) cycles long.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_DIV</name>
              <description>Length of the dead time period in cycles.  When set to  zero, no dead time period exists.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONTROL</name>
          <description>LCD Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000F7F</resetMask>
          <fields>
            <field>
              <name>LS_EN</name>
              <description>Low speed (LS) generator enable
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_EN</name>
              <description>High speed (HS) generator enable
1: enable
0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD_MODE</name>
              <description>HS/LS Mode selection</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LS</name>
                  <description>Select Low Speed (32kHz) Generator (Works in Active, Sleep and DeepSleep power modes).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HS</name>
                  <description>Select High Speed (system clock) Generator (Works in Active and Sleep power modes only).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TYPE</name>
              <description>LCD driving waveform type configuration.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TYPE_A</name>
                  <description>Type A - Each frame addresses each COM pin only once with a balanced (DC=0) waveform.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TYPE_B</name>
                  <description>Type B - Each frame addresses each COM pin twice in sequence with a positive and negative waveform that together are balanced (DC=0).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OP_MODE</name>
              <description>Driving mode configuration</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <description>PWM Mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CORRELATION</name>
                  <description>Digital Correlation Mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIAS</name>
              <description>PWM bias selection</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HALF</name>
                  <description>1/2 Bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD</name>
                  <description>1/3 Bias</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOURTH</name>
                  <description>1/4 Bias (not supported by LS generator)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIFTH</name>
                  <description>1/5 Bias (not supported by LS generator)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COM_NUM</name>
              <description>The number of COM connections minus 2. So:
0: 2 COM's
1: 3 COM's
...
13: 15 COM's
14: 16 COM's
15: undefined</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LS_EN_STAT</name>
              <description>LS enable status bit.  This bit is a copy of LS_EN that is synchronized to the low speed clock domain and back to the system clock domain. Firmware can use this bit to observe whether LS_EN has taken effect in the low speed clock domain.  Firmware should never change the configuration for the LS generator without ensuring this bit is 0.
The following procedure should be followed to disable the LS generator:
1. If LS_EN=0 we are done.  Exit the procedure.
2. Check that LS_EN_STAT=1.  If not, wait until it is. This will catch the case of a recent enable (LS_EN=1) that has not taken effect yet.
3. Set LS_EN=0.
4. Wait until LS_EN_STAT=0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA0[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA1[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA2[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA3[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USBFS0</name>
      <description>USB Host and Device Controller</description>
      <headerStructName>USBFS</headerStructName>
      <baseAddress>0x403F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>USBDEV</name>
          <description>USB Device</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>EP0_DR[%s]</name>
            <description>Control End point EP0 Data Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_BYTE</name>
                <description>This register is shared for both transmit and receive. The count in the EP0_CNT register determines the number of bytes received or to be transferred.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CR0</name>
            <description>USB control 0 Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DEVICE_ADDRESS</name>
                <description>These bits specify the USB device address to which the SIE will respond. This address must be set by firmware and is specified by the USB Host with a SET ADDRESS command during USB enumeration. This value must be programmed by firmware when assigned during enumeration. It is not set automatically by the hardware.
If USB bus reset is detected, these bits are initialized.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USB_ENABLE</name>
                <description>This bit enables the device to respond to USB traffic.
If USB bus reset is detected, this bit is cleared.
Note:
When USB PHY is GPIO mode(USBIO_CR1.IOMODE=0), USB bus reset is detected. Therefore, when USB PHY is GPIO mode, this bit is cleared even if this bit is set to 1. If this bit is set to 1, write this bit upon USB bus reset interrupt, and do not write to this bit during initialization steps.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CR1</name>
            <description>USB control 1 Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>REG_ENABLE</name>
                <description>This bit controls the operation of the internal USB regulator. For applications with supply voltages in the 5V range this bit is set high to enable the internal regulator. For device supply voltage in the 3.3V range this bit is cleared to connect the transceiver directly to the supply.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_LOCK</name>
                <description>This bit is set to turn on the automatic frequency locking of the internal oscillator to USB traffic.  Unless an external clock is being provided this bit should remain set for proper USB operation.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_ACTIVITY</name>
                <description>The Bus Activity bit is a stickybit that detects any non-idle USB event that has occurred on the USB bus. Once set to High by the SIE to indicate the bus activity this bit retains its logical High
value until firmware clears it.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_3</name>
                <description>N/A</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP_INT_EN</name>
            <description>USB SIE Data Endpoints Interrupt Enable Register</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR_EN</name>
                <description>Enables interrupt for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR_EN</name>
                <description>Enables interrupt for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR_EN</name>
                <description>Enables interrupt for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR_EN</name>
                <description>Enables interrupt for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR_EN</name>
                <description>Enables interrupt for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR_EN</name>
                <description>Enables interrupt for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR_EN</name>
                <description>Enables interrupt for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR_EN</name>
                <description>Enables interrupt for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP_INT_SR</name>
            <description>USB SIE Data Endpoint Interrupt Status</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR</name>
                <description>Interrupt status for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>Interrupt status for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>Interrupt status for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>Interrupt status for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>Interrupt status for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>Interrupt status for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>Interrupt status for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>Interrupt status for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP1_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR0</name>
            <description>USBIO Control 0 Register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE0</resetMask>
            <fields>
              <field>
                <name>RD</name>
                <description>Received Data. This read only bit gives the state of the USB differential receiver when IOMODE bit is '0'  and USB doesn't transmit. This bit is valid if USB Device.
If D+=D- (SE0), this value is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIFF_LOW</name>
                    <description>D+ &lt; D- (K state)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIFF_HIGH</name>
                    <description>D+ &gt; D- (J state)</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TD</name>
                <description>Transmit Data. Transmit a USB J or K state on the USB bus. No effect if TEN=0 or TSE0=1.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DIFF_K</name>
                    <description>Force USB K state (D+ is low D- is high).</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DIFF_J</name>
                    <description>Force USB J state (D+ is high D- is low).</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TSE0</name>
                <description>Transmit Single-Ended Zero. SE0: both D+ and D- low. No effect if TEN=0.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TEN</name>
                <description>USB Transmit Enable. This is used to manually transmit on the D+ and D- pins. Normally this bit should be cleared to allow the internal SIE to drive the pins. The most common reason for manually
transmitting is to force a resume state on the bus.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR2</name>
            <description>USBIO control 2 Register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RSVD_5_0</name>
                <description>N/A</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TEST_PKT</name>
                <description>This bit enables the device to transmit a packet in response to an internally generated IN packet.  When set, one packet will be generated.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_7</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CR1</name>
            <description>USBIO control 1 Register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x20</resetValue>
            <resetMask>0x20</resetMask>
            <fields>
              <field>
                <name>DMO</name>
                <description>This read only bit gives the state of the D- pin when IOMODE bit is '0'  and USB doesn't transmit.
This bit is '0' when USB transmits SE0, and this bit is '1' when USB transmits other than SE0.
This bit is valid if USB Device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DPO</name>
                <description>This read only bit gives the state of the D+ pin when IOMODE bit is '0' and USB doesn't transmit.
This bit displays the output value of D+ pin when USB transmits SE0 or data.
This bit is valid if USB Device.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_2</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IOMODE</name>
                <description>This bit allows the D+ and D- pins to be configured for either USB mode or bit-banged modes. If this bit is set the DMI and DPI bits are used to drive the D- and D+ pins.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DYN_RECONFIG</name>
            <description>USB Dynamic reconfiguration register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DYN_CONFIG_EN</name>
                <description>This bit is used to enable the dynamic re-configuration for the selected EP. If set to 1, indicates the reconfiguration required for selected EP.
Use 0 for EP1, 1 for EP2, etc.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DYN_RECONFIG_EPNO</name>
                <description>These bits indicates the EP number for which reconfiguration is required when dyn_config_en bit is set to 1.</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DYN_RECONFIG_RDY_STS</name>
                <description>This bit indicates the ready status for the dynamic reconfiguration, when set to 1, indicates the block is ready for reconfiguration.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF0</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER</name>
                <description>It has the lower 8 bits [7:0] of the SOF frame number.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF1</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER_MSB</name>
                <description>It has the upper 3 bits [10:8] of the SOF frame number.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x74</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP2_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR0</name>
            <description>Oscillator lock data register 0</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER</name>
                <description>These bits return the lower 8 bits of the oscillator locking circuits adder output.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR1</name>
            <description>Oscillator lock data register 1</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER_MSB</name>
                <description>These bits return the upper 7 bits of the oscillator locking circuits adder output.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP0_CR</name>
            <description>Endpoint0 control Register</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OUT_RCVD</name>
                <description>When set this bit indicates a valid OUT packet has been received and ACKed. This bit is updated to '1' after the last received packet in an OUT transaction. When clear this bit indicates no OUT received. It is cleared by any writes to the register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IN_RCVD</name>
                <description>When set this bit indicates a valid IN packet has been received. This bit is updated to '1' after the host acknowledges an IN data packet. When clear this bit indicates either no IN has been received or that the host did not acknowledge the IN data by sending ACK handshake. It is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SETUP_RCVD</name>
                <description>When set this bit indicates a valid SETUP packet was received and ACKed. This bit is forced HIGH from the start of the data packet phase of the SETUP transaction until the start of the ACK packet returned by the SIE. The CPU is prevented from clearing this bit during this interval. After this interval the bit will remain set until cleared by firmware. While this bit is set to '1' the CPU cannot write to the EP0_DRx registers. This prevents firmware from overwriting an incoming SETUP transaction before firmware has a chance to read the SETUP data. This bit is cleared by any non-locked writes to the register.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP0_CNT</name>
            <description>Endpoint0 count Register</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xCF</resetMask>
            <fields>
              <field>
                <name>BYTE_COUNT</name>
                <description>These bits indicate the number of data bytes in a transaction. For IN transactions firmware loads the count with the number of bytes to be transmitted to the host from the endpoint FIFO. Valid values are 0 to 8. For OUT or SETUP transactions the count is updated by hardware to the number of data bytes received plus two for the CRC bytes. Valid values are 2 to 10.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT/SETUP transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xB0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xB4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP3_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0xB8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0xF4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP4_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0xF8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x130</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x134</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP5_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x138</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x170</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x174</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP6_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x178</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1B4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP7_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CNT0</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC7</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT_MSB</name>
                <description>These bits are the 3 MSb bits of an 11-bit counter. The LSb are the Data Count[7:0] bits of the CNT1 register. Refer to the CNT1 register for more information.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_VALID</name>
                <description>This bit is used for OUT transactions only and is read only. It is cleared to '0' if CRC bit stuffing errors or PID errors occur. This bit does not update for some endpoint mode settings.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DATA_ERROR</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DATA_VALID</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DATA_TOGGLE</name>
                <description>This bit selects the DATA packet's toggle state. For IN transactions firmware must set this bit to the expected state. For OUT transactions the hardware sets this bit to the state of the received Data Toggle bit.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CNT1</name>
            <description>Non-control endpoint count register</description>
            <addressOffset>0x1F4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA_COUNT</name>
                <description>These bits are the 8 LSb of a 11-bit counter.  The 3 MSb bits are in the CNT0 register. The 11-bit count indicates the number of data bytes in a transaction.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIE_EP8_CR0</name>
            <description>Non-control endpoint's control Register</description>
            <addressOffset>0x1F8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>The mode controls how the USB SIE responds to traffic and how the USB SIE changes the mode of that endpoint as a result of host packets to the endpoint.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Ignore all USB traffic to this endpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_INOUT</name>
                    <description>SETUP: Accept
IN: NAK
OUT:  NAK</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_OUT_ONLY</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  ACK 0B tokens, NAK others</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL_INOUT</name>
                    <description>SETUP: Accept
IN: STALL
OUT:  STALL</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept Isochronous OUT token</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STATUS_IN_ONLY</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Stall</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>SETUP: Ignore
IN: Accept Isochronous IN token
OUT:  Ignore</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  NAK</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT</name>
                    <description>SETUP: Ignore
IN: Ignore
OUT:  Accept data and ACK if STALL=0, STALL otherwise.  
Change to MODE=8 after one succesfull OUT token.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_OUT_STATUS_IN</name>
                    <description>SETUP: Accept
IN: Respond with 0B data
OUT:  Accept data</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK_IN</name>
                    <description>SETUP: Ignore
IN: NAK
OUT:  Ignore</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN</name>
                    <description>SETUP: Ignore
IN: Respond to IN with data if STALL=0, STALL otherwise
OUT:  Ignore</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACK_IN_STATUS_OUT</name>
                    <description>SETUP: Accept
IN: Respond to IN with data
OUT:  ACK 0B tokens, NAK others</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACKED_TXN</name>
                <description>The ACK'd transaction bit is set whenever the SIE engages in a transaction to the register's endpoint that completes with an ACK packet. This bit is cleared by any writes to the register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACKED_NO</name>
                    <description>No ACK'd transactions since bit was last cleared.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACKED_YES</name>
                    <description>Indicates a transaction ended with an ACK.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>NAK_INT_EN</name>
                <description>When set this bit causes an endpoint interrupt to be generated even when a transfer completes with a NAK.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_IN_TXN</name>
                <description>The Error in transaction bit is set whenever an error is detected. For an IN transaction, this indicates a no response from HOST scenario. For an OUT transaction, this represents an RxErr (PID
error/ CRC error/ bit-stuff error scenario). This bit is cleared by any writes to the register.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STALL</name>
                <description>When this bit is set the SIE stalls an OUT packet if the Mode bits are set to ACK-OUT. The SIE stalls an IN packet if the mode bits are set to ACK-IN. This bit must be clear for all other modes.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x200</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x204</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP1_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x208</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x214</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x21C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x220</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUF_SIZE</name>
            <description>Dedicated Endpoint Buffer Size Register  *1</description>
            <addressOffset>0x230</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>IN_BUF</name>
                <description>Buffer size for IN Endpoints.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_BUF</name>
                <description>Buffer size for OUT Endpoints.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP_ACTIVE</name>
            <description>Endpoint Active Indication Register  *1</description>
            <addressOffset>0x238</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_ACT</name>
                <description>Indicates that Endpoint is currently active.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EP_TYPE</name>
            <description>Endpoint Type (IN/OUT) Indication  *1</description>
            <addressOffset>0x23C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP2_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP3_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP4_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP5_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP6_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP7_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP8_TYP</name>
                <description>Endpoint Type Indication.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>EP_IN</name>
                    <description>IN outpoint</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EP_OUT</name>
                    <description>OUT outpoint</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x240</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x244</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP2_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x248</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x250</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x254</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x258</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x25C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x260</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_CFG</name>
            <description>Arbiter Configuration Register  *1</description>
            <addressOffset>0x270</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF0</resetMask>
            <fields>
              <field>
                <name>AUTO_MEM</name>
                <description>Enables Auto Memory Configuration.  Manual memory configuration by default.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_CFG</name>
                <description>DMA Access Configuration.</description>
                <bitRange>[6:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DMA_NONE</name>
                    <description>No DMA</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DMA_MANUAL</name>
                    <description>Manual DMA</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DMA_AUTO</name>
                    <description>Auto DMA</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CFG_CMP</name>
                <description>Register Configuration Complete Indication. Posedge is detected on this bit. Hence a 0 to 1 transition is required.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USB_CLK_EN</name>
            <description>USB Block Clock Enable Register</description>
            <addressOffset>0x274</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CSR_CLK_EN</name>
                <description>Clock Enable for Core Logic clocked by AHB bus clock</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_INT_EN</name>
            <description>Arbiter Interrupt Enable  *1</description>
            <addressOffset>0x278</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR_EN</name>
                <description>Enables interrupt for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_INTR_EN</name>
                <description>Enables interrupt for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_INTR_EN</name>
                <description>Enables interrupt for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_INTR_EN</name>
                <description>Enables interrupt for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_INTR_EN</name>
                <description>Enables interrupt for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_INTR_EN</name>
                <description>Enables interrupt for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_INTR_EN</name>
                <description>Enables interrupt for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_INTR_EN</name>
                <description>Enables interrupt for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_INT_SR</name>
            <description>Arbiter Interrupt Status  *1</description>
            <addressOffset>0x27C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_INTR</name>
                <description>Interrupt status for EP1</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>Interrupt status for EP2</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>Interrupt status for EP3</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>Interrupt status for EP4</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>Interrupt status for EP5</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>Interrupt status for EP6</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>Interrupt status for EP7</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>Interrupt status for EP8</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x280</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x284</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP3_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x288</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x290</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x294</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x298</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x29C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x2A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA</name>
            <description>Common Area Write Address  *1</description>
            <addressOffset>0x2B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>CWA</name>
                <description>Write Address for Common Area</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA_MSB</name>
            <description>Endpoint Read Address value  *1</description>
            <addressOffset>0x2B4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>CWA_MSB</name>
                <description>Write Address for Common Area</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x2C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x2C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP4_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x2C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x2D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x2D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x2D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x2DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x2E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x2F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DMA_THS</name>
                <description>DMA Threshold count</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES_MSB</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x2F4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>DMA_THS_MSB</name>
                <description>DMA Threshold count</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x300</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x304</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP5_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x308</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x310</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x314</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x318</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x31C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x320</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUS_RST_CNT</name>
            <description>Bus Reset Count Register</description>
            <addressOffset>0x330</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xA</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>BUS_RST_CNT</name>
                <description>Bus Reset Count Length</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x340</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x344</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP6_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x348</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x350</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x354</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x358</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x35C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x360</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x380</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x384</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP7_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x388</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x390</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x394</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x398</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x39C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x3A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_CFG</name>
            <description>Endpoint Configuration Register  *1</description>
            <addressOffset>0x3C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>IN_DATA_RDY</name>
                <description>Indication that Endpoint Packet Data is Ready in Main memory</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_REQ</name>
                <description>Manual DMA Request for a particular (1 to 8) endpoint; changing this field from 0 to 1 causes a DMA request to be generated.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC_BYPASS</name>
                <description>Configuration Setting to prevent CRC bytes from being written to memory and being read by firmware</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>CRC_NORMAL</name>
                    <description>No CRC bypass; CRC bytes will be written to memory and Termin will be generated for the CRC byte/s</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CRC_BYPASS</name>
                    <description>CRC Bypass Set; CRC bytes will not be written into memory and Termin will be generated for the last data byte/s</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RESET_PTR</name>
                <description>Configuration Setting to Reset the RA and WA Pointers to their start values at the End of Packet transaction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RESET_KRYPTON</name>
                    <description>Do not Reset Pointer; Krypton Backward compatibility mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET_NORMAL</name>
                    <description>Reset Pointer; recommended value for reduction of CPU Configuration Writes.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_INT_EN</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x3C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL_EN</name>
                <description>IN Endpoint Local Buffer Full Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT_EN</name>
                <description>Endpoint DMA Grant Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER_EN</name>
                <description>Endpoint Buffer Overflow Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER_EN</name>
                <description>Endpoint Buffer Underflow Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INT_EN</name>
                <description>Endpoint Error in Transaction Interrupt Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN_EN</name>
                <description>Endpoint DMA Terminated Enable</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_EP8_SR</name>
            <description>Endpoint Interrupt Enable Register  *1</description>
            <addressOffset>0x3C8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x2F</resetMask>
            <fields>
              <field>
                <name>IN_BUF_FULL</name>
                <description>IN Endpoint Local Buffer Full Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_GNT</name>
                <description>Endpoint DMA Grant Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_OVER</name>
                <description>Endpoint Buffer Overflow Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_UNDER</name>
                <description>Endpoint Buffer Underflow Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_TERMIN</name>
                <description>Endpoint DMA Terminated Interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x3D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>WA</name>
                <description>Write Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA_MSB</name>
            <description>Endpoint Write Address value  *1, *2</description>
            <addressOffset>0x3D4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WA_MSB</name>
                <description>Write Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x3D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RA</name>
                <description>Read Address for EP</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA_MSB</name>
            <description>Endpoint Read Address value  *1, *2</description>
            <addressOffset>0x3DC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>RA_MSB</name>
                <description>Read Address for EP</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_DR</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x3E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>512</dim>
            <dimIncrement>4</dimIncrement>
            <name>MEM_DATA[%s]</name>
            <description>DATA</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SOF16</name>
            <description>Start Of Frame Register</description>
            <addressOffset>0x1060</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>FRAME_NUMBER16</name>
                <description>The frame number (11b)</description>
                <bitRange>[10:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>OSCLK_DR16</name>
            <description>Oscillator lock data register</description>
            <addressOffset>0x1080</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDER16</name>
                <description>These bits return the oscillator locking circuits adder output.</description>
                <bitRange>[14:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1210</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1218</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW1_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1220</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1250</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1258</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW2_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1260</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1290</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1298</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW3_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x12A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CWA16</name>
            <description>Common Area Write Address</description>
            <addressOffset>0x12B0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>CWA16</name>
                <description>Write Address for Common Area</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x12D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x12D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW4_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x12E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DMA_THRES16</name>
            <description>DMA Burst / Threshold Configuration</description>
            <addressOffset>0x12F0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DMA_THS16</name>
                <description>DMA Threshold count</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1310</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1318</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW5_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1320</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1350</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1358</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW6_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x1360</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x1390</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x1398</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW7_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x13A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_WA16</name>
            <description>Endpoint Write Address value  *3</description>
            <addressOffset>0x13D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>WA16</name>
                <description>Write Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_RA16</name>
            <description>Endpoint Read Address value  *3</description>
            <addressOffset>0x13D8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>RA16</name>
                <description>Read Address for EP</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARB_RW8_DR16</name>
            <description>Endpoint Data Register</description>
            <addressOffset>0x13E0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DR16</name>
                <description>Data Register for EP ; This register is linked to the memory, hence reset value is undefined</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>USBLPM</name>
          <description>USB Device LPM and PHY Test</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <name>POWER_CTL</name>
            <description>Power Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x303F0004</resetMask>
            <fields>
              <field>
                <name>SUSPEND</name>
                <description>Put PHY into Suspend mode.  If the PHY is enabled, this bit MUST be set before entering a low power mode (DeepSleep).
Note:
- This bit is invalid if the HOST bit of the Host Control 0 Register (HOST_CTL0) is '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_UP_EN</name>
                <description>Enables the pull up on the DP.
'0' : Disable.
'1' : Enable.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_BIG</name>
                <description>Select the resister value if POWER_CTL.DP_EN='1'. This bit is valid in GPIO.
'0' : The resister value is from 900 to1575Ohmpull up on the DP.
'1' : The resister value is from 1425 to 3090Ohmpull up on the DP</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DP_DOWN_EN</name>
                <description>Enables the ~15k pull down on the DP.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_UP_EN</name>
                <description>Enables the pull up on the DM. The bit is valid in GPIO. The pull up resistor is disabled in not GPIO.
'0' : Disable.
'1' : Enable.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_BIG</name>
                <description>Select the resister value if POWER_CTL.DM_EN='1'. This bit is valid in GPIO.
'0' : The resister value is from 900 to1575Ohmpull up on the DM.
'1' : The resister value is from 1425 to 3090Ohmpull up on the DM</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_DOWN_EN</name>
                <description>Enables the ~15k pull down on the DP.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_DPO</name>
                <description>Enables the single ended receiver on D+.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE_DMO</name>
                <description>Enables the signle ended receiver on D-.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>USBIO_CTL</name>
            <description>USB IO Control Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>DM_P</name>
                <description>The GPIO Drive Mode for DP IO pad. This field only applies if USBIO_CR1.IOMODE =1. Data comes from the corresponding GPIO.DR register.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0: Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.

Other values, not supported.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM_M</name>
                <description>The GPIO Drive Mode for DM IO pad.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FLOW_CTL</name>
            <description>Flow Control Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>EP1_ERR_RESP</name>
                <description>End Point 1 error response
0: do nothing (backward compatibility mode)
1: if this is an IN EP and an underflow occurs then cause a CRC error, if this is an OUT EP and an overflow occurs then send a NAK</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_ERR_RESP</name>
                <description>End Point 2 error response</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_ERR_RESP</name>
                <description>End Point 3 error response</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_ERR_RESP</name>
                <description>End Point 4 error response</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_ERR_RESP</name>
                <description>End Point 5 error response</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_ERR_RESP</name>
                <description>End Point 6 error response</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_ERR_RESP</name>
                <description>End Point 7 error response</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_ERR_RESP</name>
                <description>End Point 8 error response</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPM_CTL</name>
            <description>LPM Control Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17</resetMask>
            <fields>
              <field>
                <name>LPM_EN</name>
                <description>LPM enable
0: Disabled, LPM token will not get a response (backward compatibility mode) 
1: Enable, LPM token will get a handshake response (ACK, STALL, NYET or NAK)
       A STALL will be sent if the bLinkState is not 0001b
       A NYET, NAK or ACK response will be sent depending on the NYET_EN and LPM_ACK_RESP bits below</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_ACK_RESP</name>
                <description>LPM ACK response enable (if LPM_EN=1), to allow firmware to refuse a low power request 
0: a LPM token will get a NYET or NAK (depending on NYET_EN bit below) response and the device will NOT go to a low power mode  
1: a LPM token will get an ACK response and the device will go to the requested low power mode</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NYET_EN</name>
                <description>Allow firmware to choose which response to use for an LPM token (LPM_EN=1) when the device is NOT ready to go to the requested low power mode (LPM_ACK_RESP=0).
0: a LPM token will get an NAK response (indicating a CRC error),  the host is expected to repeat the LPM token.
1: a LPM token will get a NYET response</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_RESP</name>
                <description>Enable a STALL response for all undefined SubPIDs, i.e. other than LPM (0011b). If not enabled then there will be no response (Error) for the undefined SubPIDs.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LPM_STAT</name>
            <description>LPM Status register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>LPM_BESL</name>
                <description>Best Effort Service Latency
This value should match either the Baseline (DeepSleep) or Deep (Hibernate) BESL in the BOS descriptor.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_REMOTEWAKE</name>
                <description>0: Device is prohibited from initiating a remote wake
1: Device is allow to wake the host</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Status</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>Interrupt status for USB SOF</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>Interrupt status for BUS RESET</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>Interrupt status for EP0</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>Interrupt status for LPM  (Link Power Management, L1 entry)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Interrupt status for Resume</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_SET</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Set</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR_SET</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_MASK</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Mask</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_INTR_MASK</name>
                <description>Set to 1 to enable interrupt corresponding to interrupt request register</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SIE_MASKED</name>
            <description>USB SOF, BUS RESET and EP0 Interrupt Masked</description>
            <addressOffset>0x2C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR_MASKED</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_LVL_SEL</name>
            <description>Select interrupt level for each interrupt source</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFC3FF</resetMask>
            <fields>
              <field>
                <name>SOF_LVL_SEL</name>
                <description>USB SOF Interrupt level select</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>illegal</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUS_RESET_LVL_SEL</name>
                <description>BUS RESET Interrupt level select</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP0_LVL_SEL</name>
                <description>EP0 Interrupt level select</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LPM_LVL_SEL</name>
                <description>LPM Interrupt level select</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESUME_LVL_SEL</name>
                <description>Resume Interrupt level select</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ARB_EP_LVL_SEL</name>
                <description>Arbiter Endpoint Interrupt level select</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1_LVL_SEL</name>
                <description>EP1 Interrupt level select</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_LVL_SEL</name>
                <description>EP2 Interrupt level select</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP3_LVL_SEL</name>
                <description>EP3 Interrupt level select</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP4_LVL_SEL</name>
                <description>EP4 Interrupt level select</description>
                <bitRange>[23:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP5_LVL_SEL</name>
                <description>EP5 Interrupt level select</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP6_LVL_SEL</name>
                <description>EP6 Interrupt level select</description>
                <bitRange>[27:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP7_LVL_SEL</name>
                <description>EP7 Interrupt level select</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP8_LVL_SEL</name>
                <description>EP8 Interrupt level select</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_HI</name>
            <description>High priority interrupt Cause register</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_MED</name>
            <description>Medium priority interrupt Cause register</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CAUSE_LO</name>
            <description>Low priority interrupt Cause register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF9F</resetMask>
            <fields>
              <field>
                <name>SOF_INTR</name>
                <description>USB SOF Interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUS_RESET_INTR</name>
                <description>BUS RESET Interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP0_INTR</name>
                <description>EP0 Interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>LPM_INTR</name>
                <description>LPM Interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESUME_INTR</name>
                <description>Resume Interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ARB_EP_INTR</name>
                <description>Arbiter Endpoint Interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1_INTR</name>
                <description>EP1 Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2_INTR</name>
                <description>EP2 Interrupt</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP3_INTR</name>
                <description>EP3 Interrupt</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP4_INTR</name>
                <description>EP4 Interrupt</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP5_INTR</name>
                <description>EP5 Interrupt</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP6_INTR</name>
                <description>EP6 Interrupt</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP7_INTR</name>
                <description>EP7 Interrupt</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP8_INTR</name>
                <description>EP8 Interrupt</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DFT_CTL</name>
            <description>DFT control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>DDFT_OUT_SEL</name>
                <description>DDFT output select signal</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Nothing connected, output 0</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DP_SE</name>
                    <description>Single Ended output of DP</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DM_SE</name>
                    <description>Single Ended output of DM</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TXOE</name>
                    <description>Output Enable</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RCV_DF</name>
                    <description>Differential Receiver output</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DP_OUT</name>
                    <description>GPIO output of DP</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DM_OUT</name>
                    <description>GPIO output of DM</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DDFT_IN_SEL</name>
                <description>DDFT input select signal</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Nothing connected, output 0</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DP_IN</name>
                    <description>GPIO input of DP</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DM_IN</name>
                    <description>GPIO input of DM</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>USBHOST</name>
          <description>USB Host Controller</description>
          <addressOffset>0x00004000</addressOffset>
          <register>
            <name>HOST_CTL0</name>
            <description>Host Control 0 Register.</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>HOST</name>
                <description>This bit selects an operating mode of this IP.
'0' : USB Device
'1' : USB Host
Notes:
- The mode of operation mode does not transition immediately after setting this bit.  Read this bit to confirm that the operation mode has changed.
- This bit is reset to '0' if the ENABLE bit in this register changes from '1' to '0'.
- Before changing from the USB Host to the USB Device, check that the following conditions are satisfied and also set the RST bit of the Host Control 1 Register (HOST_CTL1). to '1'.
     * The SOFBUSY bit of the Host Status Register (HOST_STATUS) is set to '0'.
     * The TKNEN bits of the Host Token Endpoint Register (HOST_TOKEN) is set to '000'.
     * The SUSP bit of the Host Status Register (HOST_STATUS) is set to '0'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>This bit enables the operation of this IP.
'0' : Disable USB Host
'1' : Enable USB Host
Note:
- This bit doesn't affect the USB Device.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTL1</name>
            <description>Host Control 1 Register.</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x83</resetValue>
            <resetMask>0x83</resetMask>
            <fields>
              <field>
                <name>CLKSEL</name>
                <description>This bit selects the operating clock of USB Host.
'0' : Low-speed clock
'1' : Full-speed clock
Notes:
- This bit is set to it's default vaulue '1' if the ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.
- This bit must always be set to '1' in the USB Device mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>USTP</name>
                <description>This bit stops the clock for the USB Host operating unit. When this bit is '1', power consumption can be reduced by configuring this bit.
'0' : Normal operating mode.
'1' : Stops the clock for the USB Host operating unit.
Notes:
- If this bit is set to '1', the function of USB Host can't be used because internal clock is stopped.
- This bit is initialized if ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RST</name>
                <description>This bit resets the USB Host.
'0' : Normal operating mode.
'1' : USB Host is reset.
Notes:
- This bit is to it's default value '1' if  the ENABLE bit of the Host Control 0 Register (HOST_CTL0) changes from '1' to '0'.
- If this bit is set to '1', both the BFINI bits of the Host Endpoint 1 Control Register (HOST_EP1_CTL) and Host Endpoint 2 Control Register (HOST_EP2_CTL) are set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTL2</name>
            <description>Host Control 2 Register.</description>
            <addressOffset>0x100</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>RETRY</name>
                <description>If this bit is set to '1', the target token is retried if a NAK or error* occurs. Retry processing is performed after the time that is specified in the Host Retry Timer Setup Register (HOST_RTIMER).
* : HOST_ERR.RERR='1', HOST_ERR.TOUT='1', HOST_ERR.CRC='1', HOST_ERR.TGERR='1', HOST_ERR.STUFF='1'
'0' : Doesn't retry token sending.
'1' : Retries token sending
Note:
- This bit isn't initialized even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CANCEL</name>
                <description>When this bit is set to '1', if the target token is written to the Host Token Endpoint Register (HOST_TOKEN) in the EOF area (specified in the Host EOF Setup Register), its sending is canceled. When this bit is set to '0', token sending is not canceled even if the target token is written to the register. The cancellation of token sending is detected by reading the TCAN bit of the Interrupt USB Host Register (INTR_USBHOST).
'0' : Continues a token.
'1' : Cancels a token.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFSTEP</name>
                <description>If this bit is set to '1', the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is set to '1' each time SOF is sent.
If this bit is set to '0', the set value of the Host SOF Interrupt Frame Compare Register (HOST_FCOMP) is compared with the low-order eight bits of the SOF frame number. If they match, the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is set to '1'.
'0' : An interrupt occurred due to the HOST_HFCOMP setting.
'1' : An interrupt occurred.
Notes:
- If a SOF token (TKNEN='001') is sent by the setting of the Host Token Endpoint Register (HOST_TOKEN), the SOF interrupt flag (INTR_USBHOST.SOFIRQ) is not set to '1' regardless of the setting of this bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ALIVE</name>
                <description>This bit is used to specify the keep-alive function in the low-speed mode. If this bit it set to '1' while the CLKSEL bit of the Host Control 1 Register (HOST_CTL1) is '0', SE0 is output instead of SOF. This bit is only effective when the CLKSEL bit is '0'. If the CLKSEL bit is '1' (Full-Speed mode), SOF is output regardless of the setting of the ALIVE bit. 
'0' : SOF output.
'1' : SE0 output (Keep alive)</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_4</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TTEST</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_ERR</name>
            <description>Host Error Status Register.</description>
            <addressOffset>0x104</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>HS</name>
                <description>These flags indicate the status of a handshake packet to be sent or received.
These flags are set to 'NULL' when no handshake occurs due to an error or when a SOF token has been ended with the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN).
These bits are updated when sending or receiving has been ended. 
Write '11' to set the status back to 'NULL', all other write values are ignored. 
Note:
This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ACK</name>
                    <description>Acknowledge Packet</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NAK</name>
                    <description>Non-Acknowledge Packet</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>STALL</name>
                    <description>Stall Packet</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NULL</name>
                    <description>Null Packet</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STUFF</name>
                <description>If this bit is set to '1', it means that a bit stuffing error has been detected. When this bit is '0', it means that no error is detected. If a stuffing error is detected, bit5 (TOUT) of this register is also set to '1'.  Write '1' to clear, a write of '0' is ignored.
'0' : No stuffing error.
'1' : Stuffing error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TGERR</name>
                <description>If this bit is set to '1', it means that the data does not match the TGGL data. When this bit is '0', it means that no error is detected. Write '1' to clear, a write of '0' is ignored.
'0' : No toggle error.
'1' : Toggle error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRC</name>
                <description>If this bit is set to '1', it means that a CRC error is detected in the USB Host. When this bit is '0', it means that no error is detected. If a CRC error is detected, bit5 (TOUT) of this register is also set to '1'.  Write '1' to clear, a write of '0' is ignored.
'0' : No CRC error.
'1' : CRC error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOUT</name>
                <description>If this bit is set to '1', it means that no response is returned from the device within the specified time after a token has been sent in the USB Host. When this bit is '0', it means that no timeout is detected.  Write '1' to clear, a write of '0' is ignored.
'0' : No timeout.
'1' : Timeout has detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RERR</name>
                <description>When this bit is set to '1', it means that the received data exceeds the specified maximum number of packets in the USB Host. If a receive error is detected, bit5 (TOUT) of this register is also set to '1'. When this bit is '0', it means that no error is detected. Write '1' to clear, a write of '0' is ignored.
'0' : No receive error.
'1' : Maximum packet receive error detected.
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LSTSOF</name>
                <description>If this bit is set to '1', it means that the SOF token can't be sent in the USB Host because other token is in process. When this bit is '0', it means that SOF token was sent with no error. Write '1' to clear, a write of '0' is ignored.
'0' : SOF sent without error.
'1' : SOF error detected.
Note:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_STATUS</name>
            <description>Host Status Register.</description>
            <addressOffset>0x108</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xC2</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>CSTAT</name>
                <description>When this bit is '1', it means that the device is connected. When this bit is '0', it means that the device is disconnected.
'0' : Device is disconnected.
'1' : Device is connected.
Notes:
- This bit is set to the default value if the RST bit of the Host Control 1 Register (Host_CTL1) is set to '1'.
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TMODE</name>
                <description>If this bit is '1', it means that the device is connected in the full-speed mode. When this bit is '0', it means that the device is connected in the low-speed mode. This bit is valid when the CSTAT bit of the Host Status Register (HOST_STATUS) is '1'.
'0' : Low-speed.
'1' : Full-speed.
Notes:
- This bit is set to the default value if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'. 
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUSP</name>
                <description>If this bit is set to '1', the USB Host is placed into the suspend state. If this bit is set to '0' while it is '1' or the USB bus is placed into the k-state mode, then suspend state is released, and the RWIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
Set to '1' : Suspend.
Set '0' when this bit is '1' : Resume.
Other conditions : Holds the status.
Notes:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- The transition to disconnected on RST isn't immediate.  Read this bit to confirm the transition is complete.
- If this bit is set to '1', this bit must not be set to '1' until the RWIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
- Do not set this bit to '1' while the USB is active (during USB bus resetting, data transfer, or SOF timer running).
- If the value of this bit is changed, it is not immediately reflected on the state of the USB bus. To check whether or not the state is updated, read this bit.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SOFBUSY</name>
                <description>When a SOF token is sent using the Host Token Endpoint Register (HOST_TOKEN), this bit is set to '1', which means that the SOF timer is active. When this bit is '0', it means that the SOF timer is under suspension. To stop the active SOF timer, write '0' to this bit. However, if this bit is written with '1', its value is ignored. 
'0' : The SOF timer is stopped.
'1' : The SOF timer is active.
Notes:
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1).
- The SOF timer does not stop immediately after this bit has been set to '0' to stop the SOF timer. To check whether or not the SOF timer is stopped, read this bit.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URST</name>
                <description>When this bit is set to '1', the USB bus is reset. This bit remains a '1' during USB bus resetting, and changes to '0' when USB bus resetting is ended. If this bit is set to '0', the USB bus reset is complete</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_5</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSTBUSY</name>
                <description>This bit shows that USB Host is being reset internally. If the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1', this bit is set to '1'.
If the RST bit of Host Control 1 Register (HOST_CTL1) is set to '0', this bit is set to '0'.
'0' : USB Host isn't being reset.
'1' : USB Host is being reset.
Notes:
- If this bit is '1', the a token must not be executed.
- This bit isn't set to '0' or '1' immediately even if the RST bit of Host Control 1 Register (HOST_CTL1) is set to '0' or '1'. Read this bit to confirm the operation is complete.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CLKSEL_ST</name>
                <description>This bit shows whether it is full-speed or not. If the CLKSEL bit of the Host Control 1 Register (HOST_CTL1) is set to '1', this bit is set to '1'.
'0' : Low speed
'1' : Full speed
Note:
- If this bit is different from the CLKSEL bit, The execution of the token and bus reset must wait these bits match.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1). Read this bit to confirm the operation is complete.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOST_ST</name>
                <description>This bit shows whether the device is in USB Host mode. If the HOST bit of the Host Control Register (HOST_CTL0) is set to '1', this bit is set to '1'.
'0' : USB Device
'1' : USB Host
Notes:
- If this bit is different from the HOST bit, The execution of a token must wait these bits match.
- This bit takes time to be initialized by the RST bit of the Host Control 1 Resgiter (HOST_CTL1). Read this bit to confirm the operation is complete.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_FCOMP</name>
            <description>Host SOF Interrupt Frame Compare Register</description>
            <addressOffset>0x10C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>FRAMECOMP</name>
                <description>These bits are used to specify the data to be compared with the low-order eight bits of a frame number when sending a SOF token.
If the SOFSTEP bit of Host Control 2 Register (HOST_CTL2) is '0', the frame number of SOF is compared with the value of this register when sending a SOF token. If they match, the SOFIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
The setting of this register is invalid when the SOFSTEP bit of Host Control 2 Register (HOST_CTL2) is '1'.
Note:
- This bit is not reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_RTIMER</name>
            <description>Host Retry Timer Setup Register</description>
            <addressOffset>0x110</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFFF</resetMask>
            <fields>
              <field>
                <name>RTIMER</name>
                <description>These bits are used to specify the retry time in this register. The retry timer is activated when token sending starts while the RETRY bit of Host Control 2 Register (HOST_CTL2) is '1'. The retry time is then decremented by one when a 1-bit transfer clock (12 MHz in the full-speed mode) is output. When the retry timer reaches 0, the target token is sent, and processing ends.
If a token retry occurs in the EOF area, the retry timer is stopped until SOF sending is ended. After SOF sending has been completed, the retry timer restarts with the value that is set when the timer stopped.</description>
                <bitRange>[17:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_ADDR</name>
            <description>Host Address Register</description>
            <addressOffset>0x114</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>ADDRESS</name>
                <description>These bits are used to specify a token address.
Note:
- This bit is reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EOF</name>
            <description>Host EOF Setup Register</description>
            <addressOffset>0x118</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>EOF</name>
                <description>These bits are used to specify the time to disable token sending before transferring SOF. Specify the time with a margin, which is longer than the one-packet length. The time unit is the 1-bit transfer time.
Setting example: MAXPKT = 64 bytes, full-speed mode
 (Token_length + packet_length + header + CRC)*7/6 + Turn_around_time
  =(34 bit + 546 bit)*7/6 + 36 bit = 712.7 bit
 Therefore, set 0x2C9.
Note:
- This bit is not reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[13:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_FRAME</name>
            <description>Host Frame Setup Register</description>
            <addressOffset>0x11C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FF</resetMask>
            <fields>
              <field>
                <name>FRAME</name>
                <description>These bits are used to specify a frame number of SOF.
Notes:
- This bit isn't reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- Specify a frame number in this register before setting SOF in the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN).
- This register cannot be written while the SOFBUSY bit of the Host Status Register (HOST_STATUS) is '1' and a SOF token is in process.</description>
                <bitRange>[10:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_TOKEN</name>
            <description>Host Token Endpoint Register</description>
            <addressOffset>0x120</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x17F</resetMask>
            <fields>
              <field>
                <name>ENDPT</name>
                <description>These bits are used to specify an endpoint to send or receive data to or from the device.
Note:
- This bit isn't reset to default even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TKNEN</name>
                <description>These bits send a token according to the current settings. After operation is complete, the TKNEN bit is set to '000', and the CMPIRQ bit of the Interrupt USB Host Register (INTR_USBHOST) is set to '1'.
The settings of the TGGL and ENDPT bits are ignored when sending a SOF token.
Notes:
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- The PRE packet isn't supported.
- Do not set '100' to the TKNEN bit when the SOFBUSY bit of the Host Status Register (HOST_STATUS) is '1'
- Mode should be USB Host before writing data to this bit.
- When issuing a token again after the token interrupt flag (CMPIRQ) has been set to '1', wait for 3 cycles or more after a USB transfer clock (12 MHz in the full-speed mode, 1.5 MHz in the low-speed mode) was output, then write data to this bit.
- Read the value of TKNEN bit if a new value is written in it .Continue writing in this bit until a retrieved value equals a new value written in. During this checking process, it is needed to prevent any interrupt.
- Take the following steps when CMPIRQ bit of Interrupt USB Host Register (INTR_USBHOST) is set to '1' by finishing IN token or Isochronous IN token.
1. Read HS bit of Host Error Status Register (HOST_ERR), then set CMPIRQ bit to '0'.
2. Set EPn bit of Host DMA Enable Register (HOST_DMA_ENBL) (n=1 or 2) to '1' if HS bit of Host Error Status Register (HOST_ERR) is equal to '00' and wait until EPn bit of Host DMA Data Request Register (HOST_DMA_DREQ) changes to '1'. Finish the IN token processing if HS bit is not equal to '00'.
3. Read the received data if EPn bit of Host DMA Data Requet (HOST_DMA_DREQ) (n=1 or 2) changes to '1'.</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NONE</name>
                    <description>Sends no data.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SETUP</name>
                    <description>Sends SETUP token.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IN</name>
                    <description>Sends IN token.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OUT</name>
                    <description>Sends OUT token.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SOF</name>
                    <description>Sends SOF token.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_IN</name>
                    <description>Sends Isochronous IN.</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ISO_OUT</name>
                    <description>Sends Isochronous OUT.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSV</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>TGGL</name>
                <description>This bit is used to set toggle data. Toggle data is sent depending on the setting of this bit. When receiving toggle data, received toggle data is compared with the toggle data of this bit to verify whether or not an error occurs.
'0' : DATA0
'1' : DATA1
Notes:
- This bit isn't reset to the default value even if the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- Set this bit when the TKNEN bit of the Host Token Endpoint Register (HOST_TOKEN) is '000'.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_CTL</name>
            <description>Host Endpoint 1 Control Register</description>
            <addressOffset>0x400</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8100</resetValue>
            <resetMask>0x9DFF</resetMask>
            <fields>
              <field>
                <name>PKS1</name>
                <description>This bit specifies the maximum size transferred by one packet. The configurable range is from 0x001 to 0x100.
- If automatic buffer transfer mode (DMAE='1') is used, Endpoint 0,1, or 2 cannot be used,</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NULLE</name>
                <description>When a data transfer request in OUT the direction is transmitted while automatic buffer transfer mode is set (DMAE = 1), this bit sets a mode that transfers 0-byte data automatically upon the detection of the last packet transfer.
'0' : Releases the NULL automatic transfer mode.
'1' : Sets the NULL automatic transfer mode.
Note :
- For data transfer in the IN direction or when automatic buffer transfer mode is not set, the NULL bit configuration does not affect communication.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAE</name>
                <description>This bit sets a mode that uses DMA for writing or reading transfer data to/from send/receive buffer, and automatically transfers the send/receive data synchronized with an data request in the IN or OUT direction. Until the data size set in the DMA is reached, the data is transferred.
'0' : Releases the packet transfer mode.
'1' : Sets the packet transfer mode.
Note :
- The CPU must not access the send/receive buffer while the DMAE bit is set to '1'. For data transfer in the IN direction, set the DMA transfer size to the multiples of that set in PKS1 bits of the Host EP1 Control Register (HOST_EP1_CTL) and Host EP2 Control Register (HOST_EP2_CTR).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR</name>
                <description>This bit specifies the transfer direction the Endpoint support.
'0' : IN Endpoint.
'1' : OUT Endpoint
Note:
- This bit must be changed when INI_ST bit of the Host Endpoint 1 Status Register (HOST_EP1_STATUS) is '1'.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BFINI</name>
                <description>This bit initializes the send/receive buffer of transfer data. The BFINI bit is also automatically set by setting the RST bit of the HOST Control 1 Register (HOST_CTL1). If the RST bit was used for resetting, therefore, set the RST bit to '0' before clearing the BFINI bit.
'0' : Clears the initialization.
'1' : Initializes the send/receive buffer
Note :
- The EP1 buffer has a double-buffer configuration. The BFINI bit initialization initializes the double buffers concurrently and also initializes the EP1DRQ and EP1SPK bits.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_STATUS</name>
            <description>Host Endpoint 1 Status Register</description>
            <addressOffset>0x404</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x60000</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>SIZE1</name>
                <description>These bits indicate the number of data bytes written to the receive buffer when IN packet transfer of EP1 has finished.
The indication range is from 0x000 to 0x100.
Note :
- These bits are set to the data size transferred in the IN direction and written to the buffer. Therefore, a value read during transfer in the OUT direction has no effect.</description>
                <bitRange>[8:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VAL_DATA</name>
                <description>This bit shows that there is valid data in the EP1 buffer.
'0' : Invalid data in the buffer
'1' : Valid data in the buffer</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INI_ST</name>
                <description>This bit shows that EP1 is initialized. If the init bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is set to '1' and EP1 is initialized, this bit is to '1'.
'0' : Not initiatialized
'1' : Initialized
Note:
- This bit isn't set to '0' or '1' immediately even if BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is set to '0' or '1'.  Read this bit to confirm the transition.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_18</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_RW1_DR</name>
            <description>Host Endpoint 1 Data 1-Byte Register</description>
            <addressOffset>0x408</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>BFDT8</name>
                <description>Data Register for EP1 for 1-byte data</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_RW2_DR</name>
            <description>Host Endpoint 1 Data 2-Byte Register</description>
            <addressOffset>0x40C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BFDT16</name>
                <description>Data Register for EP1 for 2-byte data</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_CTL</name>
            <description>Host Endpoint 2 Control Register</description>
            <addressOffset>0x500</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8040</resetValue>
            <resetMask>0x9C7F</resetMask>
            <fields>
              <field>
                <name>PKS2</name>
                <description>This bit specifies the maximum size transferred by one packet. The configurable range is from 0x001 to 0x40.
- If automatic buffer transfer mode (DMAE='1') is used, this Endpoint must not set from 0 to 2.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>NULLE</name>
                <description>When a data transfer request in the OUT direction transmitted while packet transfer mode is set (DMAE = 1), this bit sets a mode that transfers 0-byte data automatically upon the detection of the last packet transfer.
'0' : Releases the NULL automatic transfer mode.
'1' : Sets the NULL automatic transfer mode.
Note :
- For data transfer in the IN direction or when automatic buffer transfer mode is not set, the NULL bit configuration does not affect communication.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMAE</name>
                <description>This bit sets a mode that uses DMA for writing or reading transfer data to/from send/receive buffer, and automatically transfers the send/receive data synchronized with an data request in the IN or OUT direction. Until the data size set in the DMA is reached, the data is transferred.
'0' : Releases the automatic buffer transfer mode.
'1' : Sets the automatic buffer transfer mode.
Note :
- The CPU must not access the send/receive buffer while the DMAE bit is set to '1'. For data transfer in the IN direction, set the DMA transfer size to the multiples of that set in PKS bits of the Host EP1 Control Register (HOST_EP1_CTL) and Host EP2 Control Register (HOST_EP2_CTR).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIR</name>
                <description>This bit specifies the transfer direction the Endpoint support.
'0' : IN Endpoint.
'1' : OUT Endpoint
Note:
- This bit must be changed when INI_ST bit of the Host Endpoint 2 Status Register (HOST_EP2_STATUS) is '1'.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BFINI</name>
                <description>This bit initializes the send/receive buffer of transfer data. The BFINI bit is also automatically set by setting the RST bit of the HOST Control 1 Register (HOST_CTL1). If the RST bit was used for resetting, therefore, set the RST bit to '0' before clearing the BFINI bit.
'0' : Clears the initialization.
'1' : Initializes the send/receive buffer
Note :
- The EP2 buffer has a double-buffer configuration. The BFINI bit initialization initializes the double buffers concurrently and also initializes the EP2DRQ and EP2SPK bits.</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_STATUS</name>
            <description>Host Endpoint 2 Status Register</description>
            <addressOffset>0x504</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x60000</resetValue>
            <resetMask>0x70000</resetMask>
            <fields>
              <field>
                <name>SIZE2</name>
                <description>These bits indicate the number of data bytes written to the receive buffer when IN packet transfer of EP2 has finished.
The indication range is from 0x000 to 0x40.
Note :
- These bits are set to the data size transferred in the IN direction and written to the buffer. Therefore, a value read during transfer in the OUT direction has no effect.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VAL_DATA</name>
                <description>This bit shows that there is valid data in the EP2 buffer.
'0' : Invalid data in the buffer
'1' : Valid data in the buffer</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INI_ST</name>
                <description>This bit shows that EP2 is initialized. If the BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is set to '1' and EP2 is initialized, this bit is to '1'.
'0' : Not Initialized
'1' : Initialized
Note:
- This bit isn't set to '0' or '1' immediately evne if BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is set to '0' or '1'.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_18</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_RW1_DR</name>
            <description>Host Endpoint 2 Data 1-Byte Register</description>
            <addressOffset>0x508</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>BFDT8</name>
                <description>Data Register for EP2 for 1-byte data.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_RW2_DR</name>
            <description>Host Endpoint 2 Data 2-Byte Register</description>
            <addressOffset>0x50C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BFDT16</name>
                <description>Data Register for EP2 for 2 byte data.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_LVL1_SEL</name>
            <description>Host Interrupt Level 1 Selection Register</description>
            <addressOffset>0x800</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_SEL</name>
                <description>These bits assign SOFIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DIRQ_SEL</name>
                <description>These bits assign DIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQ_SEL</name>
                <description>These bits assign CNNIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQ_SEL</name>
                <description>These bits assign URIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQ_SEL</name>
                <description>These bits assign URIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQ_SEL</name>
                <description>These bits assign RWKIRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_13_12</name>
                <description>N/A</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCAN_SEL</name>
                <description>These bits assign TCAN interrupt flag to selected interrupt signals.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_LVL2_SEL</name>
            <description>Host Interrupt Level 2 Selection Register</description>
            <addressOffset>0x804</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF0</resetMask>
            <fields>
              <field>
                <name>EP1_DRQ_SEL</name>
                <description>These bits assign EP1_DRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>HI</name>
                    <description>High priority interrupt</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MED</name>
                    <description>Medium priority interrupt</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LO</name>
                    <description>Low priority interrupt</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RSVD</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EP1_SPK_SEL</name>
                <description>These bits assign EP1_SPK interrupt flag to selected interrupt signals.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_DRQ_SEL</name>
                <description>These bits assign EP2_DRQ interrupt flag to selected interrupt signals.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2_SPK_SEL</name>
                <description>These bits assign EP2_SPK interrupt flag to selected interrupt signals.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_HI</name>
            <description>Interrupt USB Host Cause High Register</description>
            <addressOffset>0x900</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_MED</name>
            <description>Interrupt USB Host Cause Medium Register</description>
            <addressOffset>0x904</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_CAUSE_LO</name>
            <description>Interrupt USB Host Cause Low Register</description>
            <addressOffset>0x908</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ_INT</name>
                <description>SOFIRQ interrupt</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQ_INT</name>
                <description>DIRQ interrupt</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQ_INT</name>
                <description>CNNIRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQ_INT</name>
                <description>CMPIRQ interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQ_INT</name>
                <description>URIRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQ_INT</name>
                <description>RWKIRQ interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCAN_INT</name>
                <description>TCAN interrupt</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_HI</name>
            <description>Interrupt USB Host Endpoint Cause High Register</description>
            <addressOffset>0x920</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_MED</name>
            <description>Interrupt USB Host Endpoint Cause Medium Register</description>
            <addressOffset>0x924</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_CAUSE_LO</name>
            <description>Interrupt USB Host Endpoint Cause Low Register</description>
            <addressOffset>0x928</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ_INT</name>
                <description>EP1DRQ interrupt</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPK_INT</name>
                <description>EP1SPK interrupt</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQ_INT</name>
                <description>EP2DRQ interrupt</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPK_INT</name>
                <description>EP2SPK interrupt</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST</name>
            <description>Interrupt USB Host Register</description>
            <addressOffset>0x940</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQ</name>
                <description>If this bit is set to '1', it means that SOF token sending is started. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Does not issue an interrupt request by starting a SOF token.
'1' : Issues an interrupt request by starting a SOF token.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQ</name>
                <description>If this bit is set to '1', it means that a device disconnection is detected. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by detecting a device disconnection.
'1' : Issues an interrupt request by detecting a device disconnection.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQ</name>
                <description>If this bit is set to '1', it means that a device connection is detected. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by detecting a device connection.
'1' : Issues an interrupt request by detecting a device connection.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQ</name>
                <description>If this bit is set to '1', it means that a token is completed. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by token completion.
'1' : Issues an interrupt request by token completion.
Note :
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.
- This bit is not set to '1' even if the TCAN bit of the Interrupt USBHost Register (INTR_USBHOST) changes to '1'.
- Take the following steps when this bit is set to '1' by finishing IN token or Isochronous IN token.
1. Read HS bit of Host Error Status Register (HOST_ERR), then set CMPIRQ bit to '0'.
2. Set EPn bit of Host DMA Enable Register (HOST_DMA_ENBL) (n=1 or 2) to '1' if HS bit of Host Error Status Register (HOST_ERR) is equal to '00' and wait until EPn bit of Host DMA Data Request Register (HOST_DMA_DREQ) changes to '1'. Finish the IN token processing if HS bit is not equal to '00'.
3. Read the received data if EPn bit of Host DMA Data Requet (HOST_DMA_DREQ) (n=1 or 2) changes to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQ</name>
                <description>If this bit is set to '1', it means that USB bus resetting is ended. When this bit is '0', it has no meaning. If this bit is written with '1', it is set to '0'. However, if this bit is written with '0', its value is ignored.
'0' : Issues no interrupt request by USB bus resetting.
'1' : Issues an interrupt request by USB bus resetting.
Note :
- This bit is set to the initial value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQ</name>
                <description>If this bit is set to '1', it means that remote Wake-up is ended. When this bit is '0', it has no meaning. Write '1' to clear, a write of '0' is ignored.
'0' : Issues no interrupt request by restart.
'1' : Issues an interrupt request by restart.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCAN</name>
                <description>If this bit is set to '1', it means that token sending is canceled based on the setting of the CANCEL bit of Host Control 2 Register (HOST_CTL2). When this bit is '0', it means that token sending is not canceled. Write '1' to clear, a write of '0' is ignored.
'0' : Does not cancel token sending.
'1' : Cancels token sending.
Note :
- This bit is set to the default value when the RST bit of the Host Control 1 Register (HOST_CTL1) is set to '1'.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_SET</name>
            <description>Interrupt USB Host Set Register</description>
            <addressOffset>0x944</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQS</name>
                <description>This bit sets SOFIRQ bit. If this bit is written to '1', SOFIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQS</name>
                <description>This bit sets DIRQ bit. If this bit is written to '1', DIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQS</name>
                <description>This bit sets CNNIRQ bit. If this bit is written to '1', CNNIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQS</name>
                <description>This bit sets CMPIRQ bit. If this bit is written to '1', CMPIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQS</name>
                <description>This bit sets URIRQ bit. If this bit is written to '1', URIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQS</name>
                <description>This bit sets RWKIRQ bit. If this bit is written to '1', RWKIRQ is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCANS</name>
                <description>This bit sets TCAN bit. If this bit is written to '1', TCAN is set to '1'. However, if this bit is written with '0', its value is ignored.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_MASK</name>
            <description>Interrupt USB Host Mask Register</description>
            <addressOffset>0x948</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQM</name>
                <description>This bit masks the interrupt by SOF flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIRQM</name>
                <description>This bit masks the interrupt by DIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CNNIRQM</name>
                <description>This bit masks the interrupt by CNNIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMPIRQM</name>
                <description>This bit masks the interrupt by CMPIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>URIRQM</name>
                <description>This bit masks the interrupt by URIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RWKIRQM</name>
                <description>This bit masks the interrupt by RWKIRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCANM</name>
                <description>This bit masks the interrupt by TCAN flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_USBHOST_MASKED</name>
            <description>Interrupt USB Host Masked Register</description>
            <addressOffset>0x94C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>SOFIRQED</name>
                <description>This bit indicates the interrupt by SOF flag.
'0' : Doesn't request the interrupt by SOF
'1' : Request the interrupt by SOF</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DIRQED</name>
                <description>This bit indicates the interrupt by DIRQ flag.
'0' : Doesn't request the interrupt by DIRQ
'1' : Request the interrupt by DIRQ</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CNNIRQED</name>
                <description>This bit indicates the interrupt by CNNIRQ flag.
'0' : Doesn't request the interrupt by CNNIRQ
'1' : Request the interrupt by CNNIRQ</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMPIRQED</name>
                <description>This bit indicates the interrupt by CMPIRQ flag.
'0' : Doesn't request the interrupt by CMPIRQ
'1' : Request the interrupt by CMPIRQ</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>URIRQED</name>
                <description>This bit indicates the interrupt by URIRQ flag.
'0' : Doesn't request the interrupt by URIRQ
'1' : Request the interrupt by URIRQ</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RWKIRQED</name>
                <description>This bit indicates the interrupt by RWKIRQ flag.
'0' : Doesn't request the interrupt by RWKIRQ
'1' : Request the interrupt by RWKIRQ</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RSVD_6</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TCANED</name>
                <description>This bit indicates the interrupt by TCAN flag.
'0' : Doesn't request the interrupt by TCAN
'1' : Request the interrupt by TCAN</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP</name>
            <description>Interrupt USB Host Endpoint Register</description>
            <addressOffset>0xA00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQ</name>
                <description>This bit indicates that the EP1 packet transfer has normally ended, and processing of the data is required. The DRQ bit is an interrupt cause, and writing '0' is ignored. Clear the DRQ bit by writing '1'.
'0' : Clears the interrupt cause
'1' : Packet transfer normally ended
Note :
- If automatic buffer transfer mode (DMAE = '1') is not used, '1' must be written to the DRQ bit after data has been written or read to/from the send/receive buffer. Switch the access buffers once the DRQ bit is cleared. That DRQ = '0' may not be read after the DRQ bit is cleared. If the transfer direction is set to OUT, and the DRQ bit is cleared without writing buffer data while the DRQ bit is '1', it implies that 0-byte data is set. If DIR of the Host Endpoint 1 Control Register (HOST_EP1_CTL)  is set to '1' at initial settings, the DRQ bit of corresponding Endpoint is set at the same time. Also while the DRQ bit is not set, '1' must not be written.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPK</name>
                <description>This bit indicates that the data size transferred from the host does not satisfy the maximum packet size (including 0-byte) set by PKS in the Host Endpoint 1 Control Register (HOST_EP1_CTL) when the data has been received successfully. This bit is an interrupt cause, and writing '0' is ignored. Clear it by writing '1'.
'0' : Received data size satisfies the maximum packet size
'1' : Received data size does not satisfy the maximum packet size
Note :
- The EP1SPK bit is not set during data transfer in the OUT direction.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQ</name>
                <description>This bit indicates that the EP2 packet transfer has normally ended, and processing of the data is required. The DRQ bit is an interrupt cause, and writing '0' is ignored. Clear the DRQ bit by writing '1'.
'0' : Clears the interrupt cause
'1' : Packet transfer normally ended
Note :
- If packet transfer mode (DMAE = '1') is not used, '1' must be written to the DRQ bit after data has been written or read to/from the send/receive buffer. Switch the access buffers once the DRQ bit is cleared. That DRQ = '0' may not be read after the DRQ bit is cleared. If the transfer direction is set to OUT, and the DRQ bit is cleared without writing buffer data while the DRQ bit is '1', it implies that 0-byte data is set. If DIR of the Host Endpoint 2 Control Register (HOST_EP2_CTL)  is set to '1' at initial settings, the DRQ bit of corresponding Endpoint is set at the same time. Also while the DRQ bit is not set, '1' must not be written.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPK</name>
                <description>This bit indicates that the data size transferred from the host does not satisfy the maximum packet size (including 0-byte) set by PKS1 in the Host Endpoint 2 Control Register (HOST_EP2_CTL) when the data has been received successfully. This bit is an interrupt cause, and writing '0' is ignored. Clear it by writing '1'.
'0' : Received data size satisfies the maximum packet size
'1' : Received data size does not satisfy the maximum packet size
Note :
- The SPK bit is not set during data transfer in the OUT direction.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_SET</name>
            <description>Interrupt USB Host Endpoint Set Register</description>
            <addressOffset>0xA04</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQS</name>
                <description>This bit sets EP1DRQ bit. If this bit is written to '1', EP1DRQ is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is '1', EP1DRQ can't be set to '1'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPKS</name>
                <description>This bit sets EP1SPK bit. If this bit is written to '1', EP1SPK is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 1 Control Register (HOST_EP1_CTL) is '1', EP1SPK can't be set to '1'.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQS</name>
                <description>This bit sets EP2DRQ bit. If this bit is written to '1', EP2DRQ is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is '1', EP2DRQ can't be set to '1'.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPKS</name>
                <description>This bit sets EP2SPK bit. If this bit is written to '1', EP2SPK is set to '1'. However, if this bit is written with '0', its value is ignored.
Note:
If BFINI bit of the Host Endpoint 2 Control Register (HOST_EP2_CTL) is '1', EP2SPK can't be set to '1'.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_MASK</name>
            <description>Interrupt USB Host Endpoint Mask Register</description>
            <addressOffset>0xA08</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQM</name>
                <description>This bit masks the interrupt by EP1DRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP1SPKM</name>
                <description>This bit masks the interrupt by EP1SPK flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2DRQM</name>
                <description>This bit masks the interrupt by EP2DRQ flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EP2SPKM</name>
                <description>This bit masks the interrupt by EP2SPK flag.
'0' : Disables
'1' : Enables</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_HOST_EP_MASKED</name>
            <description>Interrupt USB Host Endpoint Masked Register</description>
            <addressOffset>0xA0C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3C</resetMask>
            <fields>
              <field>
                <name>EP1DRQED</name>
                <description>This bit indicates the interrupt by EP1DRQ flag.
'0' : Doesn't request the interrupt by EP1DRQ
'1' : Request the interrupt by EP1DRQ</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP1SPKED</name>
                <description>This bit indicates the interrupt by EP1SPK flag.
'0' : Doesn't request the interrupt by EP1SPK
'1' : Request the interrupt by EP1SPK</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2DRQED</name>
                <description>This bit indicates the interrupt by EP2DRQ flag.
'0' : Doesn't request the interrupt by EP2DRQ
'1' : Request the interrupt by EP2DRQ</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EP2SPKED</name>
                <description>This bit indicates the interrupt by EP2SPK flag.
'0' : Doesn't request the interrupt by EP2SPK
'1' : Request the interrupt by EP2SPK</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_DMA_ENBL</name>
            <description>Host DMA Enable Register</description>
            <addressOffset>0xB00</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xC</resetMask>
            <fields>
              <field>
                <name>DM_EP1DRQE</name>
                <description>This bit enables DMA Request by EP1DRQ.
'0' : Disable
'1' : Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM_EP2DRQE</name>
                <description>This bit enables DMA Request by EP2DRQ.
'0' : Disable
'1' : Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP1_BLK</name>
            <description>Host Endpoint 1 Block Register</description>
            <addressOffset>0xB20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>BLK_NUM</name>
                <description>Set the total byte number for DMA transfer. If HOST_EP1_RW1_DR or HOST_EP1_RW2_DR is written, the block number counter is decremented when DMAE='1'.
- Set this bits before DMA transfer is enabled (HOST_DMA_ENBL.DM_DP1DRQE='1')</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_EP2_BLK</name>
            <description>Host Endpoint 2 Block Register</description>
            <addressOffset>0xB30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF0000</resetMask>
            <fields>
              <field>
                <name>BLK_NUM</name>
                <description>Set the total byte number for DMA transfer. If HOST_EP2_RW1_DR or HOST_EP2_RW2_DR is written, the block number counter is decremented when DMAE='1'.
- Set this bits before DMA transfer is enabled (HOST_DMA_ENBL.DM_DP2DRQE='1')</description>
                <bitRange>[31:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMIF0</name>
      <description>Serial Memory Interface</description>
      <headerStructName>SMIF</headerStructName>
      <baseAddress>0x40420000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000</resetValue>
          <resetMask>0x81073001</resetMask>
          <fields>
            <field>
              <name>XIP_MODE</name>
              <description>Mode of operation.

Note: this field should only be changed when the IP is disabled or when STATUS.BUSY is '0' and SW should not be executing from the XIP interface or MMIO interface.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MMIO_MODE</name>
                  <description>'0': MMIO mode. Individual MMIO accesses to TX and RX FIFOs are used to generate a sequence of SPI transfers. This mode of operation allows for large flexibility in terms of the SPI transfers that can be generated.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XIP_MODE</name>
                  <description>1': XIP mode. eXecute-In-Place mode: incoming read and write transfers over the AHB-Lite bus infrastructure are automatically translated in SPI transfers to read data from and write data to a device. This mode of operation allow for efficient device read and write operations. This mode is only supported in SPI_MODE.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_IF_RX_SEL</name>
              <description>Specifies device interface receiver clock 'clk_if_rx' source. MISO data is captured on the rising edge of 'clk_if_rx'.
'0': 'spi_clk_out' (internal clock)
'1': !'spi_clk_out' (internal clock)
'2': 'spi_clk_in' (feedback clock)
'3': !'spi_clk_in' (feedback clock)

Note: the device interface transmitter clock 'clk_if_tx' is fixed and is 'spi_clk_out' MOSI data is driven on the falling edge of 'clk_if_tx'.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DESELECT_DELAY</name>
              <description>Specifies the minimum duration of SPI deselection ('spi_select_out[]' is high/'1') in between SPI transfers:
'0': 1 interface clock cycle.
'1': 2 interface clock cycles.
'2': 3 interface clock cycles.
'3': 4 interface clock cycles.
'4': 5 interface clock cycles.
'5': 6 interface clock cycles.
'6': 7 interface clock cycles.
'7': 8 interface clock cycles.

During SPI deselection, 'spi_select_out[]' are '1'/inactive, 'spi_data_out[]' are '1' and 'spi_clk_out' is '0'/inactive.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Specifies what happens for MMIO interface read accesses to an empty RX data FIFO or to a full TX format/data FIFO. Note: the FIFOs can only be accessed in MMIO_MODE.

This field is not used for test controller accesses.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BUS_ERROR</name>
                  <description>0': Generate an AHB-Lite bus error. This option is useful when SW decides to use polling on STATUS.TR_BUSY to determine if a interface transfer is no longer busy (transfer is completed). This option adds SW complexity, but limits the number of AHB-Lite wait states (and limits ISR latency).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_STATES</name>
                  <description>1': Introduce wait states. This setting potentially locks up the AHB-Lite infrastructure and may increase the CPU interrupt latency.This option is useful when SW performs TX/RX data FIFO accesses immediately after a command is setup using the TX format FIFO. This option has low SW complexity, but may result in a significant number of AHB-Lite wait states (and may increase ISR latency).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enable:
'0': Disabled. All non-retention registers are reset to their default value when the IP is disabled. When the IP is disabled, the XIP accesses produce AHB-Lite bus errors.
'1': Enabled.

Note: Before disabling the IP, SW should ensure that the IP is NOT busy (STATUS.BUSY is '0'), otherwise illegal interface transfers may occur.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>BUSY</name>
              <description>Cache, cryptography, XIP, device interface or any other logic busy in the IP:
'0': not busy
'1': busy
When BUSY is '0', the IP can be safely disabled without:
- the potential loss of transient write data.
- the potential risk of aborting an inflight SPI device interface transfer.
When BUSY is '0', the mode of operation (XIP_MODE or MMIO_MODE) can be safely changed.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_STATUS</name>
          <description>Transmitter command FIFO status</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>USED3</name>
              <description>Number of entries that are used in the TX command FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 4].</description>
              <bitRange>[2:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CMD_FIFO_WR</name>
          <description>Transmitter command FIFO write</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA20</name>
              <description>Command data. The higher two bits DATA[19:18] specify the specific command
'0'/TX: A SPI transfer always start with a TX command FIFO entry of the 'TX' format.
- DATA[17:16] specifies the width of the data transfer:
   - '0': 1 bit/cycle (single data transfer).
   - '1': 2 bits/cycle (dual data transfer).
   - '2': 4 bits/cycle (quad data transfer).
   - '3': 8 bits/cycle (octal data transfer).
- DATA[15]: specifies whether this is the last TX Byte; i.e. whether the 'spi_select_out[3:0]' IO output signals are de-activated after the transfer.
- DATA[11:8] specifies which of the four devices are selected. DATA[11:8] are directly mapped to 'spi_select_out[3:0]'. Two devices can be selected at the same time in dual-quad mode.
  - '0': device deselected
  - '1': device selected 
- DATA[7:0] specifies the transmitted Byte.

'1'/TX_COUNT: The 'TX_COUNT' command relies on the TX data FIFO to provide the transmitted bytes. The 'TX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
- DATA[17:16] specifies the width of the transfer.
- DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) from the TX data FIFO.

'2'/RX_COUNT: The 'RX_COUNT' command relies on the RX data FIFO to accept the received bytes. The 'RX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
- DATA[17:16] specifies the width of the transfer.
- DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) to the RX data FIFO.

'3'/DUMMY_COUNT: The 'DUMMY_COUNT' command conveys dummy cycles. Dummy cycles are used to implement a Turn-Around time in which the SPI master changes from a transmitter driving the data lines to a receiver receiving on the same data lines. The 'DUMMY_COUNT' command is ALWAYS considered to be NOT the last command of a SPI data transfers; i.e. it needs to be followed by another command.
- DATA[15:0] specifies the number of dummy cycles (minus 1). In dummy cycles, the data lines are not driven.</description>
              <bitRange>[19:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_CTL</name>
          <description>Transmitter data FIFO control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Determines when the TX data FIFO 'tr_tx_req' trigger is activated  (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when TX_DATA_FIFO_STATUS.USED &lt;= TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_STATUS</name>
          <description>Transmitter data FIFO status</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the TX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR1</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR2</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_DATA_FIFO_WR4</name>
          <description>Transmitter data FIFO write</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>TX data (written to TX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>TX data (written to TX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>TX data (written to TX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>write-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>TX data (written to TX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_CTL</name>
          <description>Receiver data FIFO control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Determines when RX data FIFO 'tr_rx_req' trigger is activated (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
- Trigger is active when RX_DATA_FIFO_STATUS.USED &gt; TRIGGER_LEVEL.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_STATUS</name>
          <description>Receiver data FIFO status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>USED4</name>
              <description>Number of entries that are used in the RX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD1</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD2</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD4</name>
          <description>Receiver data FIFO read</description>
          <addressOffset>0xD8</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO, first byte).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA1</name>
              <description>RX data (read from RX data FIFO, second byte).</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA2</name>
              <description>RX data (read from RX data FIFO, third byte).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DATA3</name>
              <description>RX data (read from RX data FIFO, fourth byte).</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_DATA_FIFO_RD1_SILENT</name>
          <description>Receiver data FIFO silent read</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA0</name>
              <description>RX data (read from RX data FIFO).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CTL</name>
          <description>Slow cache control</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>Specifies the cache way for which cache information is provided in SLOW_CA_STATUS0/1/2.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>Specifies the cache set for which cache information is provided in SLOW_CA_STATUS0/1/2.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': Disabled.
'1': Enabled.

Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Cache enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SLOW_CA_CMD</name>
          <description>Slow cache command</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>Cache and prefetch buffer invalidation. 
SW writes a '1' to clear the cache and prefetch buffer. The cache's LRU structure is also reset to its default state.
Note, 
A write access will invalidate the prefetch buffer automatically in hardware.
A write access should invalidate both fast and slow caches, by firmware.
Note, firmware should invalidate the cache and prefetch buffer only when STATUS.BUSY is '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CTL</name>
          <description>Fast cache control</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC0000000</resetValue>
          <resetMask>0xC3030000</resetMask>
          <fields>
            <field>
              <name>WAY</name>
              <description>See SLOW_CA_CTL.WAY.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SET_ADDR</name>
              <description>See SLOW_CA_CTL.SET_ADDR.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>See SLOW_CA_CTL.PREF_EN.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>See SLOW_CA_CTL.ENABLED.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAST_CA_CMD</name>
          <description>Fast cache command</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>INV</name>
              <description>See SLOW_CA_CMD.INV.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_CMD</name>
          <description>Cryptography Command</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START</name>
              <description>SW sets this field to '1' to start a AES-128 forward block cipher operation (on the address in CRYPTO_ADDR). HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRYPTO_RESULT0, ..., CRYPTO_RESULT3.

The operation takes roughly 13 clk_hf clock cycles.

Note: An operation can only be started in MMIO_MODE.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT0</name>
          <description>Cryptography input 0</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[31:0] = CRYPTO_INPUT0.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT1</name>
          <description>Cryptography input 1</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[63:32] = CRYPTO_INPUT1.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT2</name>
          <description>Cryptography input 2</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[95:64] = CRYPTO_INPUT2.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_INPUT3</name>
          <description>Cryptography input 3</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INPUT</name>
              <description>Four Bytes of the plaintext PT[127:96] = CRYPTO_INPUT3.INPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY0</name>
          <description>Cryptography key 0</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[31:0] = CRYPTO_KEY0.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY1</name>
          <description>Cryptography key 1</description>
          <addressOffset>0x244</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[63:32] = CRYPTO_KEY1.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY2</name>
          <description>Cryptography key 2</description>
          <addressOffset>0x248</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[95:64] = CRYPTO_KEY2.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_KEY3</name>
          <description>Cryptography key 3</description>
          <addressOffset>0x24C</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Four Bytes of the key KEY[127:96] = CRYPTO_KEY3.KEY[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT0</name>
          <description>Cryptography output 0</description>
          <addressOffset>0x260</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[31:0] = CRYPTO_OUTPUT0.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT1</name>
          <description>Cryptography output 1</description>
          <addressOffset>0x264</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[63:32] = CRYPTO_OUTPUT1.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT2</name>
          <description>Cryptography output 2</description>
          <addressOffset>0x268</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[95:64] = CRYPTO_OUTPUT2.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRYPTO_OUTPUT3</name>
          <description>Cryptography output 3</description>
          <addressOffset>0x26C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>OUTPUT</name>
              <description>Four Bytes of the ciphertext CT[127:96] = CRYPTO_OUTPUT3.OUTPUT[31:0].</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7C0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Activated in MMIO mode, when a TX data FIFO trigger 'tr_tx_req' is activated.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Activated in MMIO mode, when a RX data FIFO trigger 'tr_rx_req' is activated.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Activated in XIP mode, if:
- The selected device's ADDR_CTL.DIV2 is '1' and the AHB-Lite bus transfer address is not a multiple of 2.
- The selected device's ADDR_CTL.DIV2 is '1' and the XIP transfer request is NOT for a multiple of 2 Bytes. 

Note: In dual-quad SPI mode (ADDR_CTL.DIV is '1'), each memory device contributes a 4-bit nibble for read data or write data. This is only possible if the request address is a multiple of 2 and the number of requested Bytes is a multiple of 2.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX command FIFO (TX_CMD_FIFO_WR) with not enough free entries available.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX data FIFO (TX_DATA_FIFO_WR1, TX_DATA_FIFO_WR2, TX_DATA_FIFO_WR4) with not enough free entries available.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Activated in MMIO mode, on an AHB-Lite read transfer from the RX data FIFO (RX_DATA_FIFO_RD1, RX_DATA_FIFO_RD2, RX_DATA_FIFO_RD4) with not enough entries available. Only activated for NON test bus controller transfers.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7C4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7C8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7CC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TR_TX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TR_RX_REQ</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>XIP_ALIGNMENT_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_CMD_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_DATA_FIFO_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_DATA_FIFO_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>128</dimIncrement>
          <name>DEVICE[%s]</name>
          <description>Device (only used in XIP mode)</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80030101</resetMask>
            <fields>
              <field>
                <name>WR_EN</name>
                <description>Write enable:
'0': write transfers are not allowed to this device. An attempt to write to this device results in an AHB-Lite bus error.
'1': write transfers are allowed to this device.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CRYPTO_EN</name>
                <description>Cryptography on read/write accesses:
'0': disabled.
'1': enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SEL</name>
                <description>Specifies the connection of the IP's data lines (spi_data[0], ..., spi_data[7]) to the device's data lines (SI/IO0, SO/IO1, IO2, IO3, IO4, IO5, IO6, IO7):
'0': spi_data[0] = IO0, spi_data[1] = IO1, ..., spi_data[7] = IO7. This value is allowed for single, dual, quad, dual quad and octal SPI modes. This value must be used for the first device in dual quad SPI mode. This value must be used for octal SPI mode.
'1': spi_data[2] = IO0, spi_data[3] = IO1. This value is only allowed for single and dual SPI modes.
'2': spi_data[4] = IO0, spi_data[5] = IO1, ..., spi_data[7] = IO3. This value is only allowed for single, dual, quad and dual quad  SPI modes. In dual quad SPI mode, this value must be used for the second device. 
'3': spi_data[6] = IO0, spi_data[7] = IO1. This value is only allowed for single and dual SPI modes.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Device enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR</name>
            <description>Device region base address</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Specifies the base address of the device region. If the device region is 2^m Bytes, ADDR MUST be a multiple of 2^m.

In dual quad SPI data transfer, the two devices should have the same ADDR and MASK register settings. The device control information (ADDR_CTL, RD_CMD_CTL, etc.) are provided by the MMIO control registers of the device with the lowest index.

The most significant bit fields are constants and set based on the SMIF_XIP_ADDR parameter. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK is 0xff00:0000 (16 MB XIP memory region), ADDR[31:24] = SMIF_XIP_ADDR[31:24].</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK</name>
            <description>Device region mask</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>MASK</name>
                <description>Specifies the size of the device region. All '1' bits are used to compare the incoming transfer request address A[31:0] with the address as specified in ADDR.ADDR: Address A is in the device when (A[31:8] &amp; MASK[31:8]) == ADDR.ADDR[31:8].

The most significant bit fields are constants and set to'1'. The most significant bits are identified on the SMIF_XIP_MASK parameter. E.g., if SMIF_XIP_MASK  is 0xff00:0000 (16 MB XIP memory region), MASK[31:24] = 0xff.

Note: a transfer request that is not in any device region results in an AHB-Lite bus error.</description>
                <bitRange>[31:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADDR_CTL</name>
            <description>Address control</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x103</resetMask>
            <fields>
              <field>
                <name>SIZE2</name>
                <description>Specifies the size of the XIP device address in Bytes:
'0': 1 Byte address.
'1': 2 Byte address.
'2': 3 Byte address.
'3': 4 Byte address.
The lower significant address Bytes of the transfer request are used as XIP address to the external device. Note that for dual quad SPI data transfer, the transfer request address is divided by 2. Therefore, the transfer request address needs to be a multiple of 2. If the trasnfer requestaddress is NOT a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DIV2</name>
                <description>Specifies if the AHB-Lite bus transfer address is divided by 2 or not:
'0': No divide by 2.
'1': Divide by 2.  

This functionality is used for read and write operation in XIP, dual quad SPI mode; i.e. this DIV2 must be set to '1' in dual quad SPI mode. If the transfer request address is NOT a multiple of 2 or the requested number of Bytes is not a multiple of 2, the XIP_ALIGNMENT_ERROR interrupt cause is activated.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_CMD_CTL</name>
            <description>Read command control</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of data transfer:
'0': 1 bit/cycle (single data transfer).
'1': 2 bits/cycle (dual data transfer).
'2': 4 bits/cycle (quad data transfer).
'3': 8 bits/cycle (octal data transfer).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of command field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_ADDR_CTL</name>
            <description>Read address control</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_MODE_CTL</name>
            <description>Read mode control</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of mode field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DUMMY_CTL</name>
            <description>Read dummy control</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.

Note: this field specifies dummy cycles, not dummy Bytes!</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RD_DATA_CTL</name>
            <description>Read data control</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_CMD_CTL</name>
            <description>Write command control</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Command byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of command field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_ADDR_CTL</name>
            <description>Write address control</description>
            <addressOffset>0x64</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_MODE_CTL</name>
            <description>Write mode control</description>
            <addressOffset>0x68</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x800300FF</resetMask>
            <fields>
              <field>
                <name>CODE</name>
                <description>Mode byte code.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of mode field:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DUMMY_CTL</name>
            <description>Write dummy control</description>
            <addressOffset>0x6C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000001F</resetMask>
            <fields>
              <field>
                <name>SIZE5</name>
                <description>Number of dummy cycles (minus 1):
'0': 1 cycles
...
'31': 32 cycles.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESENT</name>
                <description>Presence of dummy cycles:
'0': not present
'1': present</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WR_DATA_CTL</name>
            <description>Write data control</description>
            <addressOffset>0x70</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x30000</resetMask>
            <fields>
              <field>
                <name>WIDTH</name>
                <description>Width of transfer.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SDHC0</name>
      <description>SD/eMMC Host Controller</description>
      <headerStructName>SDHC</headerStructName>
      <baseAddress>0x40460000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>WRAP</name>
          <description>MMIO at SDHC wrapper level</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Top level wrapper control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>ENABLE</name>
                <description>IP Enable:
0: IP disabled, RAM in DeepSleep, SDHC_CORE regs are inaccessible (any attempts to access will result in AHB Error responses), IP is NOT held in reset but the clocks are gated
1: IP enabled, normal operation</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <cluster>
          <name>CORE</name>
          <description>MMIO for Synopsys Mobile Storage Host Controller IP</description>
          <addressOffset>0x00001000</addressOffset>
          <register>
            <name>SDMASA_R</name>
            <description>SDMA System Address register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BLOCKCNT_SDMASA</name>
                <description>32-bit Block Count (SDMA System Address)
- SDMA System Address (Host Version 4 Enable = 0): This
register contains the system memory address for an
SDMA transfer in the 32-bit addressing mode. When the
Host Controller stops an SDMA transfer, this register
points to the system address of the next contiguous data
position. It can be accessed only if no transaction is
executing. Reading this register during data transfers may
return an invalid value.
- 32-bit Block Count (Host Version 4 Enable = 1): From the
Host Controller Version 4.10 specification, this register is
redefined as 32-bit Block Count. The Host Controller
decrements the block count of this register for every block
transfer and the data transfer stops when the count
reaches zero. This register must be accessed when no
transaction is executing. Reading this register during data
transfers may return invalid value.
Following are the values for BLOCKCNT_SDMASA:
- 0xFFFF_FFFF - 4G - 1 Block
- ......
- 0x0000_0002 - 2 Blocks
- 0x0000_0001 - 1 Block
- 0x0000_0000 - Stop Count
Note:
- When Host Version 4 Enable = 0, SDMA uses this register as system address and hence Auto CMD23 cannot be used with SDMA since this register is assigned for Auto CMD23 as 32-bit Block Count register. 
-When Host Version 4 Enable = 1, SDMA uses ADMA system address register and this register is reassigned to 32-bit Block Count. This register must be programmed with a non-zero value for data transfer if the 32-bit Block count register is used instead of the 16-bit Block count register. SDMA may use Auto CMD23 if 32-bit Block Count register is used.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLOCKSIZE_R</name>
            <description>Block Size register</description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>XFER_BLOCK_SIZE</name>
                <description>Transfer Block Size
These bits specify the block size of data transfers. In case of
memory, it is set to 512 bytes. It can be accessed only if no
transaction is executing. Read operations during transfers
may return an invalid value, and write operations are
ignored. Following are the values for XFER_BLOCK_SIZE:
- 0x1: 1 byte
- 0x2: 2 bytes
- 0x3: 3 bytes
- ......
- 0x1FF: 511 byte
- 0x200: 512 bytes
- ......
- 0x800: 2048 bytes
Note: This register must be programmed with a non-zero
value for data transfer.</description>
                <bitRange>[11:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SDMA_BUF_BDARY</name>
                <description>SDMA Buffer Boundary
These bits specify the size of contiguous buffer in system
memory. The SDMA transfer waits at every boundary
specified by these fields and the Host Controller generates
the DMA interrupt to request the Host Driver to update the
SDMA System Address register.
Values:
- 0x0 (BYTES_4K): 4K bytes SDMA Buffer Boundary
- 0x1 (BYTES_8K): 8K bytes SDMA Buffer Boundary
- 0x2 (BYTES_16K): 16K bytes SDMA Buffer Boundary
- 0x3 (BYTES_32K): 32K bytes SDMA Buffer Boundary
- 0x4 (BYTES_64K): 64K bytes SDMA Buffer Boundary
- 0x5 (BYTES_128K): 128K bytes SDMA Buffer Boundary
- 0x6 (BYTES_256K): 256K bytes SDMA Buffer Boundary
- 0x7 (BYTES_512K): 512K bytes SDMA Buffer Boundary</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BLOCKCOUNT_R</name>
            <description>16-bit Block Count register</description>
            <addressOffset>0x6</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>BLOCK_CNT</name>
                <description>16-bit Block Count
- If the Host Version 4 Enable bit is set 0 or the 16-bit Block
Count register is set to non-zero, the 16-bit Block Count
register is selected.
- If the Host Version 4 Enable bit is set 1 and the 16-bit
Block Count register is set to zero, the 32-bit Block Count
register is selected.
Following are the values for BLOCK_CNT:
- 0x0: Stop Count
- 0x1: 1 Block
- 0x2: 2 Blocks
- ... - ...
- 0xFFFF: 65535 Blocks
Note: For Host Version 4 Enable = 0, this register must be
set to 0000h before programming the 32-bit block count
register when Auto CMD23 is enabled for non-DMA and
ADMA modes.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ARGUMENT_R</name>
            <description>Argument register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ARGUMENT</name>
                <description>Command Argument
These bits specify the SD/eMMC command argument that is
specified in bits 39-8 of the Command format.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>XFER_MODE_R</name>
            <description>Transfer Mode register</description>
            <addressOffset>0xC</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DMA_ENABLE</name>
                <description>DMA Enable
This bit enables the DMA functionality. If this bit is set to 1, a
DMA operation begins when the Host Driver writes to the
Command register. You can select one of the DMA modes by
using DMA Select in the Host Control 1 register.
Values:
- 0x1 (ENABLED): DMA Data transfer
- 0x0 (DISABLED): No data transfer or Non-DMA data
transfer</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BLOCK_COUNT_ENABLE</name>
                <description>Block Count Enable
This bit is used to enable the Block Count register, which is
relevant for multiple block transfers. If this bit is set to 0, the
Block Count register is disabled, which is useful in executing
an infinite transfer. The Host Driver must set this bit to 0
when ADMA is used.  When 16-bit Block Count register is used, the Host Driver can set this bit to 0 in ADMA2 mode to enable larger data transfer than the maximum of 65535 block counts supported by the 16-bit Block Count register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ENABLE</name>
                <description>Auto Command Enable
This field determines use of Auto Command functions.
Note: In SDIO, this field must be set as 00b (Auto Command
Disabled).
Values:
- 0x0 (AUTO_CMD_DISABLED): Auto Command Disabled
- 0x1 (AUTO_CMD12_ENABLED): Auto CMD12 Enable
- 0x2 (AUTO_CMD23_ENABLED): Auto CMD23 Enable
- 0x3 (AUTO_CMD_AUTO_SEL): Auto CMD Auto Select</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_XFER_DIR</name>
                <description>Data Transfer Direction Select
This bit defines the direction of DAT line data transfers. This
bit is set to 1 by the Host Driver to transfer data from the
SD/eMMC card to the Host Controller and it is set to 0 for all
other commands.
Values:
- 0x1 (READ): Read (Card to Host)
- 0x0 (WRITE): Write (Host to Card)</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MULTI_BLK_SEL</name>
                <description>Multi/Single Block Select
This bit is set when issuing multiple-block transfer
commands using the DAT line. If this bit is set to 0, it is not
necessary to set the Block Count register.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_TYPE</name>
                <description>Response Type R1/R5
This bit selects either R1 or R5 as a response type when the
Response Error Check is selected.
Error statuses checked in R1:
- OUT_OF_RANGE
- ADDRESS_ERROR
- BLOCK_LEN_ERROR
- WP_VIOLATION
- CARD_IS_LOCKED
- COM_CRC_ERROR
- CARD_ECC_FAILED
- CC_ERROR
- ERROR
Response Flags checked in R5:
- COM_CRC_ERROR
- ERROR
- FUNCTION_NUMBER
- OUT_OF_RANGE
Values:
- 0x0 (RESP_R1): R1 (Memory)
- 0x1 (RESP_R5): R5 (SDIO)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR_CHK_ENABLE</name>
                <description>Response Error Check Enable
The Host Controller supports response check function to
avoid overhead of response error check by Host driver.
Response types of only R1 and R5 can be checked by the
Controller. If the Host Controller checks the response error,
set this bit to 1 and set Response Interrupt Disable to 1. If an
error is detected, the Response Error interrupt is generated
in the Error Interrupt Status register.
Note:
- Response error check must not be enabled for any
response type other than R1 and R5.
Values:
- 0x0 (DISABLED): Response Error Check is disabled
- 0x1 (ENABLED): Response Error Check is enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_INT_DISABLE</name>
                <description>Response Interrupt Disable
The Host Controller supports response check function to
avoid overhead of response error check by the Host driver.
Response types of only R1 and R5 can be checked by the
Controller.
If Host Driver checks the response error, set this bit to 0 and
wait for Command Complete Interrupt and then check the
response register.
If the Host Controller checks the response error, set this bit
to 1 and set the Response Error Check Enable bit to 1. The
Command Complete Interrupt is disabled by this bit
regardless of the Command Complete Signal Enable.
Values:
- 0x0 (ENABLED): Response Interrupt is enabled
- 0x1 (DISABLED): Response Interrupt is disabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD_R</name>
            <description>Command register</description>
            <addressOffset>0xE</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FFF</resetMask>
            <fields>
              <field>
                <name>RESP_TYPE_SELECT</name>
                <description>Response Type Select
This bit indicates the type of response expected from the
card.
Values:
- 0x0 (NO_RESP): No Response
- 0x1 (RESP_LEN_136): Response Length 136
- 0x2 (RESP_LEN_48): Response Length 48
- 0x3 (RESP_LEN_48B): Response Length 48; Check
Busy after response</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SUB_CMD_FLAG</name>
                <description>Sub Command Flag
This bit distinguishes between a main command and a sub
command.
Values:
- 0x0 (MAIN): Main Command
- 0x1 (SUB): Sub Command</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_CHK_ENABLE</name>
                <description>Command CRC Check Enable
This bit enables the Host Controller to check the CRC field in
the response. If an error is detected, it is reported as a
Command CRC error.
Note:
- CRC Check enable must be set to 0 for the command
with no response, R3 response, and R4 response.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_CHK_ENABLE</name>
                <description>Command Index Check Enable
This bit enables the Host Controller to check the index field in
the response to verify if it has the same value as the
command index. If the value is not the same, it is reported as
a Command Index error.
Note:
- Index Check enable must be set to 0 for the command
with no response, R2 response, R3 response and R4
response.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_PRESENT_SEL</name>
                <description>Data Present Select
This bit is set to 1 to indicate that data is present and that the
data is transferred using the DAT line. This bit is set to 0 in
the following instances:
- Command using the CMD line
- Command with no data transfer but using busy signal on
the DAT[0] line
- Resume Command
Values:
- 0x0 (NO_DATA): No Data Present
- 0x1 (DATA): Data Present</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_TYPE</name>
                <description>Command Type
These bits indicate the command type.
Note: While issuing Abort CMD using CMD12/CMD52 or
reset CMD using CMD0/CMD52, CMD_TYPE field shall be
set to 0x3.
Values:
- 0x3 (ABORT_CMD): Abort
- 0x2 (RESUME_CMD): Resume
- 0x1 (SUSPEND_CMD): Suspend
- 0x0 (NORMAL_CMD): Normal</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_INDEX</name>
                <description>Command Index
These bits are set to the command number that is specified
in bits 45-40 of the Command Format.</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP01_R</name>
            <description>Response Register 0/1</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP01</name>
                <description>Command Response
These bits reflect 39-8 bits of SD/eMMC Response Field.
Note: For Auto CMD, the 32-bit response (bits 39-8 of the
Response Field) is updated in the RESP67_R register.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP23_R</name>
            <description>Response Register 2/3</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP23</name>
                <description>Command Response
These bits reflect 71-40 bits of the SD/eMMC Response</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP45_R</name>
            <description>Response Register 4/5</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP45</name>
                <description>Command Response
These bits reflect 103-72 bits of the Response Field.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RESP67_R</name>
            <description>Response Register 6/7</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP67</name>
                <description>Command Response
These bits reflect bits 135-104 of SD/EMMC Response
Field.
Note: For Auto CMD, this register also reflects the 32-bit
response (bits 39-8 of the Response Field).</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BUF_DATA_R</name>
            <description>Buffer Data Port Register</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>BUF_DATA</name>
                <description>Buffer Data
These bits enable access to the Host Controller packet
buffer.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PSTATE_REG</name>
            <description>Present State Register</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1BFF0FF7</resetMask>
            <fields>
              <field>
                <name>CMD_INHIBIT</name>
                <description>Command Inhibit (CMD)
This bit indicates the following :
- SD/eMMC mode: If this bit is set to 0, it indicates that the
CMD line is not in use and the Host controller can issue
an SD/eMMC command using the CMD line. This bit is
set when the command register is written. This bit is
cleared when the command response is received. This bit
is not cleared by the response of auto CMD12/23 but
cleared by the response of read/write command.
Values:
- 0x0 (READY): Host Controller is ready to issue a
command
- 0x1 (NOT_READY): Host Controller is not ready to issue
a command</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_INHIBIT_DAT</name>
                <description>Command Inhibit (DAT)
This bit is applicable for SD/eMMC mode and is generated if
either DAT line active or Read transfer active is set to 1. If
this bit is set to 0, it indicates that the Host Controller can
issue subsequent SD/eMMC commands.
Values:
- 0x0 (READY): Can issue command which used DAT line
- 0x1 (NOT_READY): Cannot issue command which used
DAT line</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAT_LINE_ACTIVE</name>
                <description>DAT Line Active (SD/eMMC Mode only)
This bit indicates whether one of the DAT lines on the
SD/eMMC bus is in use.
In the case of read transactions, this bit indicates whether a
read transfer is executing on the SD/eMMC bus.
In the case of write transactions, this bit indicates whether a
write transfer is executing on the SD/eMMC bus.
For a command with busy, this status indicates whether the
command executing busy is executing on an SD or eMMC
bus.
Values:
- 0x0 (INACTIVE): DAT Line Inactive
- 0x1 (ACTIVE): DAT Line Active</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAT_7_4</name>
                <description>DAT[7:4] Line Signal Level
This bit is used to check the DAT line level to recover from
errors and for debugging. These bits reflect the value of the
sd_dat_in (upper nibble) signal.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_XFER_ACTIVE</name>
                <description>Write Transfer Active
This status indicates whether a write transfer is active for
SD/eMMC mode.
Values:
- 0x0 (INACTIVE): No valid data
- 0x1 (ACTIVE): Transferring data</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RD_XFER_ACTIVE</name>
                <description>Read Transfer Active
This bit indicates whether a read transfer is active for
SD/eMMC mode.
Values:
- 0x0 (INACTIVE): No valid data
- 0x1 (ACTIVE): Transferring data</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUF_WR_ENABLE</name>
                <description>Buffer Write Enable
This bit is used for non-DMA transfers. This bit is set if space
is available for writing data.
Values:
- 0x0 (DISABLED): Write disable
- 0x1 (ENABLED): Write enable</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BUF_RD_ENABLE</name>
                <description>Buffer Read Enable
This bit is used for non-DMA transfers. This bit is set if valid
data exists in the Host buffer.
Values:
- 0x0 (DISABLED): Read disable
- 0x1 (ENABLED): Read enable</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CARD_INSERTED</name>
                <description>Card Inserted
This bit indicates whether a card has been inserted. The
Host Controller debounces this signal so that Host Driver
need not wait for it to stabilize.
Values:
- 0x0 (FALSE): Reset, Debouncing, or No card
- 0x1 (TRUE): Card Inserted</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CARD_STABLE</name>
                <description>Card Stable
This bit indicates the stability of the Card Detect Pin Level. A
card is not detected if this bit is set to 1 and the value of the
CARD_INSERTED bit is 0.
Values:
- 0x0 (FALSE): Reset or Debouncing
- 0x1 (TRUE): No Card or Inserted</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CARD_DETECT_PIN_LEVEL</name>
                <description>Card Detect Pin Level
This bit reflects the inverse synchronized value of the
card_detect_n signal.
Values:
- 0x0 (FALSE): No card present
- 0x1 (TRUE): Card Present</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>WR_PROTECT_SW_LVL</name>
                <description>Write Protect Switch Pin Level
This bit is supported only for memory and combo cards. This
bit reflects the synchronized value of the card_write_prot
signal.
Values:
- 0x0 (FALSE): Write protected
- 0x1 (TRUE): Write enabled</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DAT_3_0</name>
                <description>DAT[3:0] Line Signal Level
This bit is used to check the DAT line level to recover from
errors and for debugging. These bits reflect the value of the
sd_dat_in (lower nibble) signal.</description>
                <bitRange>[23:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_LINE_LVL</name>
                <description>Command-Line Signal Level
This bit is used to check the CMD line level to recover from
errors and for debugging. These bits reflect the value of the
sd_cmd_in signal.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HOST_REG_VOL</name>
                <description>Host Regulator Voltage Stable
This bit is used to check whether the host regulator voltage is
stable for switching the voltage of UHS-I mode. This bit
reflects the synchronized value of the host_reg_vol_stable
signal.
Values:
- 0x0 (FALSE): Host Regulator Voltage is not stable
- 0x1 (TRUE): Host Regulator Voltage is stable</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_ISSU_ERR</name>
                <description>Command Not Issued by Error
This bit is set if a command cannot be issued after setting
the command register due to an error except the Auto
CMD12 error.
Values:
- 0x0 (FALSE): No error for issuing a command
- 0x1 (TRUE): Command cannot be issued</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUB_CMD_STAT</name>
                <description>Sub Command Status
This bit is used to distinguish between a main command and
a sub command status.
Values:
- 0x0 (FALSE): Main Command Status
- 0x1 (TRUE): Sub Command Status</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTRL1_R</name>
            <description>Host Control 1 Register</description>
            <addressOffset>0x28</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>LED_CTRL</name>
                <description>LED Control
This bit is used to caution the user not to remove the card
while the SD card is being accessed. The value is reflected
on the led_ctrl ouput.
Values:
- 0x0 (OFF): LED off
- 0x1 (ON): LED on</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DAT_XFER_WIDTH</name>
                <description>Data Transfer Width
For SD/eMMC mode,this bit selects the data transfer width of
the Host Controller. The Host Driver sets it to match the data
width of the SD/eMMC card.
Values:
- 0x1 (FOUR_BIT): 4-bit mode
- 0x0 (ONE_BIT): 1-bit mode</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HIGH_SPEED_EN</name>
                <description>High Speed Enable (SD/eMMC Mode only)
Before setting this bit, the Host Driver checks the High Speed
Support in the Capabilities register.
Note: SDHC always outputs the sd_cmd_out and
sd_dat_out lines at the rising edge of card clock
irrespective of this bit.
Values:
- 0x1 (HIGH_SPEED): High Speed mode
- 0x0 (NORMAL_SPEED): Normal Speed mode</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_SEL</name>
                <description>N/A</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXT_DAT_XFER</name>
                <description>Extended Data Transfer Width
This bit controls 8-bit bus width mode of embedded device.
Values:
- 0x1 (EIGHT_BIT): 8-bit Bus Width
- 0x0 (DEFAULT): Bus Width is selected by the Data
Transfer Width</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_DETECT_TEST_LVL</name>
                <description>Card Detect Test Level
This bit is enabled while the Card Detect Signal Selection is
set to 1 and it indicates whether a card inserted or not.
Values:
- 0x1 (CARD_INSERTED): Card Inserted
- 0x0 (No_CARD): No Card</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_DETECT_SIG_SEL</name>
                <description>Card Detect Signal Selection
This bit selects a source for card detection. When the source
for the card detection is switched, the interrupt must be
disabled during the switching period.
Values:
- 0x1 (CARD_DT_TEST_LEVEL): Card Detect Test Level
is selected (for test purpose)
- 0x0 (card_detect_n): card_detect_n signal is
selected (for normal use)</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PWR_CTRL_R</name>
            <description>Power Control Register</description>
            <addressOffset>0x29</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>SD_BUS_PWR_VDD1</name>
                <description>SD Bus Power for VDD1
This bit enables VDD1 power of the card. This setting is
available on the card_if_pwr_en output so that it
can be used to control the VDD1 power supply of the card.
Before setting this bit, the SD Host Driver sets the SD Bus
Voltage Select bit. If the Host Controller detects a No Card
state, this bit is cleared.
In SD mode, if this bit is cleared, the Host Controller stops
the SD Clock by clearing the SD_CLK_IN bit in the
CLK_CTRL_R register.
Values:
- 0x0 (OFF): Power off
- 0x1 (ON): Power on</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SD_BUS_VOL_VDD1</name>
                <description>These bits are NON-operational (they can be written and read but they have no effect).  In a generic HCI host these would select the card supply voltage.  But, for the applications targeted for this block it is assumed that the card supply voltage is always fixed at the board level.  If for some reason there is a variable power supply then that can be managed through normal GPIO programming separately.</description>
                <bitRange>[3:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BGAP_CTRL_R</name>
            <description>Block Gap Control Register</description>
            <addressOffset>0x2A</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>STOP_BG_REQ</name>
                <description>Stop At Block Gap Request
This bit is used to stop executing read and write transactions
at the next block gap for non-DMA, SDMA, and ADMA
transfers.
Values:
- 0x0 (XFER): Transfer
- 0x1 (STOP): Stop</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CONTINUE_REQ</name>
                <description>Continue Request
This bit is used to restart the transaction, which was stopped
using the Stop At Block Gap Request. The Host Controller
automatically clears this bit when the transaction restarts. If
stop at block gap request is set to 1, any write to this bit is
ignored.
Values:
- 0x0 (NO_AFFECT): No Affect
- 0x1 (RESTART): Restart</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RD_WAIT_CTRL</name>
                <description>N/A</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_AT_BGAP</name>
                <description>Interrupt At Block Gap
This bit is valid only in the 4-bit mode of an SDIO card and is
used to select a sample point in the interrupt cycle. Setting to
1 enables interrupt detection at the block gap for a multiple
block transfer.
Values:
- 0x0 (DISABLE): Disabled
- 0x1 (ENABLE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WUP_CTRL_R</name>
            <description>Wakeup Control Register</description>
            <addressOffset>0x2B</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>WUP_CARD_INT</name>
                <description>Wakeup Event Enable on SDIO Card Interrupt (through DAT[1]).
This bit enables wakeup event through an SDIO Card Interrupt
assertion in the Normal Interrupt Status register. This bit can
be set to 1 if FN_WUS (Wake Up Support) in CIS is set to 1.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WUP_CARD_INSERT</name>
                <description>Wakeup Event Enable on SD Card Insertion
This bit enables wakeup event through Card Insertion
assertion in the Normal Interrupt Status register. FN_WUS
(Wake Up Support) in CIS does not affect this bit.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WUP_CARD_REMOVAL</name>
                <description>Wakeup Event Enable on SD Card Removal
This bit enables wakeup event through Card Removal
assertion in the Normal Interrupt Status register. For the
SDIO card, Wake Up Support (FN_WUS) in the Card
Information Structure (CIS) register does not affect this bit.
Values:
- 0x0 (DISABLED): Disable
- 0x1 (ENABLED): Enable</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CLK_CTRL_R</name>
            <description>Clock Control Register</description>
            <addressOffset>0x2C</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFEF</resetMask>
            <fields>
              <field>
                <name>INTERNAL_CLK_EN</name>
                <description>Internal Clock Enable
This bit is set to 0 when the Host Driver is not using the Host
Controller or the Host Controller awaits a wakeup interrupt.
The Host Controller must stop its internal clock to enter a
very low power state. Certain registers are not accessible when this bit is off.  So, to be safe turn it on for any register access.
Values:
- 0x0 (FALSE): Stop
- 0x1 (TRUE): Oscillate</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INTERNAL_CLK_STABLE</name>
                <description>Internal Clock Stable
This bit enables the Host Driver to check the clock stability
twice after the Internal Clock Enable bit is set and after the
PLL Enable bit is set. This bit reflects the synchronized
value of the Internal Clock Stable signal after the Internal Clock
Enable bit is set to 1 and also reflects the synchronized
value of the Card Clock Stable signal after the PLL Enable bit is
set to 1.
Values:
- 0x0 (FALSE): Not Ready
- 0x1 (TRUE): Ready</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SD_CLK_EN</name>
                <description>SD/eMMC Clock Enable
This bit stops the clk_card output when set to 0. The
SDCLK Frequency Select bit can be changed when
this bit is set to 0.
Values:
- 0x0 (FALSE): Disable providing clk_card
- 0x1 (TRUE): Enable providing clk_card</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PLL_ENABLE</name>
                <description>PLL Enable
This bit is used to activate the PLL (applicable when Host
Version 4 Enable = 1).
Values:
- 0x0 (FALSE): PLL is in low power mode
- 0x1 (TRUE): PLL is enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLK_GEN_SELECT</name>
                <description>Clock Generator Select
This bit is used to select the clock generator mode in
SDCLK Frequency Select.
Values:
- 0x0 (FALSE): Divided Clock Mode
- 0x1 (TRUE): Programmable Clock Mode</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UPPER_FREQ_SEL</name>
                <description>These bits specify the upper 2 bits of 10-bit SDCLK
Frequency Select control.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FREQ_SEL</name>
                <description>SDCLK Frequency Select
These bits are used to select the frequency of the SDCLK
signal.
10-bit Divided Clock Mode:
- 0x3FF - 1/2046 Divided clock
- ..........
- N - 1/2N Divided Clock
- ..........
- 0x002 - 1/4 Divided Clock
- 0x001 - 1/2 Divided Clock
- 0x000 - Base clock (10MHz - 255 MHz)</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TOUT_CTRL_R</name>
            <description>Timeout Control Register</description>
            <addressOffset>0x2E</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>TOUT_CNT</name>
                <description>N/A</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_RST_R</name>
            <description>Software Reset Register</description>
            <addressOffset>0x2F</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>SW_RST_ALL</name>
                <description>Software Reset For All
This reset affects the entire Host Controller except for the
card detection circuit. During its initialization, the Host Driver
sets this bit to 1 to reset the Host Controller. All registers are
reset except the capabilities register. If this bit is set to 1, the
Host Driver must issue reset command and reinitialize the
card.
Values:
- 0x0 (FALSE): Work
- 0x1 (TRUE): Reset</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_RST_CMD</name>
                <description>Software Reset For CMD line
This bit resets only a part of the command circuit to be able
to issue a command. This reset is effective only for a command
issuing circuit (including response error statuses related to
Command Inhibit (CMD) control) and does not affect the
data transfer circuit. Host Controller can continue data
transfer even after this reset is executed while handling
subcommand-response errors.
The following registers and bits are cleared by this bit:
- Present State register - Command Inhibit (CMD) bit
- Normal Interrupt Status register - Command Complete bit
- Error Interrupt Status - Response error statuses related
to Command Inhibit (CMD) bit
Values:
- 0x0 (FALSE): Work
- 0x1 (TRUE): Reset</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_RST_DAT</name>
                <description>Software Reset For DAT line
This bit is used in SD/eMMC mode and it resets only a part
of the data circuit and the DMA circuit is also reset.
The following registers and bits are cleared by this bit:
- Buffer Data Port register
- Buffer is cleared and initialized.
- Present state register
- Buffer Read Enable
- Buffer Write Enable
- Read Transfer Active
- Write Transfer Active
- DAT Line Active
- Command Inhibit (DAT)
- Block Gap Control register
- Continue Request
- Stop At Block Gap Request
- Normal Interrupt status register
- Buffer Read Ready
- Buffer Write Ready
- DMA Interrupt
- Block Gap Event
- Transfer Complete
Values:
- 0x0 (FALSE): Work
- 0x1 (TRUE): Reset</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NORMAL_INT_STAT_R</name>
            <description>Normal Interrupt Status Register</description>
            <addressOffset>0x30</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xE1FF</resetMask>
            <fields>
              <field>
                <name>CMD_COMPLETE</name>
                <description>Command Complete
In an SD/eMMC Mode, this bit is set when the end bit of a
response except for Auto CMD12 and Auto CMD23.
This interrupt is not generated when the Response Interrupt
Disable in Transfer Mode Register is set to 1.
Values:
- 0x0 (FALSE): No command complete
- 0x1 (TRUE): Command Complete</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XFER_COMPLETE</name>
                <description>Transfer Complete
This bit is set when a read/write transfer and a command
with status busy is completed.
Values:
- 0x0 (FALSE): Not complete
- 0x1 (TRUE): Command execution is completed</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGAP_EVENT</name>
                <description>Block Gap Event
This bit is set when both read/write transaction is stopped at
block gap due to a Stop at Block Gap Request.
Values:
- 0x0 (FALSE): No Block Gap Event
- 0x1 (TRUE): Transaction stopped at block gap</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_INTERRUPT</name>
                <description>DMA Interrupt
This bit is set if the Host Controller detects the SDMA Buffer
Boundary during transfer. In case of ADMA, by setting the Int
field in the descriptor table, the Host controller generates this
interrupt. This interrupt is not generated after a Transfer
Complete.
Values:
- 0x0 (FALSE): No DMA Interrupt
- 0x1 (TRUE): DMA Interrupt is generated</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_WR_READY</name>
                <description>Buffer Write Ready
This bit is set if the Buffer Write Enable changes from 0 to 1.
Values:
- 0x0 (FALSE): Not ready to write buffer
- 0x1 (TRUE): Ready to write buffer</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_RD_READY</name>
                <description>Buffer Read Ready
This bit is set if the Buffer Read Enable changes from 0 to 1.
Values:
- 0x0 (FALSE): Not ready to read buffer
- 0x1 (TRUE): Ready to read buffer</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INSERTION</name>
                <description>Card Insertion
This bit is set if the Card Inserted in the Present State
register changes from 0 to 1.
Values:
- 0x0 (FALSE): Card state stable or Debouncing
- 0x1 (TRUE): Card Inserted</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_REMOVAL</name>
                <description>Card Removal
This bit is set if the Card Inserted in the Present State
register changes from 1 to 0.
Values:
- 0x0 (FALSE): Card state stable or Debouncing
- 0x1 (TRUE): Card Removed</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INTERRUPT</name>
                <description>Card Interrupt
This bit reflects the synchronized value of:
- DAT[1] Interrupt Input for SD Mode
Values:
- 0x0 (FALSE): No Card Interrupt
- 0x1 (TRUE): Generate Card Interrupt</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FX_EVENT</name>
                <description>FX Event
This status is set when R[14] of response register is set to 1
and Response Type R1/R5 is set to 0 in Transfer Mode
register. This interrupt is used with response check function.
Values:
- 0x0 (FALSE): No Event
- 0x1 (TRUE): FX Event is detected</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CQE_EVENT</name>
                <description>Command Queuing Event
This status is set if Command Queuing/Crypto related event
has occurred in eMMC/SD mode. Read CQHCI's
CQIS/CRNQIS register for more details. In UHS-II Mode,
this bit is irrelevant.
Values:
- 0x0 (FALSE): No Event
- 0x1 (TRUE): Command Queuing Event is detected</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ERR_INTERRUPT</name>
                <description>Error Interrupt
If any of the bits in the Error Interrupt Status register are set,
then this bit is set.
Values:
- 0x0 (FALSE): No Error
- 0x1 (TRUE): Error</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ERROR_INT_STAT_R</name>
            <description>Error Interrupt Status Register</description>
            <addressOffset>0x32</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFF</resetMask>
            <fields>
              <field>
                <name>CMD_TOUT_ERR</name>
                <description>Command Timeout Error
In SD/eMMC Mode,this bit is set only if no response is
returned within 64 SD clock cycles from the end bit of the
command. If the Host Controller detects a CMD line conflict,
along with Command CRC Error bit, this bit is set to 1,
without waiting for 64 SD/eMMC card clock cycles.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Time out</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_ERR</name>
                <description>Command CRC Error
Command CRC Error is generated in SD/eMMC mode for
following two cases.
- If a response is returned and the Command Timeout
Error is set to 0 (indicating no timeout), this bit is set to 1
when detecting a CRC error in the command response.
- The Host Controller detects a CMD line conflict by
monitoring the CMD line when a command is issued. If
the Host Controller drives the CMD line to 1 level, but
detects 0 level on the CMD line at the next SD clock
edge, then the Host Controller aborts the command (stop
driving CMD line) and set this bit to 1. The Command
Timeout Error is also set to 1 to distinguish a CMD line
conflict.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): CRC error generated</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_END_BIT_ERR</name>
                <description>Command End Bit Error
This bit is set when detecting that the end bit of a command
response is 0 in SD/eMMC mode.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): End Bit error generated</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_ERR</name>
                <description>Command Index Error
This bit is set if a Command Index error occurs in the
command respons in SD/eMMC mode.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_TOUT_ERR</name>
                <description>Data Timeout Error
This bit is set in SD/eMMC mode when detecting one of the
following timeout conditions:
- Busy timeout for R1b, R5b type
- Busy timeout after Write CRC status
- Write CRC Status timeout
- Read Data timeout
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Time out</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_ERR</name>
                <description>Data CRC Error
This error occurs in SD/eMMC mode when detecting CRC
error when transferring read data which uses the DAT line,
when detecting the Write CRC status having a value of other
than 010 or when write CRC status timeout.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_END_BIT_ERR</name>
                <description>Data End Bit Error
This error occurs in SD/eMMC mode either when detecting 0
at the end bit position of read data that uses the DAT line or
at the end bit position of the CRC status.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CUR_LMT_ERR</name>
                <description>Current Limit Error
By setting the SD Bus Power bit in the Power Control
register, the Host Controller is requested to supply power for
the SD Bus. If the Host Controller supports the Current Limit
function, it can be protected from an illegal card by stopping
power supply to the card in which case this bit indicates a
failure status. A reading of 1 for this bit means that the Host
Controller is not supplying power to the SD card due to some
failure. A reading of 0 for this bit means that the Host
Controller is supplying power and no error has occurred. The
Host Controller may require some sampling time to detect
the current limit. DWC_mshc Host Controller does not
support this function, this bit is always set to 0.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Power Fail</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ERR</name>
                <description>Auto CMD Error
This error status is used by Auto CMD12 and Auto CMD23 in
SD/eMMC mode. This bit is set when detecting that any of
the bits D00 to D05 in Auto CMD Error Status register has
changed from 0 to 1. D07 is effective in case of Auto CMD12.
Auto CMD Error Status register is valid while this bit is set to
1 and may be cleared by clearing of this bit.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA_ERR</name>
                <description>ADMA Error
This bit is set when the Host Controller detects error during
ADMA-based data transfer. The error could be due to
following reasons:
- Error response received from System bus (Master I/F)
- ADMA3,ADMA2 Descriptors invalid
- CQE Task or Transfer descriptors invalid
When the error occurs, the state of the ADMA is saved in the
ADMA Error Status register.
In eMMC CQE mode:
The Host Controller generates this Interrupt when it detects
an invalid descriptor data (Valid=0) at the ST_FDS state.
ADMA Error State in the ADMA Error Status indicates that
an error has occurred in ST_FDS state. The Host Driver may
find that Valid bit is not set at the error descriptor.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TUNING_ERR</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR</name>
                <description>Response Error
Host Controller Version 4.00 supports response error check
function to avoid overhead of response error check by Host
Driver during DMA execution. If Response Error Check
Enable is set to 1 in the Transfer Mode register, Host
Controller Checks R1 or R5 response. If an error is detected
in a response, this bit is set to 1.This is applicable in
SD/eMMC mode.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_ACK_ERR</name>
                <description>Boot Acknowledgement Error
This bit is set when there is a timeout for boot
acknowledgement or when detecting boot ack status having
a value other than 010. This is applicable only when boot
acknowledgement is expected in eMMC mode.
In SD mode, this bit is irrelevant.
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NORMAL_INT_STAT_EN_R</name>
            <description>Normal Interrupt Status Enable Register</description>
            <addressOffset>0x34</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>CMD_COMPLETE_STAT_EN</name>
                <description>Command Complete Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XFER_COMPLETE_STAT_EN</name>
                <description>Transfer Complete Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGAP_EVENT_STAT_EN</name>
                <description>Block Gap Event Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_INTERRUPT_STAT_EN</name>
                <description>DMA Interrupt Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_WR_READY_STAT_EN</name>
                <description>Buffer Write Ready Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_RD_READY_STAT_EN</name>
                <description>Buffer Read Ready Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INSERTION_STAT_EN</name>
                <description>Card Insertion Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_REMOVAL_STAT_EN</name>
                <description>Card Removal Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INTERRUPT_STAT_EN</name>
                <description>Card Interrupt Status Enable
If this bit is set to 0, the Host Controller clears the interrupt
request to the System. The Card Interrupt detection is
stopped when this bit is cleared and restarted when this bit is
set to 1. The Host Driver may clear the Card Interrupt Status
Enable before servicing the Card Interrupt and may set this
bit again after all interrupt requests from the card are cleared
to prevent inadvertent interrupts.
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_A_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_B_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_C_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RE_TUNE_EVENT_STAT_EN</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FX_EVENT_STAT_EN</name>
                <description>FX Event Status Enable
This bit is added from Version 4.10.
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_EVENT_STAT_EN</name>
                <description>CQE Event Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ERROR_INT_STAT_EN_R</name>
            <description>Error Interrupt Status Enable Register</description>
            <addressOffset>0x36</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CMD_TOUT_ERR_STAT_EN</name>
                <description>Command Timeout Error Status Enable (SD/eMMC Mode
only).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_ERR_STAT_EN</name>
                <description>ommand CRC Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_END_BIT_ERR_STAT_EN</name>
                <description>Command End Bit Error Status Enable (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_ERR_STAT_EN</name>
                <description>Command Index Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_TOUT_ERR_STAT_EN</name>
                <description>Data Timeout Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_ERR_STAT_EN</name>
                <description>Data CRC Error Status Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_END_BIT_ERR_STAT_EN</name>
                <description>Data End Bit Error Status Enable (SD/eMMC Mode only).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CUR_LMT_ERR_STAT_EN</name>
                <description>Current Limit Error Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ERR_STAT_EN</name>
                <description>Auto CMD Error Status Enable (SD/eMMC Mode only).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA_ERR_STAT_EN</name>
                <description>ADMA Error Status Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TUNING_ERR_STAT_EN</name>
                <description>Tuning Error Status Enable (UHS-I Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR_STAT_EN</name>
                <description>Response Error Status Enable (SD Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_ACK_ERR_STAT_EN</name>
                <description>Boot Acknowledgment Error (eMMC Mode only)
Setting this bit to 1 enables setting of Boot Acknowledgment
Error in Error Interrupt Status register
(ERROR_INT_STAT_R).
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_STAT_EN1</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_STAT_EN2</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_STAT_EN3</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>NORMAL_INT_SIGNAL_EN_R</name>
            <description>Normal Interrupt Signal Enable Register</description>
            <addressOffset>0x38</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFF</resetMask>
            <fields>
              <field>
                <name>CMD_COMPLETE_SIGNAL_EN</name>
                <description>Command Complete Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>XFER_COMPLETE_SIGNAL_EN</name>
                <description>Transfer Complete Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BGAP_EVENT_SIGNAL_EN</name>
                <description>Block Gap Event Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DMA_INTERRUPT_SIGNAL_EN</name>
                <description>DMA Interrupt Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_WR_READY_SIGNAL_EN</name>
                <description>Buffer Write Ready Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_RD_READY_SIGNAL_EN</name>
                <description>Buffer Read Ready Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INSERTION_SIGNAL_EN</name>
                <description>Card Insertion Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_REMOVAL_SIGNAL_EN</name>
                <description>Card Removal Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_INTERRUPT_SIGNAL_EN</name>
                <description>Card Interrupt Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_A_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_B_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INT_C_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RE_TUNE_EVENT_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FX_EVENT_SIGNAL_EN</name>
                <description>FX Event Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_EVENT_SIGNAL_EN</name>
                <description>Command Queuing Engine Event Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ERROR_INT_SIGNAL_EN_R</name>
            <description>Error Interrupt Signal Enable Register</description>
            <addressOffset>0x3A</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CMD_TOUT_ERR_SIGNAL_EN</name>
                <description>Command Timeout Error Signal Enable (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_CRC_ERR_SIGNAL_EN</name>
                <description>Command CRC Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_END_BIT_ERR_SIGNAL_EN</name>
                <description>Command End Bit Error Signal Enable (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD_IDX_ERR_SIGNAL_EN</name>
                <description>Command Index Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): No error
- 0x1 (TRUE): Error</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_TOUT_ERR_SIGNAL_EN</name>
                <description>Data Timeout Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_CRC_ERR_SIGNAL_EN</name>
                <description>Data CRC Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_END_BIT_ERR_SIGNAL_EN</name>
                <description>Data End Bit Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CUR_LMT_ERR_SIGNAL_EN</name>
                <description>Current Limit Error Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_CMD_ERR_SIGNAL_EN</name>
                <description>Auto CMD Error Signal Enable (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA_ERR_SIGNAL_EN</name>
                <description>ADMA Error Signal Enable
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TUNING_ERR_SIGNAL_EN</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESP_ERR_SIGNAL_EN</name>
                <description>Response Error Signal Enable (SD Mode only)
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_ACK_ERR_SIGNAL_EN</name>
                <description>Boot Acknowledgment Error (eMMC Mode only).
Setting this bit to 1 enables generating interrupt signal when
Boot Acknowledgement Error in Error Interrupt Status
register is set.
Values:
- 0x0 (FALSE): Masked
- 0x1 (TRUE): Enabled</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_SIGNAL_EN1</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_SIGNAL_EN2</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VENDOR_ERR_SIGNAL_EN3</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>AUTO_CMD_STAT_R</name>
            <description>Auto CMD Status Register</description>
            <addressOffset>0x3C</addressOffset>
            <size>16</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xBF</resetMask>
            <fields>
              <field>
                <name>AUTO_CMD12_NOT_EXEC</name>
                <description>Auto CMD12 Not Executed
If multiple memory block data transfer is not started due to a
command error, this bit is not set because it is not necessary
to issue an Auto CMD12. Setting this bit to 1 means that the
Host Controller cannot issue Auto CMD12 to stop multiple
memory block data transfer, due to some error. If this bit is
set to 1, error status bits (D04-D01) is meaningless.
This bit is set to 0 when Auto CMD Error is generated by
Auto CMD23.
Values:
- 0x1 (TRUE): Not Executed
- 0x0 (FALSE): Executed</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_TOUT_ERR</name>
                <description>Auto CMD Timeout Error
This bit is set if no response is returned with 64 SDCLK
cycles from the end bit of the command.
If this bit is set to 1, error status bits (D04-D01) are
meaningless.
Values:
- 0x1 (TRUE): Time out
- 0x0 (FALSE): No Error</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_CRC_ERR</name>
                <description>Auto CMD CRC Error
This bit is set when detecting a CRC error in the command
response.
Values:
- 0x1 (TRUE): CRC Error Generated
- 0x0 (FALSE): No Error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_EBIT_ERR</name>
                <description>Auto CMD End Bit Error
This bit is set when detecting that the end bit of command
response is 0.
Values:
- 0x1 (TRUE): End Bit Error Generated
- 0x0 (FALSE): No Error</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_IDX_ERR</name>
                <description>Auto CMD Index Error
This bit is set if the command index error occurs in response
to a command.
Values:
- 0x1 (TRUE): Error
- 0x0 (FALSE): No Error</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AUTO_CMD_RESP_ERR</name>
                <description>Auto CMD Response Error
This bit is set when Response Error Check Enable in the
Transfer Mode register is set to 1 and an error is detected in
R1 response of either Auto CMD12 or CMD13. This status is
ignored if any bit between D00 to D04 is set to 1.
Values:
- 0x1 (TRUE): Error
- 0x0 (FALSE): No Error</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CMD_NOT_ISSUED_AUTO_CMD12</name>
                <description>Command Not Issued By Auto CMD12 Error
If this bit is set to 1, CMD_wo_DAT is not executed due to an
Auto CMD12 Error (D04-D01) in this register.
This bit is set to 0 when Auto CMD Error is generated by
Auto CMD23.
Values:
- 0x1 (TRUE): Not Issued
- 0x0 (FALSE): No Error</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CTRL2_R</name>
            <description>Host Control 2 Register</description>
            <addressOffset>0x3E</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFDFF</resetMask>
            <fields>
              <field>
                <name>UHS_MODE_SEL</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SIGNALING_EN</name>
                <description>1.8V Signaling Enable
This bit controls voltage regulator for I/O cell in SD UHS-I mode. Setting this bit from 0 to 1 starts changing the
signal voltage from 3.3V to 1.8V. Host Controller clears this
bit if switching to 1.8V signaling fails per protocol. The value is reflected on the io_volt_sel output which can then be used to change an external regulator to supply 1.8V instead of 3.3V on the VDDIO pin associated with the CLK/CMD/DAT signals.
Note: This bit must be set for all UHS-I speed modes
(SDR12/SDR25/SDR50/DDR50).
Values:
- 0x0 (V_3_3): 3.3V Signalling
- 0x1 (V_1_8): 1.8V Signalling</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DRV_STRENGTH_SEL</name>
                <description>Driver Strength Select
These bits are used to select the Host Controller output driver in
1.8V signaling UHS-I/eMMC speed modes. The value is reflected on the io_drive_strength[1:0] output.
- 0x0 (TYPEB): Driver TYPEB is selected
- 0x1 (TYPEA): Driver TYPEA is selected
- 0x2 (TYPEC): Driver TYPEC is selected
- 0x3 (TYPED): Driver TYPED is selected</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EXEC_TUNING</name>
                <description>N/A</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SAMPLE_CLK_SEL</name>
                <description>N/A</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UHS2_IF_ENABLE</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADMA2_LEN_MODE</name>
                <description>ADMA2 Length Mode
This bit selects ADMA2 Length mode to be either 16-bit or
26-bit.
Values:
- 0x0 (FALSE): 16-bit Data Length Mode
- 0x1 (TRUE): 26-bit Data Length Mode</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CMD23_ENABLE</name>
                <description>CMD23 Enable
If the card supports CMD23, this bit is set to 1. This bit is
used to select Auto CMD23 or Auto CMD12 for ADMA3 data
transfer.
Values:
- 0x0 (FALSE): Auto CMD23 is disabled
- 0x1 (TRUE): Auto CMD23 is enabled</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HOST_VER4_ENABLE</name>
                <description>Host Version 4 Enable
This bit selects either Version 3.00 compatible mode or
Version 4 mode.
Functions of following fields are modified for Host Version 4
mode:
- SDMA Address: SDMA uses ADMA System Address
(05Fh-058h) instead of SDMA System Address register
(003h-000h)
- ADMA2/ADMA3 selection: ADMA3 is selected by DMA
select in Host Control 1 register
- 32-bit Block Count: SDMA System Address register
(003h-000h) is modified to 32-bit Block Count register
Note: It is recommended not to program ADMA3 Integrated
Descriptor Address registers and
Command Queuing registers (if applicable) while operating
in Host version less than 4 mode (Host Version 4 Enable =
0).
Values:
- 0x0 (FALSE): Version 3.00 compatible mode
- 0x1 (TRUE): Version 4 mode</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ADDRESSING</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ASYNC_INT_ENABLE</name>
                <description>Asynchronous Interrupt Enable
This bit can be set if a card supports asynchronous
interrupts and Asynchronous Interrupt Support is set to 1 in
the Capabilities register.
Values:
- 0x0 (FALSE): Disabled
- 0x1 (TRUE): Enabled</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESET_VAL_ENABLE</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPABILITIES1_R</name>
            <description>Capabilities 1 Register - 0 to 31</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x276C6481</resetValue>
            <resetMask>0xFFEFFFBF</resetMask>
            <fields>
              <field>
                <name>TOUT_CLK_FREQ</name>
                <description>Timeout Clock Frequency
This bit shows the base clock frequency used to detect Data
Timeout Error. The Timeout Clock unit defines the unit of
timeout clock frequency. It can be KHz or MHz.
- 0x00 - Get information through another method
- 0x01 - 1KHz / 1MHz
- 0x02 - 2KHz / 2MHz
- 0x03 - 3KHz / 3MHz
- ...........
- 0x3F - 63KHz / 63MHz</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TOUT_CLK_UNIT</name>
                <description>Timeout Clock Unit
This bit shows the unit of base clock frequency used to
detect Data TImeout Error.
Values:
- 0x0 (KHZ): KHz
- 0x1 (MHZ): MHz</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>BASE_CLK_FREQ</name>
                <description>Base Clock Frequency for SD clock
These bits indicate the base (maximum) clock frequency for
the SD Clock. The definition of these bits depend on the Host
Controller Version.
- 6-Bit Base Clock Frequency: This mode is supported by
the Host Controller version 1.00 and 2.00. The upper 2
bits are not effective and are always 0. The unit values
are 1 MHz. The supported clock range is 10 MHz to 63
MHz.
- 0x00 - Get information through another method
- 0x01 - 1 MHz
- 0x02 - 2 MHz
- .............
- 0x3F - 63 MHz
- 0x40-0xFF - Not Supported
- 8-Bit Base Clock Frequency: This mode is supported by
the Host Controller version 3.00. The unit values are 1
MHz. The supported clock range is 10 MHz to 255 MHz.
- 0x00 - Get information through another method
- 0x01 - 1 MHz
- 0x02 - 2 MHz
- ............
- 0xFF - 255 MHz
If the frequency is 16.5 MHz, the larger value is set to
0001001b (17 MHz) because the Host Driver uses this value
to calculate the clock divider value and it does not exceed
the upper limit of the SD Clock frequency. If these bits are all
0, the Host system has to get information using a different
method.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_BLK_LEN</name>
                <description>N/A</description>
                <bitRange>[17:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EMBEDDED_8_BIT</name>
                <description>8-bit Support for Embedded Device
This bit indicates whether the Host Controller is capable of
using an 8-bit bus width mode. This bit is not effective when
the Slot Type is set to 10b.
Values:
- 0x0 (FALSE): 8-bit Bus Width not Supported
- 0x1 (TRUE): 8-bit Bus Width Supported</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ADMA2_SUPPORT</name>
                <description>ADMA2 Support
This bit indicates whether the Host Controller is capable of
using ADMA2.
Values:
- 0x0 (FALSE): ADMA2 not Supported
- 0x1 (TRUE): ADMA2 Supported</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HIGH_SPEED_SUPPORT</name>
                <description>High Speed Support
This bit indicates whether the Host Controller and the Host
System supports High Speed mode and they can supply the
SD Clock frequency from 25 MHz to 50 MHz.
Values:
- 0x0 (FALSE): High Speed not Supported
- 0x1 (TRUE): High Speed Supported</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SDMA_SUPPORT</name>
                <description>SDMA Support
This bit indicates whether the Host Controller is capable of
using SDMA to transfer data between the system memory
and the Host Controller directly.
Values:
- 0x0 (FALSE): SDMA not Supported
- 0x1 (TRUE): SDMA Supported</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SUS_RES_SUPPORT</name>
                <description>Suspense/Resume Support
This bit indicates whether the Host Controller supports
Suspend/Resume functionality. If this bit is 0, the Host Driver
does not issue either Suspend or Resume commands
because the Suspend and Resume mechanism is not
supported.
Values:
- 0x0 (FALSE): Not Supported
- 0x1 (TRUE): Supported</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VOLT_33</name>
                <description>Voltage Support 3.3V
Values:
- 0x0 (FALSE): 3.3V Not Supported
- 0x1 (TRUE): 3.3V Supported</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VOLT_30</name>
                <description>Voltage Support 3.0V
Values:
- 0x0 (FALSE): 3.0V Not Supported
- 0x1 (TRUE): 3.0V Supported</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VOLT_18</name>
                <description>Voltage Support 1.8V
Values:
- 0x0 (FALSE): 1.8V Not Supported
- 0x1 (TRUE): 1.8V Supported</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SYS_ADDR_64_V4</name>
                <description>64-bit System Address Support for V4
This bit sets the Host Controller to support 64-bit System
Addressing of V4 mode. When this bit is set to 1, full or part
of 64-bit address must be used to decode the Host Controller
Registers so that Host Controller Registers can be placed
above system memory area. 64-bit address decode of Host
Controller registers is effective regardless of setting to 64-bit
Addressing in Host Control 2.
If this bit is set to 1, 64-bit DMA Addressing for version 4 is
enabled by setting Host Version 4 Enable
(HOST_VER4_ENABLE = 1) and by setting 64-bit
Addressing (ADDRESSING =1) in the Host Control 2
register. SDMA can be used and ADMA2 uses 128-bit
Descriptor.
Values:
- 0x0 (FALSE): 64-bit System Address for V4 is Not
Supported
- 0x1 (TRUE): 64-bit System Address for V4 is Supported</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SYS_ADDR_64_V3</name>
                <description>64-bit System Address Support for V3
This bit sets the Host controller to support 64-bit System
Addressing of V3 mode.
SDMA cannot be used in 64-bit Addressing in Version 3
Mode.
If this bit is set to 1, 64-bit ADMA2 with using 96-bit
Descriptor can be enabled by setting Host Version 4 Enable
(HOST_VER4_ENABLE = 0) and DMA select (DMA_SEL =
11b).
Values:
- 0x0 (FALSE): 64-bit System Address for V3 is Not
Supported
- 0x1 (TRUE): 64-bit System Address for V3 is Supported</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ASYNC_INT_SUPPORT</name>
                <description>Asynchronous Interrupt Support (SD Mode only)
Values:
- 0x0 (FALSE): Asynchronous Interrupt Not Supported
- 0x1 (TRUE): Asynchronous Interrupt Supported</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SLOT_TYPE_R</name>
                <description>Slot Type
These bits indicate usage of a slot by a specific Host
System.
Values:
- 0x0 (REMOVABLE_SLOT): Removable Card Slot
- 0x1 (EMBEDDED_SLOT): Embedded Slot for one Device
- 0x2 (SHARED_SLOT): Shared Bus Slot (SD mode)
- 0x3 (UHS2_EMBEDDED_SLOT): UHS-II Multiple
Embedded Devices</description>
                <bitRange>[31:30]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CAPABILITIES2_R</name>
            <description>Capabilities Register - 32 to 63</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x8000077</resetValue>
            <resetMask>0x18FFEF7F</resetMask>
            <fields>
              <field>
                <name>SDR50_SUPPORT</name>
                <description>SDR50 Support (UHS-I only)
Thsi bit indicates that SDR50 is supported. The bit 13
(USE_TUNING_SDR50) indicates whether SDR50 requires
tuning or not.
Values:
- 0x0 (FALSE): SDR50 is not supported
- 0x1 (TRUE): SDR50 is supported</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>SDR104_SUPPORT</name>
                <description>SDR104 Support (UHS-I only)
This bit mentions that SDR104 requires tuning.
Values:
- 0x0 (FALSE): SDR104 is not supported
- 0x1 (TRUE): SDR104 is supported (NOT ACTUALLY SUPPORTED)</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DDR50_SUPPORT</name>
                <description>DDR50 Support (UHS-I only)
Values:
- 0x0 (FALSE): DDR50 is not supported
- 0x1 (TRUE): DDR50 is supported</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>UHS2_SUPPORT</name>
                <description>UHS-II Support (UHS-II only)
This bit indicates whether Host Controller supports UHS-II.
Values:
- 0x0 (FALSE): UHS-II is not supported
- 0x1 (TRUE): UHS-II is supported</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DRV_TYPEA</name>
                <description>Driver Type A Support (UHS-I only)
This bit indicates support of Driver Type A for 1.8 Signaling.
Values:
- 0x0 (FALSE): Driver Type A is not supported
- 0x1 (TRUE): Driver Type A is supported</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DRV_TYPEC</name>
                <description>Driver Type C Support (UHS-I only)
This bit indicates support of Driver Type C for 1.8 Signaling.
Values:
- 0x0 (FALSE): Driver Type C is not supported
- 0x1 (TRUE): Driver Type C is supported</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DRV_TYPED</name>
                <description>Driver Type D Support (UHS-I only)
This bit indicates support of Driver Type D for 1.8 Signaling.
Values:
- 0x0 (FALSE): Driver Type D is not supported
- 0x1 (TRUE): Driver Type D is supported</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RETUNE_CNT</name>
                <description>N/A</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>USE_TUNING_SDR50</name>
                <description>Use Tuning for SDR50 (UHS-I only)
Values:
- 0x0 (ZERO): SDR50 does not require tuning
- 0x1 (ONE): SDR50 requires tuning</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RE_TUNING_MODES</name>
                <description>N/A</description>
                <bitRange>[15:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CLK_MUL</name>
                <description>Clock Multiplier
These bits indicate the clock multiplier of the programmable
clock generator. Setting these bits to 0 means that the Host
Controller does not support a programmable clock generator.
- 0x0: Clock Multiplier is not Supported
- 0x1: Clock Multiplier M = 2
- 0x2: Clock Multiplier M = 3
- .........
- 0xFF: Clock Multiplier M = 256</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ADMA3_SUPPORT</name>
                <description>ADMA3 Support
This bit indicates whether the Host Controller is capable of
using ADMA3.
Values:
- 0x0 (FALSE): ADMA3 not Supported
- 0x1 (TRUE): ADMA3 Supported</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VDD2_18V_SUPPORT</name>
                <description>1.8V VDD2 Support
This bit indicates support of VDD2 for the Host System.
Values:
- 0x0 (FALSE): 1.8V VDD2 is not Supported
- 0x1 (TRUE): 1.8V VDD2 is Supported</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR_CAPABILITIES1_R</name>
            <description>Current Capabilities Register - 0 to 31</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>MAX_CUR_33V</name>
                <description>Maximum Current for 3.3V
This bit specifies the Maximum Current for 3.3V VDD1 power
supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_CUR_30V</name>
                <description>Maximum Current for 3.0V
This bit specifies the Maximum Current for 3.0V VDD1 power
supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>MAX_CUR_18V</name>
                <description>Maximum Current for 1.8V
This bit specifies the Maximum Current for 1.8V VDD1 power
supply for the card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CURR_CAPABILITIES2_R</name>
            <description>Maximum Current Capabilities Register - 32 to 63</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>MAX_CUR_VDD2_18V</name>
                <description>Maximum Current for 1.8V VDD2
This bit specifies the Maximum Current for 1.8V VDD2 power
supply for the UHS-II card.
- 0: Get information through another method
- 1: 4mA
- 2: 8mA
- 3: 13mA
- .......
- 255: 1020mA</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FORCE_AUTO_CMD_STAT_R</name>
            <description>Force Event Register for Auto CMD Error Status register</description>
            <addressOffset>0x50</addressOffset>
            <size>16</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xBF</resetMask>
            <fields>
              <field>
                <name>FORCE_AUTO_CMD12_NOT_EXEC</name>
                <description>Force Event for Auto CMD12 Not Executed
Values:
- 0x1 (TRUE): Auto CMD12 Not Executed Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[0:0]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_TOUT_ERR</name>
                <description>Force Event for Auto CMD Timeout Error
Values:
- 0x1 (TRUE): Auto CMD Timeout Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[1:1]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_CRC_ERR</name>
                <description>Force Event for Auto CMD CRC Error
Values:
- 0x1 (TRUE): Auto CMD CRC Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[2:2]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_EBIT_ERR</name>
                <description>Force Event for Auto CMD End Bit Error
Values:
- 0x1 (TRUE): Auto CMD End Bit Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[3:3]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_IDX_ERR</name>
                <description>Force Event for Auto CMD Index Error
Values:
- 0x1 (TRUE): Auto CMD Index Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[4:4]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_RESP_ERR</name>
                <description>Force Event for Auto CMD Response Error
Values:
- 0x1 (TRUE): Auto CMD Response Error Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[5:5]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>FORCE_CMD_NOT_ISSUED_AUTO_CMD12</name>
                <description>Force Event for Command Not Issued By Auto CMD12 Error
Values:
- 0x1 (TRUE): Command Not Issued By Auto CMD12 Error
Status is set
- 0x0 (FALSE): Not Affected</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FORCE_ERROR_INT_STAT_R</name>
            <description>Force Event Register for Error Interrupt Status</description>
            <addressOffset>0x52</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>FORCE_CMD_TOUT_ERR</name>
                <description>Force Event for Command Timeout Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command Timeout Error Status is set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CMD_CRC_ERR</name>
                <description>Force Event for Command CRC Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command CRC Error Status is set</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CMD_END_BIT_ERR</name>
                <description>Force Event for Command End Bit Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command End Bit Error Status is set</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CMD_IDX_ERR</name>
                <description>Force Event for Command Index Error (SD/eMMC Mode
only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Command Index Error Status is set</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DATA_TOUT_ERR</name>
                <description>Force Event for Data Timeout Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Data Timeout Error Status is set</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DATA_CRC_ERR</name>
                <description>Force Event for Data CRC Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Data CRC Error Status is set</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_DATA_END_BIT_ERR</name>
                <description>Force Event for Data End Bit Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Data End Bit Error Status is set</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_CUR_LMT_ERR</name>
                <description>Force Event for Current Limit Error
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Current Limit Error Status is set</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_AUTO_CMD_ERR</name>
                <description>Force Event for Auto CMD Error (SD/eMMC Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Auto CMD Error Status is set</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_ADMA_ERR</name>
                <description>Force Event for ADMA Error
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): ADMA Error Status is set</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_TUNING_ERR</name>
                <description>Force Event for Tuning Error (UHS-I Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Tuning Error Status is set</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_RESP_ERR</name>
                <description>Force Event for Response Error (SD Mode only)
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Response Error Status is set</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_BOOT_ACK_ERR</name>
                <description>Force Event for Boot Ack error
Values:
- 0x0 (FALSE): Not Affected
- 0x1 (TRUE): Boot ack Error Status is set</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_VENDOR_ERR1</name>
                <description>N/A</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_VENDOR_ERR2</name>
                <description>N/A</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FORCE_VENDOR_ERR3</name>
                <description>N/A</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADMA_ERR_STAT_R</name>
            <description>ADMA Error Status Register</description>
            <addressOffset>0x54</addressOffset>
            <size>8</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>ADMA_ERR_STATES</name>
                <description>ADMA Error States
These bits indicate the state of ADMA when an error occurs
during ADMA data transfer.
Values:
- 0x0 (ST_STOP): Stop DMA - SYS_ADR register points to
a location next to the error descriptor
- 0x1 (ST_FDS): Fetch Descriptor - SYS_ADR register
points to the error descriptor
- 0x2 (UNUSED): Never set this state
- 0x3 (ST_TFR): Transfer Data - SYS_ADR register points
to a location next to the error descriptor</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ADMA_LEN_ERR</name>
                <description>ADMA Length Mismatch Error States
This error occurs in the following instances:
- While the Block Count Enable is being set, the total data
length specified by the Descriptor table is different from
that specified by the Block Count and Block Length
- When the total data length cannot be divided by the block
length
Values:
- 0x0 (NO_ERR): No Error
- 0x1 (ERROR): Error</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADMA_SA_LOW_R</name>
            <description>ADMA System Address Register - Low</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADMA_SA_LOW</name>
                <description>ADMA System Address
These bits indicate the lower 32 bits of the ADMA system
address.
- SDMA: If Host Version 4 Enable is set to 1, this register
stores the system address of the data location
- ADMA2: This register stores the byte address of the
executing command of the descriptor table
- ADMA3: This register is set by ADMA3. ADMA2
increments the address of this register that points to the
next line, every time a Descriptor line is fetched.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>ADMA_ID_LOW_R</name>
            <description>ADMA3 Integrated Descriptor Address Register - Low</description>
            <addressOffset>0x78</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>ADMA_ID_LOW</name>
                <description>ADMA Integrated Descriptor Address
These bits indicate the lower 32-bit of the ADMA Integrated
Descriptor address. The start address of Integrated
Descriptor is set to these register bits. The ADMA3 fetches
one Descriptor Address and increments these bits to indicate
the next Descriptor address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>HOST_CNTRL_VERS_R</name>
            <description>Host Controller Version</description>
            <addressOffset>0xFE</addressOffset>
            <size>16</size>
            <access>read-only</access>
            <resetValue>0x5</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SPEC_VERSION_NUM</name>
                <description>N/A</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>VENDOR_VERSION_NUM</name>
                <description>N/A</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQVER</name>
            <description>Command Queuing Version register</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x510</resetValue>
            <resetMask>0xFFF</resetMask>
            <fields>
              <field>
                <name>EMMC_VER_SUFFIX</name>
                <description>This bit indicates the eMMC version suffix (2nd digit right of
decimal point) in BCD format.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EMMC_VER_MINOR</name>
                <description>This bit indicates the eMMC minor version (1st digit right of
decimal point) in BCD format.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EMMC_VER_MAJOR</name>
                <description>This bit indicates the eMMC major version (1st digit left of
decimal point) in BCD format.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCAP</name>
            <description>Command Queuing Capabilities register</description>
            <addressOffset>0x184</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x30C8</resetValue>
            <resetMask>0x1000F3FF</resetMask>
            <fields>
              <field>
                <name>ITCFVAL</name>
                <description>Internal Timer Clock Frequency Value (ITCFVAL)
This field scales the frequency of the timer clock provided by
ITCFMUL. The Final clock frequency of actual timer clock is
calculated as ITCFVAL* ITCFMUL.</description>
                <bitRange>[9:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ITCFMUL</name>
                <description>N/A</description>
                <bitRange>[15:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CRYPTO_SUPPORT</name>
                <description>Crypto Support
This bit indicates whether the Host Controller supports
cryptographic operations.
Values:
- 0x0 (FALSE): Crypto not Supported
- 0x1 (TRUE): Crypto Supported</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCFG</name>
            <description>Command Queuing Configuration register</description>
            <addressOffset>0x188</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1103</resetMask>
            <fields>
              <field>
                <name>CQ_EN</name>
                <description>Enable command queuing engine (CQE).
When CQE is disable, the software controls the eMMC bus
using the registers between the addresses 0x000 to 0x1FF.
Before the software writes to this bit, the software verifies
that the eMMC host controller is in idle state and there are no
ongoing commands or data transfers. When software wants
to exit command queuing mode, it clears all previous tasks (if
any) before setting this bit to 0.
Values:
- 0x1 (CQE_ENABLE): Enable command queuing
- 0x0 (CQE_DISABLE): Disable command queuing</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CR_GENERAL_EN</name>
                <description>N/A</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TASK_DESC_SIZE</name>
                <description>Bit Value Description
This bit indicates the size of task descriptor used in host
memory. This bit can only be configured when Command
Queuing Enable bit is 0 (command queuing is disabled).
Values:
- 0x1 (TASK_DESC_128b): Task descriptor size is 128 bits
- 0x0 (TASK_DESC_64b): Task descriptor size is 64 bits</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DCMD_EN</name>
                <description>This bit indicates to the hardware whether the Task
Descriptor in slot #31 of the TDL is a data transfer descriptor
or a direct-command descriptor. CQE uses this bit when a
task is issued in slot #31, to determine how to decode the
Task Descriptor.
Values:
- 0x1 (SLOT31_DCMD_ENABLE): Task descriptor in slot
#31 is a DCMD Task Descriptor
- 0x0 (SLOT31_DCMD_DISABLE): Task descriptor in slot
#31 is a data Transfer Task Descriptor</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCTL</name>
            <description>Command Queuing Control register</description>
            <addressOffset>0x18C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x101</resetMask>
            <fields>
              <field>
                <name>HALT</name>
                <description>Halt request and resume
Values:
- 0x1 (HALT_CQE): Software writes 1 to this bit when it
wants to acquire software control over the eMMC bus and
to disable CQE from issuing command on the bus.
For example, issuing a Discard Task command
(CMDQ_TASK_MGMT). When the software writes 1, CQE
completes the ongoing task (if any in progress). After the
task is completed and the CQE is in idle state, CQE does not
issue new commands and indicates to the software by
setting this bit to 1. The software can poll on this bit until it is
set to 1 and only then send commands on the eMMC bus.
- 0x0 (RESUME_CQE): Software writes 0 to this bit to exit
from the halt state and resume CQE activity.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLR_ALL_TASKS</name>
                <description>Clear all tasks
This bit can only be written when the controller is halted. This
bit does not clear tasks in the device. The software has to
use the CMDQ_TASK_MGMT command to clear device's
queue.
Values:
- 0x1 (CLEAR_ALL_TASKS): Clears all the tasks in the
controller
- 0x0 (NO_EFFECT): Programming 0 has no effect</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQIS</name>
            <description>Command Queuing Interrupt Status register</description>
            <addressOffset>0x190</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>HAC</name>
                <description>Halt complete interrupt
This status bit is asserted (only if CQISE.HAC_STE=1) when
halt bit in the CQCTL register transitions from 0 to 1
indicating that the host controller has completed its current
ongoing task and has entered halt state. A value of 1 clears
this status bit.
Values:
- 0x1 (SET): HAC Interrupt is set
- 0x0 (NOTSET): HAC Interrupt is not set</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCC</name>
                <description>Task complete interrupt
This status bit is asserted (if CQISE.TCC_STE=1) when at
least one of the following conditions are met:
- A task is completed and the INT bit is set in its Task
Descriptor
- Interrupt caused by Interrupt Coalescing logic due to
timeout
- Interrupt Coalescing logic reached the configured
threshold
A value of 1 clears this status bit
Values:
- 0x1 (SET): TCC Interrupt is set
- 0x0 (NOTSET): TCC Interrupt is not set</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED</name>
                <description>Response error detected interrupt
This status bit is asserted (if CQISE.RED_STE=1) when a
response is received with an error bit set in the device status
field. Configure the CQRMEM register to identify device
status bit fields that may trigger an interrupt and that are
masked. A value of 1 clears this status bit.
Values:
- 0x1 (SET): RED Interrupt is set
- 0x0 (NOTSET): RED Interrupt is not set</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCL</name>
                <description>Task cleared interrupt
This status bit is asserted (if CQISE.TCL_STE=1) when a
task clear operation is completed by CQE. The completed
task clear operation is either an individual task clear (by
writing CQTCLR) or clearing of all tasks (by writing CQCTL).
A value of 1 clears this status bit.
Values:
- 0x1 (SET): TCL Interrupt is set
- 0x0 (NOTSET): TCL Interrupt is not set</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GCE</name>
                <description>N/A</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICCE</name>
                <description>N/A</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQISE</name>
            <description>Command Queuing Interrupt Status Enable register</description>
            <addressOffset>0x194</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>HAC_STE</name>
                <description>Halt complete interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.HAC is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.HAC is disabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCC_STE</name>
                <description>Task complete interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.TCC is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.TCC is disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_STE</name>
                <description>Response error detected interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.RED is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.RED is disabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCL_STE</name>
                <description>Task cleared interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.TCL is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.TCL is disabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GCE_STE</name>
                <description>General Crypto Error interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.GCE is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.GCE is disabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICCE_STE</name>
                <description>Invalid Crypto Configuration Error interrupt status enable
Values:
- 0x1 (INT_STS_ENABLE): CQIS.ICCE is set when its
interrupt condition is active
- 0x0 (INT_STS_DISABLE): CQIS.ICCE is disabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQISGE</name>
            <description>Command Queuing Interrupt signal enable register</description>
            <addressOffset>0x198</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>HAC_SGE</name>
                <description>Halt complete interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.HAC interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.HAC interrupt signal
generation is disabled</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCC_SGE</name>
                <description>Task complete interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.TCC interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.TCC interrupt signal
generation is disabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RED_SGE</name>
                <description>Response error detected interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.RED interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.RED interrupt signal
generation is disabled</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TCL_SGE</name>
                <description>Task cleared interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.TCL interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.TCL interrupt signal
generation is disabled</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GCE_SGE</name>
                <description>General Crypto Error interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.GCE interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.GCE interrupt signal
generation is disabled</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ICCE_SGE</name>
                <description>Invalid Crypto Configuration Error interrupt signal enable
Values:
- 0x1 (INT_SIG_ENABLE): CQIS.ICCE interrupt signal
generation is active
- 0x0 (INT_SIG_DISABLE): CQIS.ICCE interrupt signal
generation is disabled</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQIC</name>
            <description>Command Queuing Interrupt Coalescing register</description>
            <addressOffset>0x19C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80119FFF</resetMask>
            <fields>
              <field>
                <name>TOUT_VAL</name>
                <description>Interrupt Coalescing Timeout Value
Software uses this field to configure the maximum time
allowed between the completion of a task on the bus and the
generation of an interrupt.
Timer Operation: The timer is reset by software during the
interrupt service routine. It starts running when the first data
transfer task with INT=0 is completed, after the timer was
reset. When the timer reaches the value configured in
ICTOVAL field, it generates an interrupt and stops.
The timer's unit is equal to 1024 clock periods of the clock
whose frequency is specified in the Internal Timer Clock
Frequency field CQCAP register.
- 0x0: Timer is disabled. Timeout-based interrupt is not
generated
- 0x1: Timeout on 01x1024 cycles of timer clock frequency
- 0x2: Timeout on 02x1024 cycles of timer clock frequency
- ........
- 0x7f: Timeout on 127x1024 cycles of timer clock
frequency
In order to write to this field, the TOUT_VAL_WEN bit must
be set at the same write operation.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TOUT_VAL_WEN</name>
                <description>When software writes 1 to this bit, the value TOUT_VAL is
updated with the contents written on the same cycle.
Values:
- 0x1 (WEN_SET): Sets TOUT_VAL_WEN
- 0x0 (WEN_CLR): clears TOUT_VAL_WEN</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_TH</name>
                <description>Interrupt Coalescing Counter Threshold filed
Software uses this field to configure the number of task
completions (only tasks with INT=0 in the Task Descriptor),
which are required in order to generate an interrupt.
Counter Operation: As data transfer tasks with INT=0
complete, they are counted by CQE. The counter is reset by
software during the interrupt service routine. The counter
stops counting when it reaches the value configured in
INTC_TH, and generates interrupt.
- 0x0: Interrupt coalescing feature disabled
- 0x1: Interrupt coalescing interrupt generated after 1 task
when INT=0 completes
- 0x2: Interrupt coalescing interrupt generated after 2 tasks
when INT=0 completes
- ........
- 0x1f: Interrupt coalescing interrupt generated after 31
tasks when INT=0 completes
To write to this field, the INTC_TH_WEN bit must be set
during the same write operation.</description>
                <bitRange>[12:8]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_TH_WEN</name>
                <description>Interrupt Coalescing Counter Threshold Write Enable
When software writes 1 to this bit, the value INTC_TH is
updated with the contents written on the same cycle.
Values:
- 0x1 (WEN_SET): Sets INTC_TH_WEN
- 0x0 (WEN_CLR): Clears INTC_TH_WEN</description>
                <bitRange>[15:15]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_RST</name>
                <description>Counter and Timer Reset
When host driver writes 1, the interrupt coalescing timer and
counter are reset.
Values:
- 0x1 (ASSERT_INTC_RESET): Interrupt coalescing timer
and counter are reset
- 0x0 (NO_EFFECT): No Effect</description>
                <bitRange>[16:16]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>INTC_STAT</name>
                <description>Interrupt Coalescing Status Bit
This bit indicates to the software whether any tasks (with
INT=0) have completed and counted towards interrupt
coalescing (that is, this is set if and only if INTC counter &gt; 0).
Values:
- 0x1 (INTC_ATLEAST1_COMP): At least one INT0 task
completion has been counted (INTC counter &gt; 0)
- 0x0 (INTC_NO_TASK_COMP): INT0 Task completions
have not occurred since last counter reset (INTC counter
== 0)</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>INTC_EN</name>
                <description>Interrupt Coalescing Enable Bit
Values:
- 0x1 (ENABLE_INT_COALESCING): Interrupt coalescing
mechanism is active. Interrupts are counted and timed,
and coalesced interrupts are generated
- 0x0 (DISABLE_INT_COALESCING): Interrupt coalescing
mechanism is disabled (Default).</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTDLBA</name>
            <description>Command Queuing Task Descriptor List Base Address register</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TDLBA</name>
                <description>This register stores the LSB bits (31:0) of the byte address of
the head of the Task Descriptor List in system memory.
The size of the task descriptor list is 32 * (Task Descriptor
size + Transfer Descriptor size) as configured by the host
driver. This address is set on 1 KB boundary. The lower 10
bits of this register are set to 0 by the software and are
ignored by CQE.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTDBR</name>
            <description>Command Queuing DoorBell register</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DBR</name>
                <description>The software configures TDLBA and TDLBAU, and enable
CQE in CQCFG before using this register.
Writing 1 to bit n of this register triggers CQE to start
processing the task encoded in slot n of the TDL. Writing 0
by the software does not have any impact on the hardware,
and does not change the value of the register bit.
CQE always processes tasks according to the order
submitted to the list by CQTDBR write transactions. CQE
processes Data Transfer tasks by reading the Task
Descriptor and sending QUEUED_TASK_PARAMS (CMD44)
and QUEUED_TASK_ADDRESS (CMD45) commands to
the device. CQE processes DCMD tasks (in slot #31, when
enabled) by reading the Task Descriptor, and generating the
command encoded by its index and argument.
The corresponding bit is cleared to 0 by CQE in one of the
following events:
- A task execution is completed (with success or error).
- The task is cleared using CQTCLR register.
- All tasks are cleared using CQCTL register.
- CQE is disabled using CQCFG register.
Software may initiate multiple tasks at the same time (batch
submission) by writing 1 to multiple bits of this register in the
same transaction. In the case of batch submission, CQE
processes the tasks in order of the task index, starting with
the lowest index. If one or more tasks in the batch are
marked with QBR, the ordering of execution is based on said
processing order.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTCN</name>
            <description>Command Queuing TaskClear Notification register</description>
            <addressOffset>0x1AC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCN</name>
                <description>Task Completion Notification
Each of the 32 bits are bit mapped to the 32 tasks.
- Bit-N(1): Task-N has completed execution (with success
or errors)
- Bit-N(0): Task-N has not completed, could be pending or
not submitted.
On task completion, software may read this register to know
tasks that have completed. After reading this register,
software may clear the relevant bit fields by writing 1 to the
corresponding bits.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQDQS</name>
            <description>Device queue status register</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DQS</name>
                <description>Device Queue Status
Each of the 32 bits are bit mapped to the 32 tasks.
- Bit-N(1): Device has marked task N as ready for
execution
- Bit-N(0): Task-N is not ready for execution. This task
could be pending in device or not submitted.
Host controller updates this register with response of the
Device Queue Status command.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQDPT</name>
            <description>Device pending tasks register</description>
            <addressOffset>0x1B4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DPT</name>
                <description>Device-Pending Tasks
Each of the 32 bits are bit mapped to the 32 tasks.
- Bit-N(1): Task-N has been successfully queued into the
device and is awaiting execution
- Bit-N(0): Task-N is not yet queued.
Bit n of this register is set if and only if
QUEUED_TASK_PARAMS (CMD44) and
QUEUED_TASK_ADDRESS (CMD45) were sent for this
specific task and if this task has not been executed.
The controller sets this bit after receiving a successful
response for CMD45. CQE clears this bit after the task has
completed execution.
Software reads this register in the task-discard procedure to
determine if the task is queued in the device.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTCLR</name>
            <description>Command Queuing DoorBell register</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>TCLR</name>
                <description>Writing 1 to bit n of this register orders CQE to clear a task
that the software has previously issued.
This bit can only be written when CQE is in Halt state as
indicated in CQCFG register Halt bit. When software writes 1
to a bit in this register, CQE updates the value to 1, and
starts clearing the data structures related to the task. CQE
clears the bit fields (sets a value of 0) in CQTCLR and in
CQTDBR once the clear operation is complete. Software
must poll on the CQTCLR until it is cleared to verify that a
clear operation was done.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQSSC1</name>
            <description>CQ Send Status Configuration 1 register</description>
            <addressOffset>0x1C0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x11000</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>SQSCMD_IDLE_TMR</name>
                <description>This field configures the polling period to be used when
using periodic SEND_QUEUE_STATUS (CMD13) polling.
Periodic polling is used when tasks are pending in the
device, but no data transfer is in progress. When a
SEND_QUEUE_STATUS response indicates that no task is
ready for execution, CQE counts the configured time until it
issues the next SEND_QUEUE_STATUS.
Timer units are clock periods of the clock whose frequency is
specified in the Internal Timer Clock Frequency field CQCAP
register. The minimum value is 0001h (1 clock period) and
the maximum value is FFFFh (65535 clock periods).
For example, a CQCAP field value of 0 indicates a 19.2 MHz
clock frequency (period = 52.08 ns). If the setting in
CQSSC1.CIT is 1000h, the calculated polling period is
4096*52.08 ns= 213.33 ns.
Should be programmed only when CQCFG.CQ_EN is '0'.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SQSCMD_BLK_CNT</name>
                <description>This field indicates when SQS CMD is sent while data
transfer is in progress.
A value of 'n' indicates that CQE sends status command on
the CMD line, during the transfer of data block BLOCK_CNTn,
on the data lines, where BLOCK_CNT is the number of
blocks in the current transaction.
- 0x0: SEND_QUEUE_STATUS (CMD13) command is not
sent during the transaction. Instead, it is sent only when
the data lines are idle.
- 0x1: SEND_QUEUE_STATUS command is to be sent
during the last block of the transaction.
- 0x2: SEND_QUEUE_STATUS command when last 2
blocks are pending.
- 0x3: SEND_QUEUE_STATUS command when last 3
blocks are pending.
- ........
- 0xf: SEND_QUEUE_STATUS command when last 15
blocks are pending.
Should be programmed only when CQCFG.CQ_EN is '0'</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQSSC2</name>
            <description>CQ Send Status Configuration 2 register</description>
            <addressOffset>0x1C4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>SQSCMD_RCA</name>
                <description>This field provides CQE with the contents of the 16-bit RCA
field in SEND_QUEUE_STATUS (CMD13) command
argument.
CQE copies this field to bits 31:16 of the argument when
transmitting SEND_ QUEUE_STATUS (CMD13) command.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCRDCT</name>
            <description>Command response for direct command register</description>
            <addressOffset>0x1C8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>DCMD_RESP</name>
                <description>This register contains the response of the command
generated by the last direct command (DCMD) task that was
sent.
Contents of this register are valid only after bit 31 of
CQTDBR register is cleared by the controller.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQRMEM</name>
            <description>Command response mode error mask register</description>
            <addressOffset>0x1D0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFDF9A080</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>RESP_ERR_MASK</name>
                <description>The bits of this field are bit mapped to the device response.
This bit is used as an interrupt mask on the device status
filed that is received in R1/R1b responses.
- 1: When a R1/R1b response is received, with a bit i in the
device status set, a RED interrupt is generated.
- 0: When a R1/R1b response is received, bit i in the device
status is ignored.
The reset value of this register is set to trigger an interrupt on
all 'Error' type bits in the device status.
Note: Responses to CMD13 (SQS) encode the QSR so that
they are ignored by this logic.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQTERRI</name>
            <description>CQ Task Error Information register</description>
            <addressOffset>0x1D4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x9F3F9F3F</resetMask>
            <fields>
              <field>
                <name>RESP_ERR_CMD_INDX</name>
                <description>This field captures the index of the command that was
executed on the command line when the error occurred.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESP_ERR_TASKID</name>
                <description>This field captures the ID of the task which was executed on
the command line when the error occurred.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RESP_ERR_FIELDS_VALID</name>
                <description>This bit is updated when an error is detected while a
command transaction was in progress.
Values:
- 0x1 (SET): Response-related error is detected. Check
contents of RESP_ERR_TASKID and
RESP_ERR_CMD_INDX fields
- 0x0 (NOT_SET): Ignore contents of RESP_ERR_TASKID
and RESP_ERR_CMD_INDX</description>
                <bitRange>[15:15]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TRANS_ERR_CMD_INDX</name>
                <description>This field captures the index of the command that was
executed and whose data transfer has errors.</description>
                <bitRange>[21:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TRANS_ERR_TASKID</name>
                <description>This field captures the ID of the task that was executed and
whose data transfer has errors.</description>
                <bitRange>[28:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TRANS_ERR_FIELDS_VALID</name>
                <description>This bit is updated when an error is detected while a data
transfer transaction was in progress.
Values:
- 0x1 (SET): data transfer related error detected. Check
contents of TRANS_ERR_TASKID and
TRANS_ERR_CMD_INDX fields
- 0x0 (NOT_SET): Ignore contents of
TRANS_ERR_TASKID and TRANS_ERR_CMD_INDX</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCRI</name>
            <description>CQ Command response index</description>
            <addressOffset>0x1D8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CMD_RESP_INDX</name>
                <description>Last Command Response index
This field stores the index of the last received command
response. Controller updates the value every time a
command response is received.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CQCRA</name>
            <description>CQ Command response argument register</description>
            <addressOffset>0x1DC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CMD_RESP_ARG</name>
                <description>Last Command Response argument
This field stores the argument of the last received command
response. Controller updates the value every time a
command response is received.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MSHC_VER_ID_R</name>
            <description>MSHC version</description>
            <addressOffset>0x500</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x3137302A</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MSHC_VER_ID</name>
                <description>Current release number
This field indicates the Synopsys DesignWare Cores
DWC_mshc/DWC_mshc_lite current release number that is
read by an application.
For example, release number '1.60a' is represented in
ASCII as 0x313630. Lower 8 bits read from this register can
be ignored by the application.
An application reading this register in conjunction with the
MSHC_VER_TYPE_R register, gathers details of the current
release.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MSHC_VER_TYPE_R</name>
            <description>MSHC version type</description>
            <addressOffset>0x504</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x67612A2A</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>MSHC_VER_TYPE</name>
                <description>Current release type
This field indicates the Synopsys DesignWare Cores
DWC_mshc/DWC_mshc_lite current release type that is
read by an application.
For example, release type is 'ga' is represented in ASCII as
0x6761. Lower 16 bits read from this register can be ignored
by the application.
An application reading this register in conjunction with the
MSHC_VER_ID_R register, gathers details of the current
release.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MSHC_CTRL_R</name>
            <description>MSHC Control register</description>
            <addressOffset>0x508</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0x11</resetMask>
            <fields>
              <field>
                <name>CMD_CONFLICT_CHECK</name>
                <description>Command conflict check
This bit enables command conflict check.
Note: DWC_mshc controller monitors the CMD line
whenever a command is issued and checks whether the
value driven on sd_cmd_out matches the value on
sd_cmd_in at next subsequent edge of cclk_tx to determine
command conflict error. This bit is cleared only if the feed
back delay (including IO Pad delay) is more than
(t_card_clk_period - t_setup), where t_setup is the setup
time of a flop in DWC_mshc. The I/O pad delay is consistent
across CMD and DATA lines, and it is within the value:
(2*t_card_clk_period - t_setup)
Values:
- 0x0 (DISABLE_CMD_CONFLICT_CHK): Disable
command conflict check
- 0x1 (CMD_CONFLICT_CHK_LAT1): Check for command
conflict after 1 card clock cycle</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SW_CG_DIS</name>
                <description>Internal clock gating disable control
This bit must be used to disable IP's internal clock gating
when required. when disabled clocks are not gated. Clocks
to the core (except hclk) must be stopped when
programming this bit.
Values:
- 0x0 (ENABLE): Internal clock gates are active and clock
gating is controlled internally
- 0x1 (DISABLE): Internal clock gating is disabled, clocks
are not gated internally</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MBIU_CTRL_R</name>
            <description>MBIU Control register</description>
            <addressOffset>0x510</addressOffset>
            <size>8</size>
            <access>read-write</access>
            <resetValue>0x1</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>UNDEFL_INCR_EN</name>
                <description>Undefined INCR Burst
Controls generation of undefined length INCR transfer on
Master interface.
Values:
- 0x0 (FALSE): Undefined INCR type burst is the least
preferred burst on AHB Master I/F
- 0x1 (TRUE): Undefined INCR type burst is the most
preferred burst on AHB Master I/F</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURST_INCR4_EN</name>
                <description>INCR4 Burst
Controls generation of INCR4 transfers on Master interface.
Values:
- 0x0 (FALSE): AHB INCR4 burst type is not generated on
Master I/F
- 0x1 (TRUE): AHB INCR4 burst type can be generated on
Master I/F</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURST_INCR8_EN</name>
                <description>INCR8 Burst
Controls generation of INCR8 transfers on Master interface.
Values:
- 0x0 (FALSE): AHB INCR8 burst type is not generated on
Master I/F
- 0x1 (TRUE): AHB INCR8 burst type can be generated on
Master I/F</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BURST_INCR16_EN</name>
                <description>INCR16 Burst
Controls generation of INCR16 transfers on Master
interface.
Values:
- 0x0 (FALSE): AHB INCR16 burst type is not generated on
Master I/F
- 0x1 (TRUE): AHB INCR16 burst type can be generated
on Master I/F</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>EMMC_CTRL_R</name>
            <description>eMMC Control register</description>
            <addressOffset>0x52C</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0xC</resetValue>
            <resetMask>0x60F</resetMask>
            <fields>
              <field>
                <name>CARD_IS_EMMC</name>
                <description>eMMC Card present
This bit indicates the type of card connected. An application
program this bit based on the card connected to SDHC.
Values:
- 0x1 (EMMC_CARD): Card connected to SDHC is an
eMMC card
- 0x0 (NON_EMMC_CARD): Card connected to SDHC is
a non-eMMC card</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DISABLE_DATA_CRC_CHK</name>
                <description>Disable Data CRC Check
This bit controls masking of CRC16 error for Card Write in
eMMC mode. This is useful in bus testing (CMD19) for an
eMMC device. In bus testing, an eMMC card does not send
CRC status for a block, which may generate CRC error. This
CRC error can be masked using this bit during bus testing.
Values:
- 0x1 (DISABLE): DATA CRC check is disabled
- 0x0 (ENABLE): DATA CRC check is enabled</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EMMC_RST_N</name>
                <description>EMMC Device Reset signal control.
This register field controls the card_emmc_reset_n output of SDHC
Values:
- 0x1 (RST_DEASSERT): Reset to eMMC device is
deasserted
- 0x0 (RST_ASSERT): Reset to eMMC device asserted
(active low)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EMMC_RST_N_OE</name>
                <description>Output Enable (OE) control for EMMC Device Reset signal (card_emmc_reset_n).
Values:
- 0x1 (ENABLE): OE for card_emmc_reset_n is 1
- 0x0 (DISABLE): OE for card_emmc_reset_n is 0</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_ALGO_SEL</name>
                <description>Scheduler algorithm selected for execution
This bit selects the Algorithm used for selecting one of the
many ready tasks for execution.
Values:
- 0x0 (PRI_REORDER_PLUS_FCFS): Priority based
reordering with FCFS to resolve equal priority tasks
- 0x1 (FCFS_ONLY): First come First serve, in the order of
DBR rings</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CQE_PREFETCH_DISABLE</name>
                <description>Enable or Disable CQE's PREFETCH feature
This field allows Software to disable CQE's data prefetch
feature when set to 1.
Values:
- 0x0 (PREFETCH_ENABLE): CQE can Prefetch data for
sucessive WRITE transfers and pipeline sucessive READ
transfers
- 0x1 (PREFETCH_DISABLE): Prefetch for WRITE and
Pipeline for READ are disabled</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>BOOT_CTRL_R</name>
            <description>eMMC Boot Control register</description>
            <addressOffset>0x52E</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF181</resetMask>
            <fields>
              <field>
                <name>MAN_BOOT_EN</name>
                <description>Mandatory Boot Enable
This bit is used to initiate the mandatory boot operation. The
application sets this bit along with VALIDATE_BOOT bit.
Writing 0 is ignored. The SDHC clears this bit after the
boot transfer is completed or terminated.
Values:
- 0x1 (MAN_BOOT_EN): Mandatory boot enable
- 0x0 (MAN_BOOT_DIS): Mandatory boot disable</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALIDATE_BOOT</name>
                <description>Validate Mandatory Boot Enable bit
This bit is used to validate the MAN_BOOT_EN bit.
Values:
- 0x1 (TRUE): Validate Mandatory boot enable bit
- 0x0 (FALSE): Ignore Mandatory boot Enable bit</description>
                <bitRange>[7:7]</bitRange>
                <access>write-only</access>
              </field>
              <field>
                <name>BOOT_ACK_ENABLE</name>
                <description>Boot Acknowledge Enable
When this bit set, SDHC checks for boot acknowledge
start pattern of 0-1-0 during boot operation. This bit is
applicable for both mandatory and alternate boot mode.
Values:
- 0x1 (TRUE): Boot Ack enable
- 0x0 (FALSE): Boot Ack disable</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BOOT_TOUT_CNT</name>
                <description>N/A</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GP_IN_R</name>
            <description>General Purpose Input register</description>
            <addressOffset>0x530</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>GP_IN</name>
                <description>It reflects the value of gp_in ports.
NOT USED - ALWAYS READS 0</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>GP_OUT_R</name>
            <description>General Purpose Output register</description>
            <addressOffset>0x534</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CARD_DETECT_EN</name>
                <description>0: Force card_detect_n input to 0
1:  Normal card_detect_n operation allowing card detection from a device pin</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_MECH_WRITE_PROT_EN</name>
                <description>card_mech_write_prot, despite its name, is an active low signal (per the SD Host Controller Standard spec it is officially called SDWP#).  Consider that in the following:
0: Force card_mech_write_prot input to 0 internally; this forces write protection to be active
1: Allow card_mech_write_prot to work normally per the device's pin state</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LED_CTRL_OE</name>
                <description>Active high output enable for the LED output signal (led_ctrl) controlled through HOST_CTRL1_R.LED_CTRL:
0: disable OE associated with the led_ctrl output
1: enable OE associated with the led_ctrl output</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_CLOCK_OE</name>
                <description>Active high output enable for the card clock output (clk_card) which is gated by CLK_CTRL_R.SD_CLK_EN:
0: disable OE to the clk_card output
1: enable OE to the clk_card output</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_IF_PWR_EN_OE</name>
                <description>Active high output enable for the card interface power enable output (card_if_pwr_en) controlled through PWR_CTRL_R.SD_BUS_PWR_VDD1:
0: disable OE to the card_if_pwr_en output
1: enable OE to the card_if_pwr_en output</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO_VOLT_SEL_OE</name>
                <description>Active high output enable for the IO voltage selection signal (io_volt_sel) controlled through HOST_CTRL_2.SIGNALING_EN:
0: disable OE to the io_volt_sel output
1: enable OE to the io_volt_sel output</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_CLOCK_OUT_DLY</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CARD_CLOCK_IN_DLY</name>
                <description>Delay CARD_CLOCK input internally to optimally sample CMD/DAT; set according to interface mode:
00: SD Default Speed, SD SDR12, eMMC Legacy
01: SD SDR25, SD SDR50
10: SD High Speed, eMMC High Speed SDR
11: SD DDR50, eMMC DDR</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SDHC0">
      <name>SDHC1</name>
      <baseAddress>0x40470000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40600000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI). In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames mot separated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of up to 256 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>Determines the number of bits per FIFO data element:
'0': 16-bit FIFO data elements.
'1': 8-bit FIFO data elements. This mode doubles the amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, MMIO read operations return 0xffff:ffff and MMIO write operations are ignored. Colliding accesses are registered as interrupt causes: field BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL to enable IP, select the specific operation mode and oversampling factor.
When the IP is enabled, no control information should be changed. Changes should be made AFTER disabling the IP, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the IP is re-enabled. Note that disabling the IP will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when the slave is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register are reliable (when CMD_RESP_EC_BUSY is '0') or not reliable (when CMD_RESP_EC_BUSY is '1'). Note:
- When there is no ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable).
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable), when the CURR_RD_ADDR and CURR_WR_ADDR are not being updated by the HW.
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '1' (not reliable), when the CURR_RD_ADDR or CURR_WR_ADDR are being updated by the HW. 
   Note that this update lasts one I2C clock cycle, or two SPI clock cycles.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily separated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always separated by slave deselection: independent of the availability of TX FIFO data frames.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Indicates the clock phase. This field, together with the CPOL field, indicates when MOSI data is driven and MISO data is captured:
- Motorola mode 0. CPOL is '0', CPHA is '0': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is '0', CPHA is '1': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is '1', CPHA is '0': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is '1', CPHA is '1': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.

In SPI Motorola submode, all four CPOL/CPHA modes are valid.
in SPI NS submode, only CPOL=0 CPHA=0 mode is valid.
in SPI TI submode, only CPOL=0 CPHA=1 mode is valid.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. This field, together with the CPHA field, indicates when MOSI data is driven and MISO data is captured:
- CPOL is '0': SCLK is '0' when not transmitting data.
- CPOL is '1': SCLK is '1' when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (for Motorola as determined by CPOL and CPHA, for Texas Instruments on the falling edge of SCLK and for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode. 
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful for slave devices that use SCLK for functional operation other than just SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave select signal 0 (master mode) and to the incoming SPI slave select signal (slave mode). For Motorola and National Semiconductors submodes: 
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Instruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line 'spi_miso_in' is connected to the SPI MISO pin.
'1': the SPI master MISO line 'spi_miso_in' is connected to the SPI master MOSI line 'spi_mosi_out'. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
The IP should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence on availability of data frames in the TX FIFO. In slave mode, when selected and there is no data frame in the TX FIFO, the slave will transmit all '1's. In both master and slave modes, received data frames will be lost if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). When '0', the transmitter TX line 'uart_tx_out' is connected to the TX pin and the receiver RX line 'uart_rx_in' is connected to the RX pin. When '1', the transmitter TX line 'uart_tx_out' is connected to the receiver RX line 'uart_rx_in'. A similar connections scheme is followed for 'uart_rts_out' and 'uart_cts_in'.

This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0xF3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.

Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle ('1') time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal 'uart_rx_in'. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behavior when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame separates addresses (bit is '1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle ('1') to START ('0') on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a '0' to '1' transition, which indicates the first data frame bit is received (first data frame bit should be '1'). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is '0'. This feature is useful for standard UART submode and LIN submode ('break field' detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to '1'. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver's definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive '0' bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of a 0x55 data frame (sent least significant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal 'uart_rts_out' is activated. By setting this field to '0', flow control is effectively SW disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal 'uart_rts_out':
'0': RTS is low/'0' active; 'uart_rts_out' is '0' when active and 'uart_rts_out' is '1' when inactive.
'1': RTS is high/'1' active; 'uart_rts_out' is '1' when active and 'uart_rts_out' is '0' when inactive.

During IP reset (Hibernate system power mode), 'uart_rts_out' is '1'. This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal 'uart_cts_in':
'0': CTS is low/'0' active; 'uart_cts_in' is '0' when active and 'uart_cts_in' is '1' when inactive.
'1': CTS is high/'1' active; 'uart_cts_in' is '1' when active and 'uart_cts_in' is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal 'uart_cts_in' by the UART transmitter:
'0': Disabled. The UART transmitter ignores 'uart_cts_in', and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses 'uart_cts_in' to qualify the transmission of data. It transmits when 'uart_cts_in' is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', 'uart_cts_in' is connected to 'uart_rts_out' in the IP (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular (no stretching) interface (IF) low time to guarantee functional correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>When '1', a received data element byte the master is immediately NACK'd when the receiver FIFO is full. When '0', clock stretching is used instead (till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address. This is useful for slaves that do not need any data supplied within the general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities: 1). the internally clocked logic is enabled (we are in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the internally clocked logic takes over). The internally clocked logic will handle the ongoing transfer as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines are routed internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_EZ_ADDR or CURR_EZ_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_EZ_ADDR and CURR_EZ_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_sda_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values.

SDA_IN_FILT_TRIM[1] is used to enable I2CS_EC or SPIS_EC access to internal SRAM memory.
1: enable clock_scb_en, has no effect on ec_busy_pp
0: disable clock_scb_en, enable ec_busy_pp (grant I2CS_EC or SPIS_EC access)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of 'i2c_sda_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_scl_in' 50 ns filter. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of 'i2c_scl_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 0. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 1. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 2. See s8i2cs BROS (001-59539) for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative 'i2c_sda_out' filter delay:
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x1010F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

The open drain mode is supported for:
- I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
- UART mode, 'uart_tx' IO cell (SPI slave).
- SPI mode, 'spi_miso' IO cell.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is transmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x30F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptibility to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.

In UART multi-processor mode, all 8 bits are used.

In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization of the first transmitted byte in a I2C transfer: the first 7 bits represent the address of the addressed slave, and the last 1 bit is a read/write indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the ADDR field bits in the ADDR field take part in the matching of the slave address: MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

This register has a side effect when read by software: a data frame is removed from the FIFO. This may be undesirable during debug; i.e. a read during debug should NOT have a side effect. To this end, the IP uses the AHB-Lite 'hmaster[0]' input signal. When this signal is '1' in the address cycle of a bus transfer, a read transfer will not have a side effect. As a result, a read from this register will not remove a data frame from the FIFO. As a result, a read from this register behaves as a read from the SCB_RX_FIFO_RD_SILENT register.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK'd or NACK'd.

In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK'd or NACK'd.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (till the internally clocked logic takes over) (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO.   In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL.TRIGGER_LEVEL. 

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries != FF_DATA_NR/2.
BYTE_MODE is '1': # entries != FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.

Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO, and the last stop field is transmitted (both TX FIFO and transmit shifter register are empty). Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. This condition event is useful when transmitter and receiver share a TX/RX line. This is the case in LIN or SmartCard modes. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by RX_FIFO_CTRL.TRIGGER_LEVEL.

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.

Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO is full. Dependent on CTRL.BYTE_MODE: (FF_DATA_NR = EZ_DATA_NR/2)
BYTE_MODE is '0': # entries == FF_DATA_NR/2.
BYTE_MODE is '1': # entries == FF_DATA_NR.

Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. This can be either a start or stop bit(s) error:
Start bit error: after the detection of the beginning of a start bit period (RX line changes from '1' to '0'), the middle of the start bit period is sampled erroneously (RX line is '1').  Note: a start bit error is detected BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected. Note: a stop bit error may result in failure to receive successive data frame(s). Note: a stop bit error is detected AFTER a data frame is received.

A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR field specifies whether the received frame is dropped or send to the RX FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data frame is send to the RX FIFO. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO; i.e. the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1', the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '0', the received frame is send to the RX FIFO. In SmartCard submode, negatively acknowledged data frames generate a parity error. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period. Can occur at any time to address unanticipated break fields; i.e. 'break-in-data' is supported. This feature is supported for the UART standard and LIN submodes. For the UART standard submodes, ongoing receipt of data frames is NOT affected; i.e. Firmware is expected to take the proper action. For the LIN submode, possible ongoing receipt of a data frame is stopped and the (partially) received data frame is dropped and baud rate detection is started. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40610000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x40620000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB3</name>
      <baseAddress>0x40630000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB4</name>
      <baseAddress>0x40640000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB5</name>
      <baseAddress>0x40650000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB6</name>
      <baseAddress>0x40660000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB7</name>
      <baseAddress>0x40670000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB8</name>
      <baseAddress>0x40680000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB9</name>
      <baseAddress>0x40690000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB10</name>
      <baseAddress>0x406A0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB11</name>
      <baseAddress>0x406B0000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB12</name>
      <baseAddress>0x406C0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>SAR</name>
      <description>SAR ADC with Sequencer</description>
      <baseAddress>0x409D0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Analog control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000000</resetValue>
          <resetMask>0xFF3FEEF7</resetMask>
          <fields>
            <field>
              <name>PWR_CTRL_VREF</name>
              <description>VREF buffer low power mode.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWR_100</name>
                  <description>full power  (100 percent) (default), bypass cap, max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_80</name>
                  <description>80 percent power</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_60</name>
                  <description>60 percent power</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_50</name>
                  <description>50 percent power</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_40</name>
                  <description>40 percent power</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_30</name>
                  <description>30 percent power</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_20</name>
                  <description>20 percent power</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_10</name>
                  <description>10 percent power</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_SEL</name>
              <description>SARADC internal VREF selection.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VREF0</name>
                  <description>VREF0 from PRB (VREF buffer on)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF1</name>
                  <description>VREF1 from PRB (VREF buffer on)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF2</name>
                  <description>VREF2 from PRB (VREF buffer on)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_AROUTE</name>
                  <description>VREF from AROUTE (VREF buffer on)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBGR</name>
                  <description>1.024V from BandGap (VREF buffer on)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_EXT</name>
                  <description>External precision Vref direct from a pin (low impedance path).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_DIV_2</name>
                  <description>Vdda/2  (VREF buffer on)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA</name>
                  <description>Vdda.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_BYP_CAP_EN</name>
              <description>VREF bypass cap enable for when VREF buffer is on</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_SEL</name>
              <description>SARADC internal NEG selection for Single ended conversion</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_KELVIN</name>
                  <description>NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ART_VSSA</name>
                  <description>NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P1</name>
                  <description>NEG input of SARADC is connected to P1 pin of SARMUX</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P3</name>
                  <description>NEG input of SARADC is connected to P3 pin of SARMUX</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P5</name>
                  <description>NEG input of SARADC is connected to P5 pin of SARMUX</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P7</name>
                  <description>NEG input of SARADC is connected to P7 pin of SARMUX</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACORE</name>
                  <description>NEG input of SARADC is connected to an ACORE in AROUTE</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF</name>
                  <description>NEG input of SARADC is shorted with VREF input of SARADC.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR_HW_CTRL_NEGVREF</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_DLY</name>
              <description>Set the comparator latch delay in accordance with SAR conversion rate</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>D2P5</name>
                  <description>2.5ns delay, use this for 2.5Msps</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D4</name>
                  <description>4.0ns delay, use this for 2.0Msps</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D10</name>
                  <description>10ns delay, use this for 1.5Msps</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D12</name>
                  <description>12ns delay, use this for 1.0Msps or less</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare controls, not yet designated, for late changes done with an ECO</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOSTPUMP_EN</name>
              <description>deprecated</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFBUF_EN</name>
              <description>For normal ADC operation this bit must be set, for all reference choices - internal, external or vdda based reference. 
Setting this bit is critical to proper function of switches inside SARREF block.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_PWR</name>
              <description>Comparator power mode.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>P100</name>
                  <description>Power = 100 percent, Use this for SAR Clock Frequency greater than 18MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P80</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P60</name>
                  <description>Power = 60 percent, Use this for SAR Clock Frequency greater than 1.8MHz up to 18MHz.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P50</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P40</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P30</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P20</name>
                  <description>Power = 20 percent, Use this for SAR Clock Frequency less than or equal to 1.8MHz</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P10</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: SARMUX IP disabled off during DeepSleep power mode
- 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_CONFIG</name>
              <description>- 0: bypass clock domain synchronization of the DSI config signals.
- 1: synchronize the DSI config signals to peripheral clock domain.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_MODE</name>
              <description>SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1)
- 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations
- 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_DISABLE</name>
              <description>Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)
- 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations
- 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgating) on write.
- 1: SAR IP enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_CTRL</name>
          <description>Sample control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80008</resetValue>
          <resetMask>0xDFCF01FE</resetMask>
          <fields>
            <field>
              <name>LEFT_ALIGN</name>
              <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLE_ENDED_SIGNED</name>
              <description>Output data from a single ended conversion as a signed value 

If AVG_MODE = 1 (Interleaved averaging), then SINGLE_ENDED_SIGNED must be configured identically to DIFFERENTIAL_SIGNED.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Default: result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_SIGNED</name>
              <description>Output data from a differential conversion as a signed value when DIFFERENTIAL_EN or NEG_ADDR_EN is set to 1

If AVG_MODE = 1 (Interleaved averaging), then DIFFERENTIAL_SIGNED must be configured identically to SINGLE_ENDED_SIGNED.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Default: result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_CNT</name>
              <description>Averaging Count for channels that have averaging enabled (AVG_EN). A channel will be sampled (1&lt;&lt;(AVG_CNT+1)) = [2..256] times.
- In ACCUNDUMP mode  (1st order accumulate and dump filter) a channel will be sampled back to back, the average result is calculated and stored and then the next enabled channel is sampled. If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).
- In INTERLEAVED mode one sample is taken per triggered scan, only in the scan where the final averaging count is reached a valid average is calculated and stored in the RESULT register (by definition the same scan for all the channels that have averaging enabled). In all other scans the RESULT register for averaged channels will have an invalid result and the intermediate accumulated value is stored in the 16-bit WORK register. In this mode make sure that the averaging count is low enough to ensure that the intermediate value does not exceed 16-bits otherwise the MSBs will be lost. So for a 12-bit resolution the averaging count should be set to 16 or less (AVG_CNT=&lt;3).</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SHIFT</name>
              <description>Averaging shifting: after averaging the result is shifted right to fit in 12 bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_MODE</name>
              <description>Averaging mode,  in DSI mode this bit is ignored and only AccuNDump mode is available.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACCUNDUMP</name>
                  <description>Accumulate and Dump (1st order accumulate and dump filter): a channel will be sampled back to back and averaged</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INTERLEAVED</name>
                  <description>Interleaved: Each scan (trigger) one sample is taken per channel and averaged over several scans.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>- 0: Wait for next FW_TRIGGER (one shot) or hardware trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.
- 1: Continuously scan enabled channels, ignore triggers.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_EN</name>
              <description>- 0: firmware trigger only: disable hardware trigger tr_sar_in.
- 1: enable hardware trigger tr_sar_in (e.g. from TCPWM, GPIO or UDB).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_LEVEL</name>
              <description>- 0: trigger signal is a pulse input, a positive edge detected on the trigger signal triggers a new scan.
- 1: trigger signal is a level input, as long as the trigger signal remains high the SAR will do continuous scans.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_TRIGGER</name>
              <description>- 0: bypass clock domain synchronization of the trigger signal.
- 1: synchronize the trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UAB_SCAN_MODE</name>
              <description>Select whether UABs are scheduled or unscheduled. When no UAB is scanned this selection is ignored.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSCHEDULED</name>
                  <description>Unscheduled UABs: one or more of the UABs scanned by the SAR is not scheduled, for each channel that scans a UAB the SAR will wait for a positive edge on the trigger output of that UAB. Caveat: in this mode the length of SAR scan can be variable.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCHEDULED</name>
                  <description>Scheduled UABs: All UABs scanned by the SAR are assumed to be properly scheduled, i.e. their output is assumed to be valid when sampled by the SAR and the SAR does not wait. In this mode the length of the SAR scan is constant. 
This mode requires that the SAR scans strictly periodically, i.e. the SAR has to either run continuously or has to be triggered by a periodic hardware trigger (TCPWM or UDB timer). It also requires that the end of the UAB valid phase is precisely aligned with the end of the SAR sample period (using UAB.STARTUP_DELAY). Normally this scheduling is done by Creator.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REPEAT_INVALID</name>
              <description>For unscheduled UAB_SCAN_MODE only, do the following if an invalid sample is received:
- 0: use the last known valid sample for that channel and clear the NEWVALUE flag
- 1: repeat the conversions until a valid sample is received (caveat: could be never if the UAB valid window is incorrectly schedule w.r.t. SAR sampling)</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_SEL</name>
              <description>Static UAB Valid select
0=UAB0 half 0 Valid output
1=UAB0 half 1 Valid output
2=UAB1 half 0 Valid output
3=UAB1 half 1 Valid output
4=UAB2 half 0 Valid output
5=UAB2 half 1 Valid output
6=UAB3 half 0 Valid output
7=UAB3 half 1 Valid output</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_SEL_EN</name>
              <description>Enable static UAB Valid selection (override Hardware)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID_IGNORE</name>
              <description>Ignore UAB valid signal, including the dynamic/Hardware from AROUTE and the static Valid selection from the VALID_SEL fields above</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGGER_OUT_EN</name>
              <description>SAR output trigger enable (used for UAB synchronization). To ensure multiple UABs starting at the same trigger it is recommended to use this bit to temporarily disable the trigger output until all those UABs are set to run (UAB.SRAM_CTRL.RUN=1).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_DSI_OUT_EN</name>
              <description>Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a trigger pulse is send on the tr_sar_out signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME01</name>
          <description>Sample time specification ST0 and ST1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30003</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME0</name>
              <description>Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is one clock less than specified here. The minimum sample time is 167ns, which is 3.0 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME1</name>
              <description>Sample time1</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME23</name>
          <description>Sample time specification ST2 and ST3</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30003</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME2</name>
              <description>Sample time2</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME3</name>
              <description>Sample time3</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_THRES</name>
          <description>Global range detect threshold register.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_LOW</name>
              <description>Low threshold for range detect.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE_HIGH</name>
              <description>High threshold for range detect.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_COND</name>
          <description>Global range detect mode register.</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>RANGE_COND</name>
              <description>Range condition select.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BELOW</name>
                  <description>result &lt; RANGE_LOW</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INSIDE</name>
                  <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ABOVE</name>
                  <description>RANGE_HIGH &lt;= result</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUTSIDE</name>
                  <description>result &lt; RANGE_LOW || RANGE_HIGH &lt;= result</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_EN</name>
          <description>Enable bits for the channels</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_EN</name>
              <description>Channel enable. 
- 0: the corresponding channel is disabled.
- 1: the corresponding channel is enabled, it will be included in the next scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_CTRL</name>
          <description>Start control register (firmware trigger).</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_CONFIG[%s]</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x81773577</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.  
If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.
- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formatting), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_WORK[%s]</name>
          <description>Channel working data register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x88000000</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_RESULT[%s]</name>
          <description>Channel result data register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE8000000</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_NEWVALUE_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_UPDATED</name>
          <description>Channel working data register 'updated' bits</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_UPDATED</name>
              <description>If set the corresponding WORK register was updated, i.e. was already sampled during the current scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_UPDATED</name>
          <description>Channel result data register 'updated' bits</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_UPDATED</name>
              <description>If set the corresponding RESULT register was updated, i.e. was sampled during the previous scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_NEWVALUE</name>
          <description>Channel working data register 'new value' bits</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_NEWVALUE</name>
              <description>If set the corresponding WORK data received a new value, i.e. was already sampled during the current scan and data was valid.
In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.
In case of averaging this New Value bit is an OR of all the valid bits received by each conversion.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_NEWVALUE</name>
          <description>Channel result data register 'new value' bits</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_NEWVALUE</name>
              <description>If set the corresponding RESULT data received a new value, i.e. was sampled during the last scan and data was valid.
In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.
In case of averaging this New Value bit is an OR of all the valid bits received by each conversion.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register.</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF, this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register.</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR</name>
          <description>Saturate interrupt request register.</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF, this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_SET</name>
          <description>Saturate interrupt set request register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASK</name>
          <description>Saturate interrupt mask register.</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASKED</name>
          <description>Saturate interrupt masked request register</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR</name>
          <description>Range detect interrupt request register.</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_SET</name>
          <description>Range detect interrupt set request register</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASK</name>
          <description>Range detect interrupt mask register.</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASKED</name>
          <description>Range interrupt masked request register</description>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC00000FF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_MASKED_RED</name>
              <description>Reduction OR of all SAR_SATURATION_INTR_MASKED bits</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_MASKED_RED</name>
              <description>Reduction OR of all SAR_RANGE_INTR_MASKED bits</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_CHAN_CONFIG</name>
          <description>Injection channel configuration register.</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0003577</resetMask>
          <fields>
            <field>
              <name>INJ_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this injection channel. If differential is enabled then INJ_PIN_ADDR[0] is ignored and considered to be 0, i.e. INJ_PIN_ADDR points to the even pin of a pin pair.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT</name>
                  <description>AROUTE virtual port</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (INJ_PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SAMPLE_TIME_SEL</name>
              <description>Injection sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_TAILGATING</name>
              <description>Injection channel tailgating.
- 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set if the SAR is not busy.  If the SAR is busy, the INJ channel addressed pin is sampled at the end of the current scan.
- 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_START_EN</name>
              <description>Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_RESULT</name>
          <description>Injection channel result register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF8000000</resetMask>
          <fields>
            <field>
              <name>INJ_RESULT</name>
              <description>SAR conversion result of the channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_NEWVALUE</name>
              <description>The data in this register received a new value (only relevant for UAB, this bit shows the value of the UAB valid bit)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000001F</resetMask>
          <fields>
            <field>
              <name>CUR_CHAN</name>
              <description>current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_VREF_NEG</name>
              <description>the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF8FFFFF</resetMask>
          <fields>
            <field>
              <name>CUR_AVG_ACCU</name>
              <description>the current value of the averaging accumulator</description>
              <bitRange>[19:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRLV_BUSY</name>
              <description>If high then the SAR is in the middle of Interleaved averaging spanning several scans. While this bit is high the Firmware should not make any changes to the configuration registers otherwise some results may be incorrect. Note that the CUR_AVG_CNT status register below gives an indication how many more scans need to be done to complete the Interleaved averaging.
This bit can be cleared by changing the averaging mode to ACCUNDUMP or by disabling the SAR.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_AVG_CNT</name>
              <description>the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH0</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, also powers on the temperature sensor. Write with '1' to set bit.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR0</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_DS_CTRL</name>
          <description>SARMUX switch DSI control</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF00FF</resetMask>
          <fields>
            <field>
              <name>MUX_DS_CTRL_P0</name>
              <description>for P0 switches</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_P1</name>
              <description>for P1 switches</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_P2</name>
              <description>for P2 switches</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_P3</name>
              <description>for P3 switches</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_P4</name>
              <description>for P4 switches</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_P5</name>
              <description>for P5 switches</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_P6</name>
              <description>for P6 switches</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_P7</name>
              <description>for P7 switches</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_VSSA</name>
              <description>for vssa switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_TEMP</name>
              <description>for temp switch</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_AMUXBUSA</name>
              <description>for amuxbusa switch</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_AMUXBUSB</name>
              <description>for amuxbusb switches</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_SARBUS0</name>
              <description>for sarbus0 switch</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_DS_CTRL_SARBUS1</name>
              <description>for sarbus1 switch</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_SQ_CTRL</name>
          <description>SARMUX switch Sar Sequencer control</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF00FF</resetMask>
          <fields>
            <field>
              <name>MUX_SQ_CTRL_P0</name>
              <description>for P0 switches</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P1</name>
              <description>for P1 switches</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P2</name>
              <description>for P2 switches</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P3</name>
              <description>for P3 switches</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P4</name>
              <description>for P4 switches</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P5</name>
              <description>for P5 switches</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P6</name>
              <description>for P6 switches</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_P7</name>
              <description>for P7 switches</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_VSSA</name>
              <description>for vssa switch</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_TEMP</name>
              <description>for temp switch</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_AMUXBUSA</name>
              <description>for amuxbusa switch</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_AMUXBUSB</name>
              <description>for amuxbusb switches</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_SARBUS0</name>
              <description>for sarbus0 switch</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_SQ_CTRL_SARBUS1</name>
              <description>for sarbus1 switch</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_STATUS</name>
          <description>SARMUX switch status</description>
          <addressOffset>0x348</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_TRIM0</name>
          <description>Analog trim register.</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>CAP_TRIM</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIMUNIT</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_TRIM1</name>
          <description>Analog trim register.</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>SAR_REF_BUF_TRIM</name>
              <description>SAR Reference buffer trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PASS</name>
      <description>PASS top-level MMIO (DSABv2, INTR)</description>
      <baseAddress>0x409F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTB0_INT</name>
              <description>CTB0 interrupt pending</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB1_INT</name>
              <description>CTB1 interrupt pending</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB2_INT</name>
              <description>CTB2 interrupt pending</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB3_INT</name>
              <description>CTB3 interrupt pending</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC0_INT</name>
              <description>CTDAC0 interrupt pending</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC1_INT</name>
              <description>CTDAC1 interrupt pending</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC2_INT</name>
              <description>CTDAC2 interrupt pending</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTDAC3_INT</name>
              <description>CTDAC3 interrupt pending</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>AREF</name>
          <description>AREF configuration</description>
          <addressOffset>0x00000E00</addressOffset>
          <register>
            <name>AREF_CTRL</name>
            <description>global AREF control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF039FFFD</resetMask>
            <fields>
              <field>
                <name>AREF_MODE</name>
                <description>Control bit to trade off AREF settling and noise performance</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NORMAL</name>
                    <description>Nominal noise normal startup mode (meets normal mode settling and noise specifications)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FAST_START</name>
                    <description>High noise fast startup mode (meets fast mode settling and noise specifications)</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AREF_BIAS_SCALE</name>
                <description>BIAS Current Control for all AREF Amplifiers.  (These are risk mitigation bits that should not be touched by the customer:  the impact on IDDA/noise/startup still needs to be characterized)
0: 125nA (reduced bias: reduction in total AREF IDDA, higher noise and longer startup times)
1: 250nA ('default' setting to meet bandgap performance (noise/startup) and IDDA specifications)
2: 375nA (increased bias: increase in total AREF IDDA, lower noise and shorter startup times)
3: 500nA (further increased bias: increase in total AREF IDDA, lower noise and shorter startup times)</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AREF_RMB</name>
                <description>AREF control signals (RMB).

Bit 0: Manual VBG startup circuit enable
         0: normal VBG startup circuit operation
         1: VBG startup circuit is forced 'always on'

Bit 1: Manual disable of IPTAT2 DAC
         0: normal IPTAT2 DAC operation
         1: PTAT2 DAC is disabled while VBG startup is active

Bit 2: Manual enable of VBG offset correction DAC
         0: normal VBG offset correction DAC operation
         1: VBG offset correction DAC is enabled while VBG startup is active</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTB_IPTAT_SCALE</name>
                <description>CTB IPTAT current scaler.  This bit must be set in order to operate the CTB amplifiers in the lowest power mode.  This bit is chip-wide (controls all CTB amplifiers).
0: 1uA
1: 100nA</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CTB_IPTAT_REDIRECT</name>
                <description>Re-direct the CTB IPTAT output current. This can be used to reduce amplifier bias glitches during power mode transitions (for PSoC4A/B DSAB backwards compatibility).
0: Opamp&lt;n&gt;.IPTAT = AREF.IPTAT and Opamp&lt;n&gt;.IZTAT= AREF.IZTAT
1: Opamp&lt;n&gt;.IPTAT = HiZ and Opamp&lt;n&gt;.IZTAT= AREF.IPTAT

*Note that in Deep Sleep, the AREF IZTAT and/or IPTAT currents can be disabled and therefore the corresponding Opamp&lt;n&gt;.IZTAT/IPTAT will be HiZ.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IZTAT_SEL</name>
                <description>iztat current select control</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SRSS</name>
                    <description>Use 250nA IZTAT from SRSS</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LOCAL</name>
                    <description>Use locally generated 250nA</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CLOCK_PUMP_PERI_SEL</name>
                <description>CTBm charge pump clock source select. This field has nothing to do with the AREF.
0: Use the dedicated pump clock from SRSS (default)
1: Use one of the CLK_PERI dividers</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREF_SEL</name>
                <description>bandgap voltage select control</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SRSS</name>
                    <description>Use 0.8V Vref from SRSS</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LOCAL</name>
                    <description>Use locally generated Vref</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>EXTERNAL</name>
                    <description>Use externally supplied Vref (aref_ext_vref)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEEPSLEEP_MODE</name>
                <description>AREF DeepSleep Operation Modes (only applies if DEEPSLEEP_ON = 1)</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>All blocks 'OFF' in DeepSleep</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IPTAT</name>
                    <description>IPTAT bias generator 'ON' in DeepSleep (used for fast AREF wakeup only: IPTAT outputs not available)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IPTAT_IZTAT</name>
                    <description>IPTAT bias generator and outputs 'ON' in DeepSleep (used for biasing the CTBm with a PTAT current only in deep sleep)

*Note that this mode also requires that the CTB_IPTAT_REDIRECT be set if the CTBm opamp is to operate in DeepSleep</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>IPTAT_IZTAT_VREF</name>
                    <description>IPTAT, VREF, and IZTAT generators 'ON' in DeepSleep. This mode provides identical AREF functionality in DeepSleep as in the Active mode.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DEEPSLEEP_ON</name>
                <description>- 0: AREF IP disabled/off during DeepSleep power mode
- 1: AREF IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Disable AREF</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>VREF_TRIM0</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VREF_ABS_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VREF_TRIM1</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VREF_TEMPCO_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VREF_TRIM2</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>VREF_CURV_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VREF_TRIM3</name>
          <description>VREF Trim bits</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>VREF_ATTEN_TRIM</name>
              <description>Obsolete</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IZTAT_TRIM0</name>
          <description>IZTAT Trim bits</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IZTAT_ABS_TRIM</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IZTAT_TRIM1</name>
          <description>IZTAT Trim bits</description>
          <addressOffset>0xF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IZTAT_TC_TRIM</name>
              <description>IZTAT temperature correction trim (RMB)
0x00 : No IZTAT temperature correction
0xFF : Maximum IZTAT temperature correction

As this is a Risk Mitigation Register, it should be loaded with 0x08.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IPTAT_TRIM0</name>
          <description>IPTAT Trim bits</description>
          <addressOffset>0xF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>IPTAT_CORE_TRIM</name>
              <description>IPTAT trim
0x0 : Minimum IPTAT current (~150nA at room)
0xF : Maximum IPTAT current (~350nA at room)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IPTAT_CTBM_TRIM</name>
              <description>CTMB PTAT Current Trim
0x0 : Minimum CTMB IPTAT Current (~875nA)
0xF : Maximum CTMB IPTAT Current (~1.1uA)</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ICTAT_TRIM0</name>
          <description>ICTAT Trim bits</description>
          <addressOffset>0xF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>ICTAT_TRIM</name>
              <description>ICTAT trim
0x00 : Minimum ICTAT current (~150nA at room)
0x0F : Maximum ICTAT current (~350nA at room)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDM0</name>
      <description>PDM registers</description>
      <headerStructName>PDM</headerStructName>
      <baseAddress>0x40A00000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20808</resetValue>
          <resetMask>0x80030F0F</resetMask>
          <fields>
            <field>
              <name>PGA_R</name>
              <description>Right channel PGA gain:
+1.5dB/step, -12dB ~ +10.5dB
'0': -12 dB
'1': -10.5 dB 
...
'15' +10.5 dB
(Note: These bits are connected to AR36U12.PDM_CORE_CFG.PGA_R)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PGA_L</name>
              <description>Left channel PGA gain:
+1.5dB/step, -12dB ~ +10.5dB
'0': -12 dB
'1': -10.5 dB 
...
'15': +10.5 dB
(Note: These bits are connected to AR36U12.PDM_CORE_CFG.PGA_L)</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFT_MUTE</name>
              <description>Soft mute function to mute the volume smoothly
'0': Disabled.
'1': Enabled.
(Note: This bit is connected to AR36U12.PDM_CORE_CFG.SOFT_MUTE)</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>STEP_SEL</name>
              <description>Set fine gain step for smooth PGA or Soft-Mute attenuation transition.
'0': 0.13dB
'1': 0.26dB
(Note: This bit is connected to AR36U12.PDM_CORE2_CFG.SEL_STEP)</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Enables the PDM component:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_CTL</name>
          <description>Clock control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x200310</resetValue>
          <resetMask>0x7F0F33</resetMask>
          <fields>
            <field>
              <name>CLK_CLOCK_DIV</name>
              <description>PDM CLK (FPDM_CLK) (1st divider):
This configures a frequency of PDM CLK. The configured frequency is used to operate PDM core. I.e. the frequency is input to MCLKQ_CLOCK_DIV register.

Note: configure a frequency of PDM CLK as lower than or equal 50MHz with this divider.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIVBY1</name>
                  <description>Divide by 1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVBY2</name>
                  <description>Divide by 2 (no 50 percent duty cycle)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVBY3</name>
                  <description>Divide by 3 (no 50 percent duty cycle)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVBY4</name>
                  <description>Divide by 4 (no 50 percent duty cycle)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MCLKQ_CLOCK_DIV</name>
              <description>MCLKQ divider (2nd divider)

(Note: These bits are connected to 
AR36U12.PDM_CORE2_CFG.DIV_MCLKQ)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIVBY1</name>
                  <description>Divide by 1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVBY2</name>
                  <description>Divide by 2 (no 50 percent duty cycle)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVBY3</name>
                  <description>Divide by 3 (no 50 percent duty cycle)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIVBY4</name>
                  <description>Divide by 4 (no 50 percent duty cycle)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKO_CLOCK_DIV</name>
              <description>PDM CKO (FPDM_CKO) clock divider (3rd divider):
FPDM_CKO = MCLKQ / (CKO_CLOCK_DIV + 1)

Note: To configure '0' to this field is prohibited.
(Note: PDM_CKO is configured by MCLKQ_CLOCK_DIV,  CLK_CLOCK_DIV and CKO_CLOCK_DIV. )
(Note: These bits are connected to 
AR36U12.PDM_CORE_CFG.MCLKDIV)</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SINC_RATE</name>
              <description>SINC Decimation Rate. For details, see the data sheet provided by Archband.
Oversampling Ratio = Decimation Rate = 2 X SINC_RATE
(Note: These bits are connected to AR36U12.PDM_CORE_CFG.SINC_RATE)</description>
              <bitRange>[22:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODE_CTL</name>
          <description>Mode control</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1B000103</resetValue>
          <resetMask>0x1F070707</resetMask>
          <fields>
            <field>
              <name>PCM_CH_SET</name>
              <description>Specifies PCM output channels as mono or stereo:

(Note: These bits are connected to AR36U12.PDM_CORE2_CFG.PCM_CHSET)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>Channel disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MONO_L</name>
                  <description>Mono left channel enable</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MONO_R</name>
                  <description>Mono right channel enable</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEREO</name>
                  <description>Stereo channel enable</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SWAP_LR</name>
              <description>Input data L/R channel swap:
'1': Right/Left channel recording swap
'0': No Swap
(Note: This bit is connected to AR36U12.PDM_CORE_CFG.LRSWAP)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_CYCLES</name>
              <description>Set time step for gain change during PGA or soft mute operation in
number of 1/a sampling rate.
(Note: These bits are connected to AR36U12.PDM_CORE_CFG.S_CYCLES)</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>STEP_NUM64</name>
                  <description>64steps</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEP_NUM96</name>
                  <description>96steps</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEP_NUM128</name>
                  <description>128steps</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEP_NUM160</name>
                  <description>160steps</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEP_NUM192</name>
                  <description>192steps</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEP_NUM256</name>
                  <description>256steps</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEP_NUM384</name>
                  <description>384steps</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STEP_NUM512</name>
                  <description>512steps</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CKO_DELAY</name>
              <description>Phase difference from the rising edge of internal sampler clock (CLK_IS) to that of PDM_CKO clock:

(Note: These bits are connected to AR36U12.PDM_CORE2_CFG.PDMCKO_DLY)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADV3</name>
                  <description>CLK_IS is 3*PDM_CLK period early</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADV2</name>
                  <description>CLK_IS is 2*PDM_CLK period early</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADV1</name>
                  <description>CLK_IS is 1*PDM_CLK period early</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NO_DELAY</name>
                  <description>CLK_IS is the same as PDM_CKO</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DLY1</name>
                  <description>CLK_IS is 1*PDM_CLK period late</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DLY2</name>
                  <description>CLK_IS is 2*PDM_CLK period late</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DLY3</name>
                  <description>CLK_IS is 3*PDM_CLK period late</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DLY4</name>
                  <description>CLK_IS is 4*PDM_CLK period late</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HPF_GAIN</name>
              <description>Adjust high pass filter coefficients. 
H(Z) = (1 - Z-1 ) / [1 - (1- 2 -HPF_GAIN) Z-1 ]
(Note: These bits are connected to AR36U12.PDM_CORE_CFG.HPGAIN)</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HPF_EN_N</name>
              <description>Enable high pass filter (active low)
'1': Disabled.
'0': Enabled.
(Note: This bit is connected to AR36U12.PDM_CORE_CFG.ADCHPD)</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA_CTL</name>
          <description>Data control</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x103</resetMask>
          <fields>
            <field>
              <name>WORD_LEN</name>
              <description>PCM Word Length in number of bits:

(Note: These bits are connected to AR36U12.PDM_CORE2_CFG.PCM_IWL)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIT_EXTENSION</name>
              <description>When reception word length is shorter than the word length of RX_FIFO_RD, extension mode of upper bit should be set.
'0': Extended by '0'
'1': Extended by sign bit (if MSB word is '1', then it is extended by '1', if MSB is '0' then it is extended by '0')</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>STREAM_EN</name>
              <description>Enable data streaming flow:
'0': Disabled.
'1': Enabled.
(Note: This bit is connected to AR36U12.PDM_CORE_CFG.PDMA_EN)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10000</resetMask>
          <fields>
            <field>
              <name>RX_REQ_EN</name>
              <description>Trigger output ('tr_pdm_rx_req') enable for requests of DMA transfer
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTL</name>
          <description>RX FIFO control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated.
Note: software can configure up to 254 in Mono channel enabled (MODE_CTL.PCM_CH_SET = '1' or '2'), up to 253 in Stereo channel enabled (MODE_CTL.PCM_CH_SET = '3').</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the RX FIFO and RX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the RX FIFO have no effect. Freeze will not advance the RX FIFO write pointer.This field is used only for debugging purposes.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>RX FIFO status</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF00FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of entries in the RX FIFO. The field value is in the range [0, 255]. When this is zero, the RX FIFO is empty.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>RX FIFO read pointer: RX FIFO location from which a data frame is read by the host.This field is used only for debugging purposes.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>RX FIFO write pointer: RX FIFO location at which a new data frame is written by the hardware.This field is used only for debugging purposes.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>RX FIFO read</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. 
Note: Don't access to this bit while RX_FIFO_CTL.CLEAR is '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>RX FIFO silent read</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will NOT remove the data frame from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. This field is used only for debugging purposes.
Note: Don't access to this bit while RX_FIFO_CTL.CLEAR is '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x650000</resetMask>
          <fields>
            <field>
              <name>RX_TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in RX_FIFO_CTL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>RX FIFO is not empty.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x650000</resetMask>
          <fields>
            <field>
              <name>RX_TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x650000</resetMask>
          <fields>
            <field>
              <name>RX_TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x650000</resetMask>
          <fields>
            <field>
              <name>RX_TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S0</name>
      <description>I2S registers</description>
      <headerStructName>I2S</headerStructName>
      <baseAddress>0x40A10000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>TX_ENABLED</name>
              <description>Enables the I2S TX component:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ENABLED</name>
              <description>Enables the I2S RX component:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_CTL</name>
          <description>Clock control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x13F</resetMask>
          <fields>
            <field>
              <name>CLOCK_DIV</name>
              <description>Frequency divisor for generating I2S clock frequency.
The selected clock with CLOCK_SEL is divided by this. 
'0': Bypass
'1': 2 x
'2': 3 x
'3': 4 x
...
'62': 63 x
'63': 64 x</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SEL</name>
              <description>Selects clock to be used by I2S:
'0': Internal clock ('clk_audio_i2s')
'1': External clock ('clk_i2s_if')</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10101</resetMask>
          <fields>
            <field>
              <name>TX_START</name>
              <description>Transmitter enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PAUSE</name>
              <description>Pause enable:
'0': Disabled (TX FIFO data is sent over I2S).
'1': Enabled ('0' data is sent over I2S, instead of TX FIFO data).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_START</name>
              <description>Receiver enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>TX_REQ_EN</name>
              <description>Trigger output ('tr_i2s_tx_req') enable for requests of DMA transfer in transmission
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_REQ_EN</name>
              <description>Trigger output ('tr_i2s_rx_req') enable for requests of DMA transfer in reception
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTL</name>
          <description>Transmitter control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x440510</resetValue>
          <resetMask>0x37737F8</resetMask>
          <fields>
            <field>
              <name>B_CLOCK_INV</name>
              <description>Serial data transmission is advanced by 0.5 SCK cycles. This bit is valid only in TX slave mode.
When set to '1', the serial data will be transmitted 0.5 SCK cycles earlier than when set to '0'. 

1) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK falling edge
2) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK rising edge that is 0.5 SCK cycles before the SCK falling edge in 1)
3) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK rising edge
4) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK falling edge that is 0.5 SCK cycles before the SCK rising edge in 3)

(Note that this is only the appearance w.r.t. SCK edge, the actual timing is generated by an internal clock that runs 8x the SCK frequency). The word sync (TX_WS) signal is not affected by this bit setting. 
Note: When Master mode, must be '0'.
(Note: This bit is connected to AR38U12.TX_CFG.TX_BCLKINV)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALLING_EDGE_TX</name>
                  <description>SDO transmitted at SCK falling edge when TX_CTL.SCKI_POL=0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING_EDGE_TX</name>
                  <description>SDO transmitted at SCK rising edge when TX_CTL.SCKI_POL=0</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_NR</name>
              <description>Specifies number of channels per frame:

Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.
(Note: These bits are connected to AR38U12.TX_CFG.TX_CHSET)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CH_NUM1</name>
                  <description>1 channel</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM2</name>
                  <description>2 channels</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM3</name>
                  <description>3 channels</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM4</name>
                  <description>4 channels</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM5</name>
                  <description>5 channels</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM6</name>
                  <description>6 channels</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM7</name>
                  <description>7 channels</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM8</name>
                  <description>8 channels</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MS</name>
              <description>Set interface in master or slave mode:

(Note: This bit is connected to AR38U12.TX_CFG.TX_MS)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <description>Slave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <description>Master</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE</name>
              <description>Select I2S, left-justified or TDM:

(Note: These bits are connected to AR38U12.TX_CFG.TX_I2S_MODE)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEFT_JUSTIFIED</name>
                  <description>Left Justified</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S</name>
                  <description>I2S mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_A</name>
                  <description>TDM mode A, the 1st Channel align to WSO 
Rising Edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_B</name>
                  <description>TDM mode B, the 1st Channel align to WSO
Rising edge with1 SCK Delay</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WS_PULSE</name>
              <description>Set WS pulse width in TDM mode:

(Note: This bit is connected to AR38U12.TX_CFG.TX_WS_PULSE)
Note: When not TDM mode, must be '1'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCK_PERIOD</name>
                  <description>Pulse width is 1 SCK period</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_LENGTH</name>
                  <description>Pulse width is 1 channel length</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVHDATA</name>
              <description>Set overhead value:
'0': Set to '0'
'1': Set to '1'
(Note: This bit is connected to AR38U12.TX_CFG.TX_OVHDATA)</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WD_EN</name>
              <description>Set watchdog for 'tx_ws_in':
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_LEN</name>
              <description>Channel length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- When TDM mode, must be 32-bit length to this field.
(Note: These bits are connected to AR38U12.TX_CFG.TX_CHLEN)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WORD_LEN</name>
              <description>Word length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- Don't configure this field as beyond Channel length.
(Note: These bits are connected to AR38U12.TX_CFG.TX_IWL)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCKO_POL</name>
              <description>TX master bit clock polarity. 
When this bit is 1, the outgoing tx_sck signal is inverted after it has been transmitted from the I2S transceiver core. This bit does not affect the internal serial data transmission timing. The word sync (TX_WS) signal is not affected by this bit setting. 
'0': When transmitter is in master mode, serial data is transmitted from the falling bit clock edge
'1': When transmitter is in master mode, serial data is transmitted from the rising bit clock edge</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKI_POL</name>
              <description>TX slave bit clock polarity. 
When this bit is 1, the incoming tx_sck signal is inverted before it is received by the I2S transceiver core. This bit does not affect the internal serial data transmission timing. The word sync (TX_WS) signal is not affected by this bit setting. See TX_CTL.B_CLOCK_INV for more details.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_WATCHDOG</name>
          <description>Transmitter watchdog</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_COUNTER</name>
              <description>Start value of the TX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTL</name>
          <description>Receiver control</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x440510</resetValue>
          <resetMask>0x3F727F8</resetMask>
          <fields>
            <field>
              <name>B_CLOCK_INV</name>
              <description>Serial data capture is delayed by 0.5 SCK cycles. This bit is valid only in RX master mode.
When set to '1', the serial data will be captured 0.5 SCK cycles later than when set to '0'.

1) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK rising edge
2) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK falling edge that is 0.5 SCK cycles after the SCK rising edge in 1)
3) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK falling edge
4) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK rising edge that is 0.5 SCK cycles after the SCK falling edge in 3)

(Note that this is only the appearance w.r.t. SCK edge, the actual capture timing is derived from an internal clock that runs 8x the SCK frequency). The word sync (RX_WS) signal is not affected by this bit setting. 
Note: When Slave mode, must be '0'.
(Note: This bit is connected to AR38U12.TX_CFG.RX_BCLKINV)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RISING_EDGE_RX</name>
                  <description>SDI received at SCK rising edge when RX_CTL.SCKO_POL=0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING_EDGE_RX</name>
                  <description>SDI received at SCK falling edge when RX_CTL.SCKO_POL=0</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_NR</name>
              <description>Specifies number of channels per frame:

Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.
(Note: These bits are connected to AR38U12.RX_CFG.RX_CHSET)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CH_NUM1</name>
                  <description>1 channel</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM2</name>
                  <description>2 channels</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM3</name>
                  <description>3 channels</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM4</name>
                  <description>4 channels</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM5</name>
                  <description>5 channels</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM6</name>
                  <description>6 channels</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM7</name>
                  <description>7 channels</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM8</name>
                  <description>8 channels</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MS</name>
              <description>Set interface in master or slave mode:

(Note: This bit is connected to AR38U12.TX_CFG.RX_MS)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <description>Slave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <description>Master</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE</name>
              <description>Select I2S, left-justified or TDM:

(Note: These bits are connected to AR38U12.RX_CFG.RX_I2S_MODE)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEFT_JUSTIFIED</name>
                  <description>Left Justified</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S</name>
                  <description>I2S mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_A</name>
                  <description>TDM mode A, the 1st Channel align to WSO 
Rising Edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_B</name>
                  <description>TDM mode B, the 1st Channel align to WSO
Rising edge with1 SCK Delay</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WS_PULSE</name>
              <description>Set WS pulse width in TDM mode:

(Note: This bit is connected to AR38U12.RX_CFG.RX_WS_PULSE)
Note: When not TDM mode, must be '1'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCK_PERIOD</name>
                  <description>Pulse width is 1 SCK period</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_LENGTH</name>
                  <description>Pulse width is 1 channel length</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WD_EN</name>
              <description>Set watchdog for 'rx_ws_in'
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_LEN</name>
              <description>Channel length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- When TDM mode, must be 32-bit length to this field.
(Note: These bits are connected to AR38U12.RX_CFG.RX_CHLEN)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WORD_LEN</name>
              <description>Word length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- Don't configure this field as beyond Channel length.
(Note: These bits are connected to AR38U12.RX_CFG.RX_IWL)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIT_EXTENSION</name>
              <description>When reception word length is shorter than the word length of RX_FIFO_RD, extension mode of upper bit should be set.
'0': Extended by '0'
'1': Extended by sign bit (if MSB word is '1', then it is extended by '1', if MSB is '0' then it is extended by '0')</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKO_POL</name>
              <description>RX master bit clock polarity.
When this bit is 1, the outgoing rx_sck signal is inverted after it has been transmitted from the I2S receiver core. This bit does not affect the internal serial data capture timing. The word sync (RX_WS) signal is not affected by this bit setting.See RX_CTL.B_CLOCK_INV for more details.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKI_POL</name>
              <description>RX slave bit clock polarity.
When this bit is 1, the incoming rx_sck signal is inverted before it is received by the I2S receiver core. This bit does not affect the internal serial data capture timing. The word sync (RX_WS) signal is not affected by this bit setting.
'0': When receiver is in slave mode, serial data is sampled on the rising bit clock edge
'1': When receiver is in slave mode, serial data is sampled on the falling bit clock edge</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_WATCHDOG</name>
          <description>Receiver watchdog</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_COUNTER</name>
              <description>Start value of the RX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTL</name>
          <description>TX FIFO control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the TX FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the TX FIFO and TX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the TX FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer. This field is used only for debugging purposes.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>TX FIFO status</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of entries in the TX FIFO. The field value is in the range [0, 256].</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>TX FIFO read pointer: FIFO location from which a data frame is read by the hardware.This field is used only for debugging purposes.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>TX FIFO write pointer: FIFO location at which a new data frame is written by the host. This field is used only for debugging purposes.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>TX FIFO write</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data written into the TX FIFO. Behavior is similar to that of a PUSH operation. 
Note: Don't access to this register while TX_FIFO_CTL.CLEAR is '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTL</name>
          <description>RX FIFO control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated.
Note: software can configure up to 253 in I2S mode or Left Justified (RX_CTL.I2S_MODE = '0' or '1'). In TDM mode (RX_CTL.I2S_MODE = '2' or '3'), it can configure up to [256 - (RX_CTL.CH_NR+2)].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the RX FIFO and RX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the RX FIFO have no effect. Freeze will not advance the RX FIFO write pointer. This field is used only for debugging purposee.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>RX FIFO status</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of entries in the RX FIFO. The field value is in the range [0, 256].</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>RX FIFO read pointer: FIFO location from which a data frame is read by the host. This field is used only for debugging purposes.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>RX FIFO write pointer: FIFO location at which a new data frame is written by the hardware. This field is used only for debugging purposes.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>RX FIFO read</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will remove the data frame from the RX FIFO; i.e. behavior is similar to that of a POP operation. 
Notes: 
 - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
 - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>RX FIFO silent read</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will NOT remove the data frame from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. This field is used only for debugging purposes.
Notes: 
 - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
 - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TRIGGER_LEVEL in TX_FIFO_CTRL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>TX FIFO is not full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and TX_EMPTY is '1'.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Triggers (sets to '1') when the Tx watchdog event occurs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in RX_FIFO_CTRL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>RX FIFO is not empty.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>RX FIFO is full.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Triggers (sets to '1') when the Rx watchdog event occurs.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="I2S0">
      <name>I2S1</name>
      <baseAddress>0x40A11000</baseAddress>
    </peripheral>
  </peripherals>
</device>