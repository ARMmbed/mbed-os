#! armclang -E --target=arm-arm-none-eabi -x c -mcpu=cortex-m0
; The first line specifies a preprocessor command that the linker invokes
; to pass a scatter file through a C preprocessor.

;*******************************************************************************
;* \file cyb06xx5_cm0plus.sct
;* \version 2.90.1
;*
;* Linker file for the ARMCC.
;*
;* The main purpose of the linker script is to describe how the sections in the
;* input files should be mapped into the output file, and to control the memory
;* layout of the output file.
;*
;* \note The entry point location is fixed and starts at 0x10000000. The valid
;* application image should be placed there.
;*
;* \note The linker files included with the PDL template projects must be
;* generic and handle all common use cases. Your project may not use every
;* section defined in the linker files. In that case you may see the warnings
;* during the build process: L6314W (no section matches pattern) and/or L6329W
;* (pattern only matches removed unused sections). In your project, you can
;* suppress the warning by passing the "--diag_suppress=L6314W,L6329W" option to
;* the linker, simply comment out or remove the relevant code in the linker
;* file.
;*
;*******************************************************************************
;* \copyright
;* Copyright 2016-2020 Cypress Semiconductor Corporation
;* SPDX-License-Identifier: Apache-2.0
;*
;* Licensed under the Apache License, Version 2.0 (the "License");
;* you may not use this file except in compliance with the License.
;* You may obtain a copy of the License at
;*
;*     http://www.apache.org/licenses/LICENSE-2.0
;*
;* Unless required by applicable law or agreed to in writing, software
;* distributed under the License is distributed on an "AS IS" BASIS,
;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;* See the License for the specific language governing permissions and
;* limitations under the License.
;******************************************************************************/

#if !defined(MBED_ROM_START)
  #define MBED_ROM_START    0x10000000
#endif

;* MBED_APP_START is being  used by the bootloader build script and
;* will be calculate by the system. Without bootloader the MBED_APP_START
;* is equal to MBED_ROM_START
;*
#if !defined(MBED_APP_START)
  #define MBED_APP_START    MBED_ROM_START
#endif

#if !defined(MBED_ROM_SIZE)
  #define MBED_ROM_SIZE     0x00010000
#endif

;* MBED_APP_SIZE is being  used by the bootloader build script and
;* will be calculate by the system. Without bootloader the MBED_APP_SIZE
;* is equal to MBED_ROM_SIZE
;*
#if !defined(MBED_APP_SIZE)
  #define MBED_APP_SIZE     MBED_ROM_SIZE
#endif

#if !defined(MBED_RAM_START)
  #define MBED_RAM_START    0x08020000
#endif

#if !defined(MBED_RAM_SIZE)
  #define MBED_RAM_SIZE     0x0000C000
#endif

#if !defined(MBED_PUBLIC_RAM_SIZE)
  #define MBED_PUBLIC_RAM_SIZE     0x200
#endif

; The size of the stack section at the end of CM0+ SRAM
#if !defined(MBED_BOOT_STACK_SIZE)
  #define MBED_BOOT_STACK_SIZE 0x400
#endif

#define STACK_SIZE MBED_BOOT_STACK_SIZE

#if !defined(MBED_PUBLIC_RAM_START)
  #define MBED_PUBLIC_RAM_START    (MBED_RAM_START + MBED_RAM_SIZE - STACK_SIZE - MBED_PUBLIC_RAM_SIZE)
#endif

; The defines below describe the location and size of blocks of memory in the target.
; Use these defines to specify the memory regions available for allocation.

; The following defines control RAM and flash memory allocation for the CM0+ core.
; You can change the memory allocation by editing the RAM and Flash defines.
; Your changes must be aligned with the corresponding defines for the CM4 core in 'xx_cm4_dual.scat',
; where 'xx' is the device group; for example, 'cyb06xx7_cm4_dual.scat'.
; RAM
#define RAM_START               MBED_RAM_START
#define RAM_SIZE                MBED_RAM_SIZE
; Public RAM
#define PUBLIC_RAM_START        MBED_PUBLIC_RAM_START
#define PUBLIC_RAM_SIZE         MBED_PUBLIC_RAM_SIZE
; Flash
#define FLASH_START             MBED_APP_START
#define FLASH_SIZE              MBED_APP_SIZE

; The size of the MCU boot header area at the start of FLASH
#define BOOT_HEADER_SIZE        0x00000400


; The following defines describe device specific memory regions and must not be changed.
; Supervisory flash: User data
#define SFLASH_USER_DATA_START  0x16000800
#define SFLASH_USER_DATA_SIZE   0x00000800

; Supervisory flash: Normal Access Restrictions (NAR)
#define SFLASH_NAR_START        0x16001A00
#define SFLASH_NAR_SIZE         0x00000200

; Supervisory flash: Public Key
#define SFLASH_PUBLIC_KEY_START 0x16005A00
#define SFLASH_PUBLIC_KEY_SIZE  0x00000C00

; Supervisory flash: Table of Content # 2
#define SFLASH_TOC_2_START      0x16007C00
#define SFLASH_TOC_2_SIZE       0x00000200

; Supervisory flash: Table of Content # 2 Copy
#define SFLASH_RTOC_2_START     0x16007E00
#define SFLASH_RTOC_2_SIZE      0x00000200

; External memory
#define XIP_START               0x18000000
#define XIP_SIZE                0x08000000

; eFuse
#define EFUSE_START             0x90700000
#define EFUSE_SIZE              0x100000


; Cortex-M0+ application flash area
LR_IROM1 (FLASH_START + BOOT_HEADER_SIZE) (FLASH_SIZE - BOOT_HEADER_SIZE - 0x8000)
{
    ER_FLASH_VECTORS +0
    {
        * (RESET, +FIRST)
    }

    ER_FLASH_CODE +0 FIXED
    {
        * (InRoot$$Sections)
        * (+RO)
    }

    ER_RAM_VECTORS RAM_START UNINIT
    {
        * (RESET_RAM, +FIRST)
    }

    RW_RAM_DATA +0
    {
        * (.cy_ramfunc)
        * (+RW, +ZI)
    }

    ; Place variables in the section that should not be initialized during the
    ; device startup.
    RW_IRAM1 +0 UNINIT
    {
        * (.noinit)
    }

    RW_IRAM2 PUBLIC_RAM_START UNINIT
    {
        * (.cy_sharedmem)
    }

    ; Application heap area (HEAP)
    ARM_LIB_HEAP  +0 EMPTY RAM_START+RAM_SIZE-STACK_SIZE-ImageLimit(RW_IRAM2)
    {
    }

    ; Stack region growing down
    ARM_LIB_STACK RAM_START+RAM_SIZE EMPTY -STACK_SIZE
    {
    }
}



; Supervisory flash: User data
LR_SFLASH_USER_DATA SFLASH_USER_DATA_START SFLASH_USER_DATA_SIZE
{
    .cy_sflash_user_data +0
    {
        * (.cy_sflash_user_data)
    }
}

; Supervisory flash: Normal Access Restrictions (NAR)
LR_SFLASH_NAR SFLASH_NAR_START SFLASH_NAR_SIZE
{
    .cy_sflash_nar +0
    {
        * (.cy_sflash_nar)
    }
}

; Supervisory flash: Public Key
LR_SFLASH_PUBLIC_KEY SFLASH_PUBLIC_KEY_START SFLASH_PUBLIC_KEY_SIZE
{
    .cy_sflash_public_key +0
    {
        * (.cy_sflash_public_key)
    }
}

; Supervisory flash: Table of Content # 2
LR_SFLASH_TOC_2 SFLASH_TOC_2_START SFLASH_TOC_2_SIZE
{
    .cy_toc_part2 +0
    {
        * (.cy_toc_part2)
    }
}

; Supervisory flash: Table of Content # 2 Copy
LR_SFLASH_RTOC_2 SFLASH_RTOC_2_START SFLASH_RTOC_2_SIZE
{
    .cy_rtoc_part2 +0
    {
        * (.cy_rtoc_part2)
    }
}


; Places the code in the Execute in Place (XIP) section. See the smif driver documentation for details.
LR_EROM XIP_START XIP_SIZE
{
    cy_xip +0
    {
        * (.cy_xip)
    }
}


; eFuse
LR_EFUSE EFUSE_START EFUSE_SIZE
{
    .cy_efuse +0
    {
        * (.cy_efuse)
    }
}


; The section is used for additional metadata (silicon revision, Silicon/JTAG ID, etc.) storage.
CYMETA 0x90500000
{
    .cymeta +0 { * (.cymeta) }
}

/* The following symbols used by the cymcuelftool. */
/* Flash */
#define __cy_memory_0_start 0x10000000
#define __cy_memory_0_length  0x00070000
#define __cy_memory_0_row_size 0x200


/* Supervisory Flash */
#define __cy_memory_2_start    0x16000000
#define __cy_memory_2_length   0x8000
#define __cy_memory_2_row_size 0x200

/* XIP */
#define __cy_memory_3_start    0x18000000
#define __cy_memory_3_length   0x08000000
#define __cy_memory_3_row_size 0x200

/* eFuse */
#define __cy_memory_4_start    0x90700000
#define __cy_memory_4_length   0x100000
#define __cy_memory_4_row_size 1


/* [] END OF FILE */
