/**
 ******************************************************************************
 * @file    shci.h
 * @author  MCD Application Team
 * @brief   HCI command for the system channel
 ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics. 
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the 
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
 */


/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __SHCI_H
#define __SHCI_H

#ifdef __cplusplus
extern "C" {
#endif

  /* Includes ------------------------------------------------------------------*/
#include "mbox_def.h" /* Requested to expose the MB_WirelessFwInfoTable_t structure */

  /* Exported types ------------------------------------------------------------*/

  /* SYSTEM EVENT */
  typedef enum
  {
    WIRELESS_FW_RUNNING = 0x00,
    FUS_FW_RUNNING = 0x01,
  } SHCI_SysEvt_Ready_Rsp_t;

  /* ERROR CODES
   *
   * These error codes are detected on CPU2 side and are send back to the CPU1 via a system
   * notification message. It is up to the application running on CPU1 to manage these errors
   *
   * These errors can be generated by all layers (low level driver, stack, framework infrastructure, etc..)
   */
   typedef enum
   {
     ERR_BLE_INIT = 0,                 /* This event is currently not reported by the CPU2                    */
     ERR_THREAD_LLD_FATAL_ERROR = 125, /* The LLD driver used on 802_15_4 detected a fatal error              */
     ERR_THREAD_UNKNOWN_CMD = 126,     /* The command send by the CPU1 to control the Thread stack is unknown */
     ERR_ZIGBEE_UNKNOWN_CMD = 200,     /* The command send by the CPU1 to control the Zigbee stack is unknown */
   } SCHI_SystemErrCode_t;

#define SHCI_EVTCODE                    ( 0xFF )
#define SHCI_SUB_EVT_CODE_BASE          ( 0x9200 )

  /**
   * THE ORDER SHALL NOT BE CHANGED TO GUARANTEE COMPATIBILITY WITH THE CPU1 DEFINITION
   */
  typedef enum
  {
    SHCI_SUB_EVT_CODE_READY =  SHCI_SUB_EVT_CODE_BASE,
    SHCI_SUB_EVT_ERROR_NOTIF,
    SHCI_SUB_EVT_BLE_NVM_RAM_UPDATE,
    SHCI_SUB_EVT_THREAD_NVM_RAM_UPDATE,
    SHCI_SUB_EVT_NVM_START_WRITE,
    SHCI_SUB_EVT_NVM_END_WRITE,
    SHCI_SUB_EVT_NVM_START_ERASE,
    SHCI_SUB_EVT_NVM_END_ERASE,
    SHCI_SUB_EVT_CODE_CONCURRENT_802154_EVT,
  } SHCI_SUB_EVT_CODE_t;

  /**
   * SHCI_SUB_EVT_CODE_READY
   * This notifies the CPU1 that the CPU2 is now ready to receive commands
   * It reports as well which firmware is running on CPU2 : The wireless stack of the FUS (previously named RSS)
   */
  typedef PACKED_STRUCT{
    SHCI_SysEvt_Ready_Rsp_t sysevt_ready_rsp;
  } SHCI_C2_Ready_Evt_t;

  /**
   * SHCI_SUB_EVT_ERROR_NOTIF
   * This reports to the CPU1 some error form the CPU2
   */
  typedef PACKED_STRUCT{
    SCHI_SystemErrCode_t errorCode;
  } SHCI_C2_ErrorNotif_Evt_t;

  /**
   * SHCI_SUB_EVT_BLE_NVM_RAM_UPDATE
   * This notifies the CPU1 which part of the BLE NVM RAM has been updated so that only the modified
   * section could be written in Flash/NVM
   * StartAddress : Start address of the section that has been modified
   * Size : Size (in bytes) of the section that has been modified
   */
  typedef PACKED_STRUCT{
    uint32_t StartAddress;
    uint32_t Size;
  } SHCI_C2_BleNvmRamUpdate_Evt_t;

  /**
   * SHCI_SUB_EVT_THREAD_NVM_RAM_UPDATE
   * This notifies the CPU1 which part of the OT NVM RAM has been updated so that only the modified
   * section could be written in Flash/NVM
   * StartAddress : Start address of the section that has been modified
   * Size : Size (in bytes) of the section that has been modified
   */
  typedef PACKED_STRUCT{
    uint32_t StartAddress;
    uint32_t Size;
  } SHCI_C2_ThreadNvmRamUpdate_Evt_t;

  /**
   * SHCI_SUB_EVT_NVM_START_WRITE
   * This notifies the CPU1 that the CPU2 has started a write procedure in Flash
   * NumberOfWords : The number of 64bits data the CPU2 needs to write in Flash.
   *                 For each 64bits data, the algorithm as described in AN5289 is executed.
   *                 When this number is reported to 0, it means the Number of 64bits to be written
   *                 was unknown when the procedure has started.
   * When all data are written, the SHCI_SUB_EVT_NVM_END_WRITE event is reported
   */
  typedef PACKED_STRUCT{
    uint32_t NumberOfWords;
  } SHCI_C2_NvmStartWrite_Evt_t;

  /**
   * SHCI_SUB_EVT_NVM_END_WRITE
   * This notifies the CPU1 that the CPU2 has written all expected data in Flash
   */

  /**
   * SHCI_SUB_EVT_NVM_START_ERASE
   * This notifies the CPU1 that the CPU2 has started a erase procedure in Flash
   * NumberOfSectors : The number of sectors the CPU2 needs to erase in Flash.
   *                   For each sector, the algorithm as described in AN5289 is executed.
   *                   When this number is reported to 0, it means the Number of sectors to be erased
   *                   was unknown when the procedure has started.
   * When all sectors are erased, the SHCI_SUB_EVT_NVM_END_ERASE event is reported
   */
  typedef PACKED_STRUCT{
    uint32_t NumberOfSectors;
  } SHCI_C2_NvmStartErase_Evt_t;

  /**
   * SHCI_SUB_EVT_NVM_END_ERASE
   * This notifies the CPU1 that the CPU2 has erased all expected flash sectors
   */

  /* SYSTEM COMMAND */
  typedef PACKED_STRUCT
  {
    /**
     * MetaData holds :
     * 2*32bits for chaining list
     * 1*32bits with BLE header (type + Opcode + Length)
     */
    uint32_t MetaData[3];
  } SHCI_Header_t;

  typedef enum
  {
    SHCI_Success = 0x00,
    SHCI_UNKNOWN_CMD = 0x01,
    SHCI_ERR_UNSUPPORTED_FEATURE = 0x11,
    SHCI_ERR_INVALID_HCI_CMD_PARAMS = 0x12,
    SHCI_ERR_INVALID_PARAMS = 0x42,
    SHCI_FUS_CMD_NOT_SUPPORTED = 0xFF,
  } SHCI_CmdStatus_t;

  typedef enum
  {
    SHCI_8BITS =  0x01,
    SHCI_16BITS = 0x02,
    SHCI_32BITS = 0x04,
  } SHCI_Busw_t;

#define SHCI_OGF                        ( 0x3F )
#define SHCI_OCF_BASE                   ( 0x50 )

  /**
   * THE ORDER SHALL NOT BE CHANGED TO GUARANTEE COMPATIBILITY WITH THE CPU2 DEFINITION
   */
  typedef enum
  {
    SHCI_OCF_C2_RESERVED1 =  SHCI_OCF_BASE,
    SHCI_OCF_C2_RESERVED2,
    SHCI_OCF_C2_FUS_GET_STATE,
    SHCI_OCF_C2_FUS_RESERVED1,
    SHCI_OCF_C2_FUS_FW_UPGRADE,
    SHCI_OCF_C2_FUS_FW_DELETE,
    SHCI_OCF_C2_FUS_UPDATE_AUTH_KEY,
    SHCI_OCF_C2_FUS_LOCK_AUTH_KEY,
    SHCI_OCF_C2_FUS_STORE_USR_KEY,
    SHCI_OCF_C2_FUS_LOAD_USR_KEY,
    SHCI_OCF_C2_FUS_START_WS,
    SHCI_OCF_C2_FUS_RESERVED2,
    SHCI_OCF_C2_FUS_RESERVED3,
    SHCI_OCF_C2_FUS_LOCK_USR_KEY,
    SHCI_OCF_C2_FUS_UNLOAD_USR_KEY,
    SHCI_OCF_C2_FUS_ACTIVATE_ANTIROLLBACK,
    SHCI_OCF_C2_FUS_RESERVED7,
    SHCI_OCF_C2_FUS_RESERVED8,
    SHCI_OCF_C2_FUS_RESERVED9,
    SHCI_OCF_C2_FUS_RESERVED10,
    SHCI_OCF_C2_FUS_RESERVED11,
    SHCI_OCF_C2_FUS_RESERVED12,
    SHCI_OCF_C2_BLE_INIT,
    SHCI_OCF_C2_THREAD_INIT,
    SHCI_OCF_C2_DEBUG_INIT,
    SHCI_OCF_C2_FLASH_ERASE_ACTIVITY,
    SHCI_OCF_C2_CONCURRENT_SET_MODE,
    SHCI_OCF_C2_FLASH_STORE_DATA,
    SHCI_OCF_C2_FLASH_ERASE_DATA,
    SHCI_OCF_C2_RADIO_ALLOW_LOW_POWER,
    SHCI_OCF_C2_MAC_802_15_4_INIT,
    SHCI_OCF_C2_REINIT,
    SHCI_OCF_C2_ZIGBEE_INIT,
    SHCI_OCF_C2_LLD_TESTS_INIT,
    SHCI_OCF_C2_EXTPA_CONFIG,
    SHCI_OCF_C2_SET_FLASH_ACTIVITY_CONTROL,
    SHCI_OCF_C2_BLE_LLD_INIT,
    SHCI_OCF_C2_CONFIG,
    SHCI_OCF_C2_CONCURRENT_GET_NEXT_BLE_EVT_TIME,
    SHCI_OCF_C2_CONCURRENT_ENABLE_NEXT_802154_EVT_NOTIFICATION,
    SHCI_OCF_C2_802_15_4_DEINIT,
  } SHCI_OCF_t;

#define SHCI_OPCODE_C2_FUS_GET_STATE         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_GET_STATE)
/** No command parameters */
/** Response parameters*/
/** It responds a 1 byte value holding FUS State error code when the FUS State value is 0xFF (FUS_STATE_VALUE_ERROR) */
  typedef enum
  {
    FUS_STATE_ERROR_NO_ERROR =  0x00,
    FUS_STATE_ERROR_IMG_NOT_FOUND = 0x01,
    FUS_STATE_ERROR_IMG_CORRUPT = 0x02,
    FUS_STATE_ERROR_IMG_NOT_AUTHENTIC = 0x03,
    FUS_STATE_ERROR_IMG_NOT_ENOUGH_SPACE = 0x04,
    FUS_STATE_ERROR_IMAGE_USRABORT = 0x05,
    FUS_STATE_ERROR_IMAGE_ERSERROR = 0x06,
    FUS_STATE_ERROR_IMAGE_WRTERROR = 0x07,
    FUS_STATE_ERROR_AUTH_TAG_ST_NOTFOUND = 0x08,
    FUS_STATE_ERROR_AUTH_TAG_CUST_NOTFOUND = 0x09,
    FUS_STATE_ERROR_AUTH_KEY_LOCKED = 0x0A,
    FUS_STATE_ERROR_FW_ROLLBACK_ERROR = 0x11,
    FUS_STATE_ERROR_STATE_NOT_RUNNING = 0xFE,
    FUS_STATE_ERROR_ERR_UNKNOWN = 0xFF,
  } SHCI_FUS_GetState_ErrorCode_t;

  enum
  {
    FUS_STATE_VALUE_IDLE =  0x00,
    FUS_STATE_VALUE_FW_UPGRD_ONGOING =  0x10,
    FUS_STATE_VALUE_FW_UPGRD_ONGOING_END = 0x1F,    /* All values between 0x10 and 0x1F has the same meaning */
    FUS_STATE_VALUE_FUS_UPGRD_ONGOING =  0x20,
    FUS_STATE_VALUE_FUS_UPGRD_ONGOING_END =  0x2F,  /* All values between 0x20 and 0x2F has the same meaning */
    FUS_STATE_VALUE_SERVICE_ONGOING =  0x30,
    FUS_STATE_VALUE_SERVICE_ONGOING_END =  0x3F,    /* All values between 0x30 and 0x3F has the same meaning */
    FUS_STATE_VALUE_ERROR =  0xFF,
  };

#define SHCI_OPCODE_C2_FUS_RESERVED1         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED1)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_FW_UPGRADE   (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_FW_UPGRADE)
  /** No structure for command parameters */
  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_FW_DELETE   (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_FW_DELETE)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_UPDATE_AUTH_KEY    (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_UPDATE_AUTH_KEY)
  typedef PACKED_STRUCT{
  uint8_t KeySize;
  uint8_t KeyData[64];
  } SHCI_C2_FUS_UpdateAuthKey_Cmd_Param_t;

  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_LOCK_AUTH_KEY    (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_LOCK_AUTH_KEY)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_STORE_USR_KEY    (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_STORE_USR_KEY)
  /** Command parameters */
  /* List of supported key type */
  enum
  {
    KEYTYPE_NONE =  0x00,
    KEYTYPE_SIMPLE = 0x01,
    KEYTYPE_MASTER = 0x02,
    KEYTYPE_ENCRYPTED = 0x03,
  };

  /* List of supported key size */
  enum
  {
    KEYSIZE_16 =  16,
    KEYSIZE_32 = 32,
  };

  typedef PACKED_STRUCT{
  uint8_t KeyType;
  uint8_t KeySize;
  uint8_t KeyData[32 + 12];
  } SHCI_C2_FUS_StoreUsrKey_Cmd_Param_t;

  /** Response parameters*/
  /** It responds a 1 byte value holding the index given for the stored key */

#define SHCI_OPCODE_C2_FUS_LOAD_USR_KEY         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_LOAD_USR_KEY)
  /** Command parameters */
  /** 1 byte holding the key index value */

  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_START_WS             (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_START_WS)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED2            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED2)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED3            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED3)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_LOCK_USR_KEY         (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_LOCK_USR_KEY)
  /** Command parameters */
  /** 1 byte holding the key index value */

  /** No response parameters*/

#define SHCI_OPCODE_C2_FUS_UNLOAD_USR_KEY       (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_UNLOAD_USR_KEY)
/** No command parameters */
/** 1 byte holding the key index value */

#define SHCI_OPCODE_C2_FUS_ACTIVATE_ANTIROLLBACK  (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_ACTIVATE_ANTIROLLBACK)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED7            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED7)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED8            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED8)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED9            (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED9)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED10           (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED10)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED11           (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED11)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_FUS_RESERVED12           (( SHCI_OGF << 10) + SHCI_OCF_C2_FUS_RESERVED12)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_BLE_INIT                 (( SHCI_OGF << 10) + SHCI_OCF_C2_BLE_INIT)
  /** THE ORDER SHALL NOT BE CHANGED    */
  typedef PACKED_STRUCT{
  uint8_t* pBleBufferAddress;   /**< NOT USED - shall be set to 0 */
  uint32_t BleBufferSize;       /**< NOT USED - shall be set to 0 */

  /**
   * NumAttrRecord
   * Maximum number of attribute records related to all the required characteristics (excluding the services)
   * that can be stored in the GATT database, for the specific BLE user application.
   * For each characteristic, the number of attribute records goes from two to five depending on the characteristic properties:
   *    - minimum of two (one for declaration and one for the value)
   *    - add one more record for each additional property: notify or indicate, broadcast, extended property.
   * The total calculated value must be increased by 9, due to the records related to the standard attribute profile and
   * GAP service characteristics, and automatically added when initializing GATT and GAP layers
   *  - Min value: <number of user attributes> + 9
   *  - Max value: depending on the GATT database defined by user application
   */
  uint16_t NumAttrRecord;

  /**
   * NumAttrServ
   * Defines the maximum number of services that can be stored in the GATT database. Note that the GAP and GATT services
   * are automatically added at initialization so this parameter must be the number of user services increased by two.
   *    - Min value: <number of user service> + 2
   *    - Max value: depending GATT database defined by user application
   */
  uint16_t NumAttrServ;

  /**
   * AttrValueArrSize
   * NOTE: This parameter is ignored by the CPU2 when the parameter "Options" is set to "LL_only" ( see Options description in that structure )
   *
   * Size of the storage area for the attribute values.
   * Each characteristic contributes to the attrValueArrSize value as follows:
   *    - Characteristic value length plus:
   *        + 5 bytes if characteristic UUID is 16 bits
   *        + 19 bytes if characteristic UUID is 128 bits
   *        + 2 bytes if characteristic has a server configuration descriptor
   *        + 2 bytes * NumOfLinks if the characteristic has a client configuration descriptor
   *        + 2 bytes if the characteristic has extended properties
   * Each descriptor contributes to the attrValueArrSize value as follows:
   *    - Descriptor length
   */
  uint16_t AttrValueArrSize;

  /**
   * NumOfLinks
   * Maximum number of BLE links supported
   *    - Min value: 1
   *    - Max value: 8
   */
  uint8_t NumOfLinks;

  /**
   * ExtendedPacketLengthEnable
   * Disable/enable the extended packet length BLE 5.0 feature
   *    - Disable: 0
   *    - Enable: 1
   */
  uint8_t ExtendedPacketLengthEnable;

  /**
   * PrWriteListSize
   * NOTE: This parameter is ignored by the CPU2 when the parameter "Options" is set to "LL_only" ( see Options description in that structure )
   *
   * Maximum number of supported prepare write request
   *    - Min value: given by the macro DEFAULT_PREP_WRITE_LIST_SIZE
   *    - Max value: a value higher than the minimum required can be specified, but it is not recommended
   */
  uint8_t PrWriteListSize;

  /**
   * MblockCount
   * NOTE: This parameter is overwritten by the CPU2 with an hardcoded optimal value when the parameter "Options" is set to "LL_only"
   * ( see Options description in that structure )
   *
   * Number of allocated memory blocks for the BLE stack
   *     - Min value: given by the macro MBLOCKS_CALC
   *     - Max value: a higher value can improve data throughput performance, but uses more memory
   */
  uint8_t MblockCount;

  /**
   * AttMtu
   * NOTE: This parameter is ignored by the CPU2 when the parameter "Options" is set to "LL_only" ( see Options description in that structure )
   *
   * Maximum ATT MTU size supported
   *     - Min value: 23
   *     - Max value: 512
   */
  uint16_t AttMtu;

  /**
   * SlaveSca
   * The sleep clock accuracy (ppm value) that used in BLE connected slave mode to calculate the window widening
   * (in combination with the sleep clock accuracy sent by master in CONNECT_REQ PDU),
   * refer to BLE 5.0 specifications - Vol 6 - Part B - chap 4.5.7 and 4.2.2
   *     - Min value: 0
   *     - Max value: 500 (worst possible admitted by specification)
   */
  uint16_t SlaveSca;

  /**
   * MasterSca
   * The sleep clock accuracy handled in master mode. It is used to determine the connection and advertising events timing.
   * It is transmitted to the slave in CONNEC_REQ PDU used by the slave to calculate the window widening,
   * see SlaveSca and Bluetooth Core Specification v5.0 Vol 6 - Part B - chap 4.5.7 and 4.2.2
   * Possible values:
   *    - 251 ppm to 500 ppm: 0
   *    - 151 ppm to 250 ppm: 1
   *    - 101 ppm to 150 ppm: 2
   *    - 76 ppm to 100 ppm: 3
   *    - 51 ppm to 75 ppm: 4
   *    - 31 ppm to 50 ppm: 5
   *    - 21 ppm to 30 ppm: 6
   *    - 0 ppm to 20 ppm: 7
   */
  uint8_t MasterSca;

  /**
   * LsSource
   * Source for the 32 kHz slow speed clock.
   *    - External crystal LSE: 0 - No calibration
   *    - Others:1 - As the accuracy of this oscillator can vary depending upon external conditions (temperature),
   *      it is calibrated every second to ensure correct behavior of timing sensitive BLE operations
   */
  uint8_t LsSource;

  /**
   * MaxConnEventLength
   * This parameter determines the maximum duration of a slave connection event. When this duration is reached the slave closes
   * the current connections event (whatever is the CE_length parameter specified by the master in HCI_CREATE_CONNECTION HCI command),
   * expressed in units of 625/256 µs (~2.44 µs)
   *    - Min value: 0 (if 0 is specified, the master and slave perform only a single TX-RX exchange per connection event)
   *    - Max value: 1638400 (4000 ms). A higher value can be specified (max 0xFFFFFFFF) but results in a maximum connection time
   *      of 4000 ms as specified. In this case the parameter is not applied, and the predicted CE length calculated on slave is not shortened
   */
  uint32_t MaxConnEventLength;

  /**
   * HsStartupTime
   * Startup time of the high speed (16 or 32 MHz) crystal oscillator in units of 625/256 µs (~2.44 µs).
   *    - Min value: 0
   *    - Max value:  820 (~2 ms). A higher value can be specified, but the value that implemented in stack is forced to ~2 ms
   */
  uint16_t HsStartupTime;

  /**
   * ViterbiEnable
   * Viterbi implementation in BLE LL reception.
   *    - 0: Enable
   *    - 1: Disable
   */
  uint8_t ViterbiEnable;

  /**
   * Options flags
   * - bit 0:   1: LL only                   0: LL + host
   * - bit 1:   1: no service change desc.   0: with service change desc.
   * - bit 2:   1: device name Read-Only     0: device name R/W
   * - bit 7:   1: LE Power Class 1          0: LE Power Classe 2-3
   * - other bits: reserved ( shall be set to 0)
   */
  uint8_t Options;

  /**
   * HwVersion
   * Reserved for future use - shall be set to 0
   */
  uint8_t HwVersion;

  /**
   * Maximum number of connection-oriented channels in initiator mode.
   * Range: 0 .. 64
   */
  uint8_t max_coc_initiator_nbr;

  /**
   * Minimum transmit power in dBm supported by the Controller.
   * Range: -127 .. 20
   */
  int8_t min_tx_power;

  /**
   * Maximum transmit power in dBm supported by the Controller.
   * Range: -127 .. 20
   */
  int8_t max_tx_power;
  } SHCI_C2_Ble_Init_Cmd_Param_t;

  typedef PACKED_STRUCT{
    SHCI_Header_t Header;       /** Does not need to be initialized by the user */
    SHCI_C2_Ble_Init_Cmd_Param_t Param;
  } SHCI_C2_Ble_Init_Cmd_Packet_t;

  /**
   * Options
   * Each definition below may be added together to build the Options value
   * WARNING : Only one definition per bit shall be added to build the Options value
   */
#define SHCI_C2_BLE_INIT_OPTIONS_LL_ONLY                              (1<<0)
#define SHCI_C2_BLE_INIT_OPTIONS_LL_HOST                              (0<<0)

#define SHCI_C2_BLE_INIT_OPTIONS_NO_SVC_CHANGE_DESC                   (1<<1)
#define SHCI_C2_BLE_INIT_OPTIONS_WITH_SVC_CHANGE_DESC                 (0<<1)

#define SHCI_C2_BLE_INIT_OPTIONS_DEVICE_NAME_RO                       (1<<2)
#define SHCI_C2_BLE_INIT_OPTIONS_DEVICE_NAME_RW                       (0<<2)

#define SHCI_C2_BLE_INIT_OPTIONS_POWER_CLASS_1                        (1<<7)
#define SHCI_C2_BLE_INIT_OPTIONS_POWER_CLASS_2_3                      (0<<7)


#define SHCI_OPCODE_C2_THREAD_INIT              (( SHCI_OGF << 10) + SHCI_OCF_C2_THREAD_INIT)
/** No command parameters */
/** No response parameters*/

#define SHCI_OPCODE_C2_DEBUG_INIT              (( SHCI_OGF << 10) + SHCI_OCF_C2_DEBUG_INIT)
  /** Command parameters */
    typedef PACKED_STRUCT
    {
      uint8_t thread_config;
      uint8_t ble_config;
      uint8_t mac_802_15_4_config;
      uint8_t zigbee_config;
    } SHCI_C2_DEBUG_TracesConfig_t;

    typedef PACKED_STRUCT
    {
      uint8_t ble_dtb_cfg;
      uint8_t reserved[3];
    } SHCI_C2_DEBUG_GeneralConfig_t;

    typedef PACKED_STRUCT{
      uint8_t *pGpioConfig;
      uint8_t *pTracesConfig;
      uint8_t *pGeneralConfig;
      uint8_t GpioConfigSize;
      uint8_t TracesConfigSize;
      uint8_t GeneralConfigSize;
    } SHCI_C2_DEBUG_init_Cmd_Param_t;

    typedef PACKED_STRUCT{
      SHCI_Header_t Header;       /** Does not need to be initialized by the user */
      SHCI_C2_DEBUG_init_Cmd_Param_t Param;
    } SHCI_C2_DEBUG_Init_Cmd_Packet_t;
    /** No response parameters*/

#define SHCI_OPCODE_C2_FLASH_ERASE_ACTIVITY     (( SHCI_OGF << 10) + SHCI_OCF_C2_FLASH_ERASE_ACTIVITY)
  /** Command parameters */
    typedef enum
    {
      ERASE_ACTIVITY_OFF =  0x00,
      ERASE_ACTIVITY_ON = 0x01,
    } SHCI_EraseActivity_t;

    /** No response parameters*/

#define SHCI_OPCODE_C2_CONCURRENT_SET_MODE          (( SHCI_OGF << 10) + SHCI_OCF_C2_CONCURRENT_SET_MODE)
/** command parameters */
    typedef enum
    {
      BLE_ENABLE,
      THREAD_ENABLE,
      ZIGBEE_ENABLE,
      MAC_ENABLE,
    } SHCI_C2_CONCURRENT_Mode_Param_t;
      /** No response parameters*/
    
#define SHCI_OPCODE_C2_CONCURRENT_GET_NEXT_BLE_EVT_TIME          (( SHCI_OGF << 10) + SHCI_OCF_C2_CONCURRENT_GET_NEXT_BLE_EVT_TIME)
/** command parameters */
    typedef PACKED_STRUCT
    {
      uint32_t relative_time;
    } SHCI_C2_CONCURRENT_GetNextBleEvtTime_Param_t;
      /** No response parameters*/
    
#define SHCI_OPCODE_C2_CONCURRENT_ENABLE_NEXT_802154_EVT_NOTIFICATION    (( SHCI_OGF << 10) + SHCI_OCF_C2_CONCURRENT_ENABLE_NEXT_802154_EVT_NOTIFICATION)
    /** No command parameters */
    /** No response parameters*/
    
#define SHCI_OPCODE_C2_FLASH_STORE_DATA          (( SHCI_OGF << 10) + SHCI_OCF_C2_FLASH_STORE_DATA)
#define SHCI_OPCODE_C2_FLASH_ERASE_DATA          (( SHCI_OGF << 10) + SHCI_OCF_C2_FLASH_ERASE_DATA)
/** command parameters */
    typedef enum
    {
      BLE_IP,
      THREAD_IP,
      ZIGBEE_IP,
    } SHCI_C2_FLASH_Ip_t;
      /** No response parameters*/

#define SHCI_OPCODE_C2_RADIO_ALLOW_LOW_POWER    (( SHCI_OGF << 10) + SHCI_OCF_C2_RADIO_ALLOW_LOW_POWER)

#define SHCI_OPCODE_C2_MAC_802_15_4_INIT        (( SHCI_OGF << 10) + SHCI_OCF_C2_MAC_802_15_4_INIT)

#define SHCI_OPCODE_C2_REINIT                   (( SHCI_OGF << 10) + SHCI_OCF_C2_REINIT)

#define SHCI_OPCODE_C2_ZIGBEE_INIT              (( SHCI_OGF << 10) + SHCI_OCF_C2_ZIGBEE_INIT)

#define SHCI_OPCODE_C2_LLD_TESTS_INIT           (( SHCI_OGF << 10) + SHCI_OCF_C2_LLD_TESTS_INIT)

#define SHCI_OPCODE_C2_BLE_LLD_INIT             (( SHCI_OGF << 10) + SHCI_OCF_C2_BLE_LLD_INIT)

#define SHCI_OPCODE_C2_EXTPA_CONFIG             (( SHCI_OGF << 10) + SHCI_OCF_C2_EXTPA_CONFIG)
  /** Command parameters */
    enum
    {
      EXT_PA_ENABLED_LOW,
      EXT_PA_ENABLED_HIGH,
    }/* gpio_polarity */;

    enum
    {
      EXT_PA_DISABLED,
      EXT_PA_ENABLED,
    }/* gpio_status */;

    typedef PACKED_STRUCT{
      uint32_t gpio_port;
      uint16_t gpio_pin_number;
      uint8_t gpio_polarity;
      uint8_t gpio_status;
    } SHCI_C2_EXTPA_CONFIG_Cmd_Param_t;

    /** No response parameters*/

#define SHCI_OPCODE_C2_SET_FLASH_ACTIVITY_CONTROL   (( SHCI_OGF << 10) + SHCI_OCF_C2_SET_FLASH_ACTIVITY_CONTROL)
  /** Command parameters */
    typedef enum
    {
      FLASH_ACTIVITY_CONTROL_PES,
      FLASH_ACTIVITY_CONTROL_SEM7,
    }SHCI_C2_SET_FLASH_ACTIVITY_CONTROL_Source_t;

    /** No response parameters*/

#define SHCI_OPCODE_C2_CONFIG   (( SHCI_OGF << 10) + SHCI_OCF_C2_CONFIG)
  /** Command parameters */
    typedef PACKED_STRUCT{
      uint8_t PayloadCmdSize;
      uint8_t Config1;
      uint8_t EvtMask1;
      uint8_t Spare1;
      uint32_t BleNvmRamAddress;
      uint32_t ThreadNvmRamAddress;
    } SHCI_C2_CONFIG_Cmd_Param_t;

#define SHCI_OPCODE_C2_802_15_4_DEINIT    (( SHCI_OGF << 10) + SHCI_OCF_C2_802_15_4_DEINIT)

/**
 * PayloadCmdSize
 * Value that shall be used
 */
#define SHCI_C2_CONFIG_PAYLOAD_CMD_SIZE   (sizeof(SHCI_C2_CONFIG_Cmd_Param_t) - 1)

/**
 * Config1
 * Each definition below may be added together to build the Config1 value
 * WARNING : Only one definition per bit shall be added to build the Config1 value
 */
#define SHCI_C2_CONFIG_CONFIG1_BIT0_BLE_NVM_DATA_TO_INTERNAL_FLASH    (0<<0)
#define SHCI_C2_CONFIG_CONFIG1_BIT0_BLE_NVM_DATA_TO_SRAM              (1<<0)
#define SHCI_C2_CONFIG_CONFIG1_BIT1_THREAD_NVM_DATA_TO_INTERNAL_FLASH (0<<1)
#define SHCI_C2_CONFIG_CONFIG1_BIT1_THREAD_NVM_DATA_TO_SRAM           (1<<1)

/**
 * EvtMask1
 * Each definition below may be added together to build the EvtMask1 value
 */
#define SHCI_C2_CONFIG_EVTMASK1_BIT0_ERROR_NOTIF_ENABLE               (1<<0)
#define SHCI_C2_CONFIG_EVTMASK1_BIT1_BLE_NVM_RAM_UPDATE_ENABLE        (1<<1)
#define SHCI_C2_CONFIG_EVTMASK1_BIT2_THREAD_NVM_RAM_UPDATE_ENABLE         (1<<2)
#define SHCI_C2_CONFIG_EVTMASK1_BIT3_NVM_START_WRITE_ENABLE           (1<<3)
#define SHCI_C2_CONFIG_EVTMASK1_BIT4_NVM_END_WRITE_ENABLE             (1<<4)
#define SHCI_C2_CONFIG_EVTMASK1_BIT5_NVM_START_ERASE_ENABLE           (1<<5)
#define SHCI_C2_CONFIG_EVTMASK1_BIT6_NVM_END_ERASE_ENABLE             (1<<6)

/**
 * BleNvmRamAddress
 * The buffer shall have a size of BLE_NVM_SRAM_SIZE number of 32bits
 * The buffer shall be allocated in SRAM2
 */
#define BLE_NVM_SRAM_SIZE (507)

/**
 * ThreadNvmRamAddress
 * The buffer shall have a size of THREAD_NVM_SRAM_SIZE number of 32bits
 * The buffer shall be allocated in SRAM2
 */
#define THREAD_NVM_SRAM_SIZE (1016)


  /** No response parameters*/

 /* Exported type --------------------------------------------------------*/
#define FUS_DEVICE_INFO_TABLE_VALIDITY_KEYWORD    (0xA94656B9)

/*
  *   At startup, the informations relative to the wireless binary are stored in RAM trough a structure defined by
  *   MB_WirelessFwInfoTable_t.This structure contains 4 fields (Version,MemorySize, Stack_info and a reserved part)
  *   each of those coded on 32 bits as shown on the table below:
  *
  *
  *               |7 |6 |5 |4 |3 |2 |1 |0 |7 |6 |5 |4 |3 |2 |1 |0 |7 |6 |5 |4 |3 |2 |1 |0 |7 |6 |5 |4 |3 |2 |1 |0 |
  *               -------------------------------------------------------------------------------------------------
  * Version       |   Major version       |    Minor version      |    Sub version        | Branch    |ReleaseType|
  *               -------------------------------------------------------------------------------------------------
  * MemorySize    |   SRAM2B (kB)         |    SRAM2A (kB)        |    SRAM1 (kB)         | FLASH (4kb)           |
  *               -------------------------------------------------------------------------------------------------
  * Info stack    |   Reserved            |    Reserved           |    Reserved           | Type (MAC,Thread,BLE) |
  *               -------------------------------------------------------------------------------------------------
  * Reserved      |   Reserved            |    Reserved           |    Reserved           | Reserved              |
  *               -------------------------------------------------------------------------------------------------
  *
  */

/* Field Version */
#define INFO_VERSION_MAJOR_OFFSET                   24
#define INFO_VERSION_MAJOR_MASK                     0xff000000
#define INFO_VERSION_MINOR_OFFSET                   16
#define INFO_VERSION_MINOR_MASK                     0x00ff0000
#define INFO_VERSION_SUB_OFFSET                     8
#define INFO_VERSION_SUB_MASK                       0x0000ff00
#define INFO_VERSION_BRANCH_OFFSET                  4
#define INFO_VERSION_BRANCH_MASK                    0x0000000f0
#define INFO_VERSION_TYPE_OFFSET                    0
#define INFO_VERSION_TYPE_MASK                      0x00000000f

#define INFO_VERSION_TYPE_RELEASE                   1

/* Field Memory */
#define INFO_SIZE_SRAM2B_OFFSET                     24
#define INFO_SIZE_SRAM2B_MASK                       0xff000000
#define INFO_SIZE_SRAM2A_OFFSET                     16
#define INFO_SIZE_SRAM2A_MASK                       0x00ff0000
#define INFO_SIZE_SRAM1_OFFSET                      8
#define INFO_SIZE_SRAM1_MASK                        0x0000ff00
#define INFO_SIZE_FLASH_OFFSET                      0
#define INFO_SIZE_FLASH_MASK                        0x000000ff

/* Field stack information */
#define INFO_STACK_TYPE_OFFSET                      0
#define INFO_STACK_TYPE_MASK                        0x000000ff
#define INFO_STACK_TYPE_NONE                        0

#define INFO_STACK_TYPE_BLE_FULL                    0x01
#define INFO_STACK_TYPE_BLE_HCI                     0x02
#define INFO_STACK_TYPE_BLE_LIGHT                   0x03
#define INFO_STACK_TYPE_BLE_BEACON                  0x04
#define INFO_STACK_TYPE_THREAD_FTD                  0x10
#define INFO_STACK_TYPE_THREAD_MTD                  0x11
#define INFO_STACK_TYPE_ZIGBEE_FFD                  0x30
#define INFO_STACK_TYPE_ZIGBEE_RFD                  0x31
#define INFO_STACK_TYPE_MAC                         0x40
#define INFO_STACK_TYPE_BLE_THREAD_FTD_STATIC       0x50
#define INFO_STACK_TYPE_BLE_THREAD_FTD_DYAMIC       0x51
#define INFO_STACK_TYPE_802154_LLD_TESTS            0x60
#define INFO_STACK_TYPE_802154_PHY_VALID            0x61
#define INFO_STACK_TYPE_BLE_PHY_VALID               0x62
#define INFO_STACK_TYPE_BLE_LLD_TESTS               0x63
#define INFO_STACK_TYPE_BLE_RLV                     0x64
#define INFO_STACK_TYPE_802154_RLV                  0x65
#define INFO_STACK_TYPE_BLE_ZIGBEE_FFD_STATIC       0x70
#define INFO_STACK_TYPE_BLE_ZIGBEE_RFD_STATIC       0x71
#define INFO_STACK_TYPE_BLE_ZIGBEE_FFD_DYNAMIC      0x78
#define INFO_STACK_TYPE_BLE_ZIGBEE_RFD_DYNAMIC      0x79
#define INFO_STACK_TYPE_RLV                         0x80
#define INFO_STACK_TYPE_BLE_MAC_STATIC              0x90

typedef struct {
/**
 * Wireless Info
 */
  uint8_t VersionMajor;
  uint8_t VersionMinor;
  uint8_t VersionSub;
  uint8_t VersionBranch;
  uint8_t VersionReleaseType;
  uint8_t MemorySizeSram2B;     /*< Multiple of 1K */
  uint8_t MemorySizeSram2A;     /*< Multiple of 1K */
  uint8_t MemorySizeSram1;      /*< Multiple of 1K */
  uint8_t MemorySizeFlash;      /*< Multiple of 4K */
  uint8_t StackType;
/**
 * Fus Info
 */
  uint8_t FusVersionMajor;
  uint8_t FusVersionMinor;
  uint8_t FusVersionSub;
  uint8_t FusMemorySizeSram2B;  /*< Multiple of 1K */
  uint8_t FusMemorySizeSram2A;  /*< Multiple of 1K */
  uint8_t FusMemorySizeFlash;   /*< Multiple of 4K */
}WirelessFwInfo_t;


/* Exported functions ------------------------------------------------------- */

  /**
  * SHCI_C2_FUS_GetState
  * @brief Read the FUS State
  *        If the user is not interested by the Error code response, a null value may
  *        be passed as parameter
  *
  *        Note:  This command is fully supported only by the FUS.
  *               When the wireless firmware receives that command, it responds SHCI_FUS_CMD_NOT_SUPPORTED the first time.
  *               When the wireless firmware receives that command a second time, it reboots the full device with the FUS running on CPU2
  *
  * @param  p_rsp : return the error code when the FUS State Value = 0xFF
  * @retval FUS State Values
  */
  uint8_t SHCI_C2_FUS_GetState( SHCI_FUS_GetState_ErrorCode_t *p_rsp );

  /**
  * SHCI_C2_FUS_FwUpgrade
  * @brief Request the FUS to install the CPU2 firmware update
  *        Note:  This command is only supported by the FUS.
  *
  * @param  fw_src_add: Address of the firmware image location
  * @param  fw_dest_add: Address of the firmware destination
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_FwUpgrade( uint32_t fw_src_add,  uint32_t fw_dest_add );

  /**
  * SHCI_C2_FUS_FwDelete
  * @brief Delete the wireless stack on CPU2
  *        Note:  This command is only supported by the FUS.
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_FwDelete( void );

  /**
  * SHCI_C2_FUS_UpdateAuthKey
  * @brief Request the FUS to update the authentication key
  *        Note:  This command is only supported by the FUS.
  *
  * @param  pCmdPacket
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_UpdateAuthKey( SHCI_C2_FUS_UpdateAuthKey_Cmd_Param_t *pParam );

  /**
  * SHCI_C2_FUS_LockAuthKey
  * @brief Request the FUS to prevent any future update of the authentication key
  *        Note:  This command is only supported by the FUS.
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_LockAuthKey( void );

  /**
  * SHCI_C2_FUS_StoreUsrKey
  * @brief Request the FUS to store the user key
  *        Note:  This command is supported by both the FUS and the wireless stack.
  *
  * @param  pParam : command parameter
  * @param  p_key_index : Index allocated by the FUS to the stored key
  *
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_StoreUsrKey( SHCI_C2_FUS_StoreUsrKey_Cmd_Param_t *pParam, uint8_t *p_key_index );

  /**
  * SHCI_C2_FUS_LoadUsrKey
  * @brief Request the FUS to load the user key into the AES
  *        Note:  This command is supported by both the FUS and the wireless stack.
  *
  * @param  key_index : index of the user key to load in AES1
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_LoadUsrKey( uint8_t key_index );

  /**
  * SHCI_C2_FUS_StartWs
  * @brief Request the FUS to reboot on the wireless stack
  *        Note:  This command is only supported by the FUS.
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_StartWs( void );

  /**
  * SHCI_C2_FUS_LockUsrKey
  * @brief Request the FUS to lock the user key so that it cannot be updated later on
  *        Note:  This command is supported by both the FUS and the wireless stack.
  *
  * @param  key_index : index of the user key to lock
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_LockUsrKey( uint8_t key_index );

  /**
  * SHCI_C2_FUS_UnloadUsrKey
  * @brief Request the FUS to Unload the user key so that the CPU1 may use the AES with another Key
  *        Note:  This command is supported by both the FUS and the wireless stack.
  *
  * @param  key_index : index of the user key to unload
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_UnloadUsrKey( uint8_t key_index );

  /**
  * SHCI_C2_FUS_ActivateAntiRollback
  * @brief Request the FUS to enable the AntiRollback feature so that it is not possible to update the wireless firmware
  *        with an older version than the current one.
  *        Note:
  *               - This command is only supported by the FUS.
  *               - Once this feature is enabled, it is not possible anymore to disable it.
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FUS_ActivateAntiRollback( void );

  /**
  * SHCI_C2_BLE_Init
  * @brief Provides parameters and starts the BLE Stack
  *
  * @param  pCmdPacket : Parameters are described SHCI_C2_Ble_Init_Cmd_Packet_t declaration
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_BLE_Init( SHCI_C2_Ble_Init_Cmd_Packet_t *pCmdPacket );

  /**
  * SHCI_C2_THREAD_Init
  * @brief Starts the THREAD Stack
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_THREAD_Init( void );

  /**
  * SHCI_C2_LLDTESTS_Init
  * @brief Starts the LLD tests CLI
  *
  * @param  param_size : Nb of bytes
  * @param  p_param : pointeur with data to give from M4 to M0
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_LLDTESTS_Init( uint8_t param_size, uint8_t * p_param );

    /**
  * SHCI_C2_BLE_LLD_Init
  * @brief Starts the LLD tests BLE
  *
  * @param  param_size : Nb of bytes
  * @param  p_param : pointeur with data to give from M4 to M0
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_BLE_LLD_Init( uint8_t param_size, uint8_t * p_param );
  
    /**
  * SHCI_C2_ZIGBEE_Init
  * @brief Starts the Zigbee Stack
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_ZIGBEE_Init( void );
  
  /**
  * SHCI_C2_DEBUG_Init
  * @brief Starts the Traces
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_DEBUG_Init( SHCI_C2_DEBUG_Init_Cmd_Packet_t *pCmdPacket );

  /**
  * SHCI_C2_FLASH_EraseActivity
  * @brief Provides the information of the start and the end of a flash erase window on the CPU1
  *
  * @param  erase_activity: Start/End of erase activity
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FLASH_EraseActivity( SHCI_EraseActivity_t erase_activity );

  /**
  * SHCI_C2_CONCURRENT_SetMode
  * @brief Enable/Disable Thread on CPU2 (M0+)
  *
  * @param  Mode: BLE or Thread enable flag
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_CONCURRENT_SetMode( SHCI_C2_CONCURRENT_Mode_Param_t Mode );
    
  /**
  * SHCI_C2_CONCURRENT_GetNextBleEvtTime
  * @brief Get the next BLE event date (relative time)
  *
  * @param  Command Packet
  * @retval None
  */
  SHCI_CmdStatus_t SHCI_C2_CONCURRENT_GetNextBleEvtTime( SHCI_C2_CONCURRENT_GetNextBleEvtTime_Param_t *pParam );
    
  /**
  * SHCI_C2_CONCURRENT_EnableNext_802154_EvtNotification
  * @brief Activate the next 802.15.4 event notification (one shot)
  *
  * @param  None
  * @retval None
  */
  SHCI_CmdStatus_t SHCI_C2_CONCURRENT_EnableNext_802154_EvtNotification( void );

  /**
  * SHCI_C2_FLASH_StoreData
  * @brief Store Data in Flash
  *
  * @param  Ip: BLE or THREAD
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FLASH_StoreData( SHCI_C2_FLASH_Ip_t Ip );

  /**
  * SHCI_C2_FLASH_EraseData
  * @brief Erase Data in Flash
  *
  * @param  Ip: BLE or THREAD
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_FLASH_EraseData( SHCI_C2_FLASH_Ip_t Ip );

  /**
  * SHCI_C2_RADIO_AllowLowPower
  * @brief Allow or forbid IP_radio (802_15_4 or BLE) to enter in low power mode.
  *
  * @param  Ip: BLE or 802_15_5
  * @param  FlagRadioLowPowerOn: True or false
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_RADIO_AllowLowPower( SHCI_C2_FLASH_Ip_t Ip,uint8_t  FlagRadioLowPowerOn);


  /**
  * SHCI_C2_MAC_802_15_4_Init
  * @brief Starts the MAC 802.15.4 on M0
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_MAC_802_15_4_Init( void );

  /**
   * SHCI_GetWirelessFwInfo
   * @brief This function read back the informations relative to the wireless binary loaded.
   *         Refer yourself to MB_WirelessFwInfoTable_t structure to get the significance
   *         of the different parameters returned.
   * @param  pWirelessInfo : Pointer to WirelessFwInfo_t.
   *
   * @retval SHCI_Success
   */
  SHCI_CmdStatus_t SHCI_GetWirelessFwInfo( WirelessFwInfo_t* pWirelessInfo );

  /**
  * SHCI_C2_Reinit
  * @brief This is required to allow the CPU1 to fake a set C2BOOT when it has already been set.
  *        In order to fake a C2BOOT, the CPU1 shall :
  *        - Send SHCI_C2_Reinit()
  *        - call SEV instruction
  *        WARNING:
  *        This function is intended to be used by the SBSFU
  *
  * @param  None
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_Reinit( void );

  /**
  * SHCI_C2_ExtpaConfig
  * @brief Send the Ext PA configuration
  *        When the CPU2 receives the command, it controls the Ext PA as requested by the configuration
  *        This configures only which IO is used to enable/disable the ExtPA and the associated polarity
  *        This command has no effect on the other IO that is used to control the mode of the Ext PA (Rx/Tx)
  *
  * @param gpio_port: GPIOx where x can be (A..F) to select the GPIO peripheral for STM32WBxx family
  * @param gpio_pin_number: This parameter can be one of GPIO_PIN_x (= LL_GPIO_PIN_x)  where x can be (0..15).
  * @param gpio_polarity: This parameter can be either
  *                       - EXT_PA_ENABLED_LOW: ExtPA is enabled when GPIO is low
  *                       - EXT_PA_ENABLED_HIGH: ExtPA is enabled when GPIO is high
  * @param gpio_status: This parameter can be either
  *                       - EXT_PA_DISABLED: Stop driving the ExtPA
  *                       - EXT_PA_ENABLED: Drive the ExtPA according to radio activity
  *                                          (ON before the Event and OFF at the end of the event)
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_ExtpaConfig(uint32_t gpio_port, uint16_t gpio_pin_number, uint8_t gpio_polarity, uint8_t gpio_status);

  /**
  * SHCI_C2_SetFlashActivityControl
  * @brief Set the mechanism to be used on CPU2 to prevent the CPU1 to either write or erase in flash
  *
  * @param Source: It can be one of the following list
  *                -  FLASH_ACTIVITY_CONTROL_PES : The CPU2 set the PES bit to prevent the CPU1 to either read or write in flash
  *                -  FLASH_ACTIVITY_CONTROL_SEM7 : The CPU2 gets the semaphore 7 to prevent the CPU1 to either read or write in flash.
  *                                                 This requires the CPU1 to first get semaphore 7 before erasing or writing the flash.
  *
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_SetFlashActivityControl(SHCI_C2_SET_FLASH_ACTIVITY_CONTROL_Source_t Source);

  /**
  * SHCI_C2_Config
  * @brief Send the system configuration to the CPU2
  *
  * @param pCmdPacket: address of the buffer holding following parameters
  *                    uint8_t PayloadCmdSize : Size of the payload - shall be SHCI_C2_CONFIG_PAYLOAD_CMD_SIZE
  *                    uint8_t Config1 :
  *                     - bit0 :  0 - BLE NVM Data  data are flushed in internal secure flash
  *                               1 - BLE NVM Data are written in SRAM cache pointed by BleNvmRamAddress
  *                     - bit1 :  0 - THREAD NVM Data  data are flushed in internal secure flash
  *                               1 - THREAD NVM Data are written in SRAM cache pointed by ThreadNvmRamAddress
  *                     - bit2 to bit7 : Unused, shall be set to 0
  *                    uint8_t EvtMask1 :
  *                            When a bit is set to 0, the event is not reported
  *                            bit0 : Asynchronous Event with Sub Evt Code 0x9201 (= SHCI_SUB_EVT_ERROR_NOTIF)
  *                            ...
  *                            bit31 : Asynchronous Event with Sub Evt Code 0x9220
  *                    uint8_t Spare1 : Unused, shall be set to 0
  *                    uint32_t BleNvmRamAddress :
  *                               Only considered when Config1.bit0 = 1
  *                               When set to 0, data are kept in internal SRAM on CPU2
  *                               Otherwise, data are copied in the cache pointed by BleNvmRamAddress
  *                               The size of the buffer shall be BLE_NVM_SRAM_SIZE (number of 32bits)
  *                               The buffer shall be allocated in SRAM2
  *                    uint32_t ThreadNvmRamAddress :
  *                               Only considered when Config1.bit1 = 1
  *                               When set to 0, data are kept in internal SRAM on CPU2
  *                               Otherwise, data are copied in the cache pointed by ThreadNvmRamAddress
  *                               The size of the buffer shall be THREAD_NVM_SRAM_SIZE (number of 32bits)
  *                               The buffer shall be allocated in SRAM2
  *
  *                    Please check macro definition to be used for this function
  *                    They are defined in this file next to the definition of SHCI_OPCODE_C2_CONFIG
  *
  * @retval Status
  */
  SHCI_CmdStatus_t SHCI_C2_Config(SHCI_C2_CONFIG_Cmd_Param_t *pCmdPacket);

  /**
   * SHCI_C2_802_15_4_DeInit
   * @brief Deinit 802.15.4 layer (to be used before entering StandBy mode)
   *
   * @param  None
   * @retval Status
   */
  SHCI_CmdStatus_t SHCI_C2_802_15_4_DeInit( void );

  #ifdef __cplusplus
}
#endif

#endif /*__SHCI_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
